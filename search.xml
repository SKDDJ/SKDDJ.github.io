<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机操作系统</title>
      <link href="/article/dbeddcc1.html"/>
      <url>/article/dbeddcc1.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一章：概述"><a href="#第一章：概述" class="headerlink" title="第一章：概述"></a>第一章：概述</h2><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202308291710176.jpg"></p><h3 id="1-1-操作系统概念引入"><a href="#1-1-操作系统概念引入" class="headerlink" title="1.1 操作系统概念引入"></a>1.1 操作系统概念引入</h3><ul><li>操作系统<ul><li>外部<ul><li>虚拟机</li><li>用户环境</li></ul></li><li>内部<ul><li>作业管理</li><li>资源管理</li></ul></li></ul></li></ul><h3 id="1-2-操作系统的主要功能"><a href="#1-2-操作系统的主要功能" class="headerlink" title="1.2 操作系统的主要功能"></a>1.2 操作系统的主要功能</h3><h4 id="1-2-1-用户接口"><a href="#1-2-1-用户接口" class="headerlink" title="1.2.1 用户接口"></a>1.2.1 用户接口</h4><table><thead><tr><th>OS提供给用户交互命令集合</th><th></th><th></th></tr></thead><tbody><tr><td>用户操作的方式</td><td></td><td>应用程序编程接口</td></tr><tr><td>CLI(command line interface)</td><td>GUI(graphic user interface)</td><td>API(application programming interface)</td></tr></tbody></table><h4 id="1-2-2-处理机管理功能"><a href="#1-2-2-处理机管理功能" class="headerlink" title="1.2.2 处理机管理功能"></a>1.2.2 处理机管理功能</h4><table><thead><tr><th>进程管理</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>控制</td><td>调度</td><td>同步</td><td>通信</td></tr><tr><td>controling</td><td>scheduling</td><td>synchronization</td><td>communication</td></tr></tbody></table><h4 id="1-2-3-存储器管理功能"><a href="#1-2-3-存储器管理功能" class="headerlink" title="1.2.3 存储器管理功能"></a>1.2.3 存储器管理功能</h4><table><thead><tr><th>内存管理</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>分配</td><td>保护</td><td>映射</td><td>扩展</td></tr><tr><td>allocation</td><td>protection</td><td>mapping</td><td>extension</td></tr></tbody></table><h4 id="1-2-4-设备管理功能"><a href="#1-2-4-设备管理功能" class="headerlink" title="1.2.4 设备管理功能"></a>1.2.4 设备管理功能</h4><table><thead><tr><th>I&#x2F;O管理</th><th></th><th></th></tr></thead><tbody><tr><td>缓冲</td><td>分配</td><td>驱动</td></tr><tr><td>buffering</td><td>allocation</td><td>driving</td></tr></tbody></table><h4 id="1-2-5-文件管理功能"><a href="#1-2-5-文件管理功能" class="headerlink" title="1.2.5 文件管理功能"></a>1.2.5 文件管理功能</h4><table><thead><tr><th>文件管理</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>存储</td><td>结构</td><td>读写</td><td>安全</td></tr><tr><td>storage</td><td>organization</td><td>operation</td><td>security</td></tr></tbody></table><h3 id="1-3-操作系统的发展"><a href="#1-3-操作系统的发展" class="headerlink" title="1.3 操作系统的发展"></a>1.3 操作系统的发展</h3><h3 id="1-4-多道与分时系统"><a href="#1-4-多道与分时系统" class="headerlink" title="1.4 多道与分时系统"></a>1.4 多道与分时系统</h3><h4 id="1-4-1-单道批处理系统"><a href="#1-4-1-单道批处理系统" class="headerlink" title="1.4.1 单道批处理系统"></a>1.4.1 单道批处理系统</h4><p>批处理： batch processing</p><p>Program A “Run” wait “Run” -&gt;</p><p>主要特征：自动性、顺序性、单道性</p><h4 id="1-4-2-多道批处理系统"><a href="#1-4-2-多道批处理系统" class="headerlink" title="1.4.2 多道批处理系统"></a>1.4.2 多道批处理系统</h4><p>内存中存放多个作业运行</p><h5 id="1-4-2-1-优点："><a href="#1-4-2-1-优点：" class="headerlink" title="1.4.2.1 优点："></a>1.4.2.1 优点：</h5><ol><li>提高 CPU 利用率</li><li>提高 I&#x2F;O 利用率</li><li>提高系统吞吐率</li></ol><h5 id="1-4-2-2-需解决的问题"><a href="#1-4-2-2-需解决的问题" class="headerlink" title="1.4.2.2 需解决的问题"></a>1.4.2.2 需解决的问题</h5><ol><li>作业管理： 组织作业运行</li><li>处理机管理： 分配和控制 CPU</li><li>存储器管理： 内存分配和回收</li><li>I&#x2F;O 设备管理：I&#x2F;O 设备的分配和操纵</li><li>文件管理： 文件的存取、共享和保护</li></ol><h4 id="1-4-3-分时系统-Time-Sharing"><a href="#1-4-3-分时系统-Time-Sharing" class="headerlink" title="1.4.3 分时系统 Time Sharing"></a>1.4.3 分时系统 Time Sharing</h4><p>时间片 time slice<br>时间中断 time interupt</p><h5 id="1-4-3-1-个人电脑-Personal-Computer"><a href="#1-4-3-1-个人电脑-Personal-Computer" class="headerlink" title="1.4.3.1 个人电脑 Personal Computer"></a>1.4.3.1 个人电脑 Personal Computer</h5><h5 id="1-4-3-2-分布式系统-Distributed-System"><a href="#1-4-3-2-分布式系统-Distributed-System" class="headerlink" title="1.4.3.2 分布式系统  Distributed System"></a>1.4.3.2 分布式系统  Distributed System</h5><ul><li>支持分布式服务</li><li>系统之间数据共享</li><li>多处理器 SMP</li><li>异构性（CPU、GPU）</li><li>高可用、高可靠</li></ul><h6 id="一、同时性-concurrency-x2F-parallelisim"><a href="#一、同时性-concurrency-x2F-parallelisim" class="headerlink" title="一、同时性 concurrency&#x2F;parallelisim"></a>一、同时性 concurrency&#x2F;parallelisim</h6><p>并行：同一时刻，多个处理机<br>并发：同一时间间隔，单个处理机交替运行</p><h6 id="二、-共享"><a href="#二、-共享" class="headerlink" title="二、 共享"></a>二、 共享</h6><p>系统内资源供内存中并发程序使用</p><h6 id="三、-虚拟-Hypervisor"><a href="#三、-虚拟-Hypervisor" class="headerlink" title="三、 虚拟 Hypervisor"></a>三、 虚拟 Hypervisor</h6><p>一个物理实体 -&gt; 多个逻辑上的对应物</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309051656188.jpg" alt="企业级、云计算"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309051657420.jpg" alt="个人用户"></p><p><strong>SOTA: Container</strong></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309051657172.jpg" alt="Docker、K8S"></p><p><strong>LibOS</strong></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309051658835.jpg" alt="LibOS"></p><h6 id="四、-不确定性"><a href="#四、-不确定性" class="headerlink" title="四、 不确定性"></a>四、 不确定性</h6><p>同一输入可能不同输出</p><ol><li>异步</li><li>随机</li></ol><h3 id="1-5-实时系统及操作系统结构"><a href="#1-5-实时系统及操作系统结构" class="headerlink" title="1.5 实时系统及操作系统结构"></a>1.5 实时系统及操作系统结构</h3><h3 id="1-6-操作系统的体系结构"><a href="#1-6-操作系统的体系结构" class="headerlink" title="1.6 操作系统的体系结构"></a>1.6 操作系统的体系结构</h3><h4 id="1-6-1-操作系统的基本特征"><a href="#1-6-1-操作系统的基本特征" class="headerlink" title="1.6.1 操作系统的基本特征"></a>1.6.1 操作系统的基本特征</h4><ol><li>concurrency</li><li>sharing</li><li>virtualization</li><li>non-determinism</li></ol><h2 id="第二章：进程与调度"><a href="#第二章：进程与调度" class="headerlink" title="第二章：进程与调度"></a>第二章：进程与调度</h2><h3 id="2-1-进程的描述与控制"><a href="#2-1-进程的描述与控制" class="headerlink" title="2.1 进程的描述与控制"></a>2.1 进程的描述与控制</h3><h4 id="2-1-1-Concept"><a href="#2-1-1-Concept" class="headerlink" title="2.1.1 Concept"></a>2.1.1 Concept</h4><blockquote><p>一个具有独立功能的程序在一个数据集合上的一次动态执行过程。</p></blockquote><h4 id="2-1-2-Feature"><a href="#2-1-2-Feature" class="headerlink" title="2.1.2 Feature"></a>2.1.2 Feature</h4><ol><li>动态性<br>进程对应程序的执行<br>进程是动态产生，动态消亡的</li><li>独立性<br>各进程的地址空间相互独立，除非采用进程间通信手段</li><li>并发性<br>任何进程都可以同其他进程一起向前推进</li><li>异步性<br>每个进程都以其相对独立的不可预知的速度向前推进</li><li>结构化<br>进程 &#x3D; 代码段 + 数据段 + PCB</li></ol><h4 id="2-1-3-The-Difference-Between-Process-and-Program"><a href="#2-1-3-The-Difference-Between-Process-and-Program" class="headerlink" title="2.1.3 The Difference Between Process and Program"></a>2.1.3 The Difference Between Process and Program</h4><ol><li>进程是动态的，程序是静态的：程序是有序代码的集合；通常对应着文件、静态和可以复制。进程是程序的执行。</li><li>进程是暂时的，程序是永久的：进程是一个状态变化的过程，程序可长久保存。</li><li>进程与程序的组成不同：进程的组成包括程序、数据和PCB(进程控制块)。</li><li>进程能真实地描述并发，而程序不能</li><li>进程可创建其他进程，而程序不能</li><li>同一程序同时运行于若干个数据集合上，它将属于若干个不同的进程$\to$一个程序可对应多个进程</li><li>进程是资源申请和系统调度的基本单位</li></ol><h4 id="2-1-4-Challenges"><a href="#2-1-4-Challenges" class="headerlink" title="2.1.4 Challenges"></a>2.1.4 Challenges</h4><ol><li>空间开销（space overhead）</li><li>时间开销（time overhead）</li><li>控制复杂性（control complexity）</li></ol><h4 id="2-1-5-Three-States"><a href="#2-1-5-Three-States" class="headerlink" title="2.1.5 Three States"></a>2.1.5 Three States</h4><ol><li>就绪态（Ready） ：一个进程已经具备运行条件，但由于无CPU暂时不能运行的状态。当调度给其CPU时，立即可以运行。位于“就绪队列”中</li><li>执行态（Running） ：进程占有了包括CPU在内的全部资源，并在CPU上运行</li><li>等待态（阻塞态，Waiting&#x2F;Blocked）：进程因等待某种事件的发生而暂时不能运行的状态（即使CPU空闲，该进程也不可运行）。位于“等待队列”中</li></ol><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309062203172.jpg" alt="三状态"></p><h4 id="2-1-6-Five-States"><a href="#2-1-6-Five-States" class="headerlink" title="2.1.6 Five States"></a>2.1.6 Five States</h4><p>Addition:</p><ol><li>新建状态</li></ol><p>OS已完成为创建进程所必要的工作<br>已构造了进程标识符；已创建了管理进程所需的表格<br>但还没有允许执行该进程<br>OS所需的关于该进程的信息保存在主存的进程表中，但进程自身还未进入主存，也没有为与这个程序相关的数据分配空间，程序保留在辅存中。</p><ol start="2"><li>退出状态</li></ol><p>它不再有执行资格<br>表格和其它信息暂时由辅助程序保留</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309062205976.jpg" alt="五状态"></p><h4 id="2-1-7-Swapping-amp-Suspend"><a href="#2-1-7-Swapping-amp-Suspend" class="headerlink" title="2.1.7 Swapping &amp; Suspend"></a>2.1.7 Swapping &amp; Suspend</h4><blockquote><p>Problems:</p><ol><li>主存中同时有多个进程</li><li>I&#x2F;O速度比计算速度慢很多 </li><li>其他作业因没有主存空间不能投入运行</li></ol></blockquote><ul><li>交换（Swapping）<ul><li>挂起（Suspend）：把进程从内存转到外存</li><li>激活（Activate&#x2F;Resume）：把进程从外存转到内存</li></ul></li><li>那么古尔丹，代价是什么：I&#x2F;O 操作比较耗时</li></ul><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309062209418.jpg" alt="具有挂起状态的进程状态图"></p><h5 id="2-1-7-1-双挂起"><a href="#2-1-7-1-双挂起" class="headerlink" title="2.1.7.1 双挂起"></a>2.1.7.1 双挂起</h5><ol><li>就绪(Ready)：进程在内存且可立即进入运行状态（活动就绪）；</li><li>阻塞(Blocked)：进程在内存，并等待某事件的出现（活动阻塞）；</li><li>阻塞 &#x2F; 挂起（Blocked, suspend）：进程在外存并等待某事件的出现；</li><li>就绪 &#x2F; 挂起（Ready, suspend）：进程在外存，但只要进入内存，即可运行；<br><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309062210404.jpg"></li></ol><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309062211241.jpg" alt="实际Linux 系统"></p><h3 id="2-2-进程调度"><a href="#2-2-进程调度" class="headerlink" title="2.2 进程调度"></a>2.2 进程调度</h3><h4 id="2-2-1-内核功能-Kernel-Function"><a href="#2-2-1-内核功能-Kernel-Function" class="headerlink" title="2.2.1 内核功能 Kernel Function"></a>2.2.1 内核功能 Kernel Function</h4><blockquote><p>一些与硬件紧密相关的模块或运行频率较高的模块，公用基本操作模块等常驻内存，便于提高操作系统运行效能的软件，称为操作系统的内核。</p></blockquote><ol><li>进程管理：创建、撤消、调度、控制</li><li>存储管理：分配或回收空间、虚拟存储管理等。</li><li>I&#x2F;O设备管理：设备、通道的分配和回收、设备的管理、虚拟设备的实现等。</li><li>中断处理：操作系统的重要活动都依赖于中断。</li></ol><h4 id="2-2-2-原语-Primitive"><a href="#2-2-2-原语-Primitive" class="headerlink" title="2.2.2 原语 Primitive"></a>2.2.2 原语 Primitive</h4><p>由若干机器指令构成用以完成特定功能的一段程序，并在执行中不可分割的<br>操作系统内核的功能大都通过执行各种原语实现<br>原子操作<br>在一个操作中的所有动作，要么全做，要么全不做<br>All-or-None</p><h4 id="2-2-3-PCB-Process-Control-Block"><a href="#2-2-3-PCB-Process-Control-Block" class="headerlink" title="2.2.3 PCB(Process Control Block)"></a>2.2.3 PCB(Process Control Block)</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309071635913.jpg"><br>进程控制块的信息：</p><ul><li>进程标识符 pid<br>惟一地标识一个进程：为每一个进程赋予一个惟一的数字标识符，方便系统使用。</li><li>父进程 ppid</li><li>用户 uid</li></ul><h5 id="2-2-3-1-进程控制块的组织方式"><a href="#2-2-3-1-进程控制块的组织方式" class="headerlink" title="2.2.3.1 进程控制块的组织方式"></a>2.2.3.1 进程控制块的组织方式</h5><ul><li>链接<br><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309071637511.jpg"></li><li>索引<br><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309071639732.jpg"></li></ul><h5 id="2-2-3-2-Linux-task-struct-partial-s"><a href="#2-2-3-2-Linux-task-struct-partial-s" class="headerlink" title="2.2.3.2 Linux task_struct (partial)s"></a>2.2.3.2 Linux task_struct (partial)s</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">&#123;</span>  <span class="token comment">/* these are hardcoded - don't touch */</span>  <span class="token comment">/*-1 unrunnable, 0 runnable, >0 stopped */</span>  <span class="token keyword">volatile</span> <span class="token keyword">long</span>        state<span class="token punctuation">;</span>   <span class="token keyword">long</span>                 priority<span class="token punctuation">;</span>  <span class="token comment">/* per process flags */</span>  <span class="token keyword">unsigned</span>             <span class="token keyword">long</span> flags<span class="token punctuation">;</span>   <span class="token keyword">int</span> errno<span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token class-name">task_struct</span>   <span class="token operator">*</span>next_task<span class="token punctuation">,</span> <span class="token operator">*</span>prev_task<span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token class-name">task_struct</span>   <span class="token operator">*</span>next_run<span class="token punctuation">,</span>  <span class="token operator">*</span>prev_run<span class="token punctuation">;</span>  <span class="token class-name">pid_t</span>                pid<span class="token punctuation">;</span>  <span class="token comment">/* memory management info */</span>  <span class="token keyword">struct</span> <span class="token class-name">mm_struct</span>     <span class="token operator">*</span>mm<span class="token punctuation">;</span>  <span class="token comment">/* signal handlers */</span>  <span class="token keyword">struct</span> <span class="token class-name">signal_struct</span> <span class="token operator">*</span>sig<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-3-3-进程在内存中的样子"><a href="#2-2-3-3-进程在内存中的样子" class="headerlink" title="2.2.3.3 进程在内存中的样子"></a>2.2.3.3 进程在内存中的样子</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309071641876.jpg"></p><h5 id="2-2-3-4-homework1"><a href="#2-2-3-4-homework1" class="headerlink" title="2.2.3.4 homework1"></a>2.2.3.4 homework1</h5><p>Linux内核有list.h，理解其设计原理，体会其设计思想<br>实现一个简单的进程管理程序。使用 list.h 维护不同状态的进程。</p><h5 id="2-2-3-5-进程组织"><a href="#2-2-3-5-进程组织" class="headerlink" title="2.2.3.5 进程组织"></a>2.2.3.5 进程组织</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309071643462.jpg"></p><p>解释了为什么使用 ssh 连接远程服务器执行命令后退出 ssh 连接，会话内的进程会被 kill，因为所有会话中的父命令是 sshd</p><h5 id="2-2-3-6-进程的创建流程"><a href="#2-2-3-6-进程的创建流程" class="headerlink" title="2.2.3.6 进程的创建流程"></a>2.2.3.6 进程的创建流程</h5><ul><li>进程的创建<ul><li>申请空白PCB（process control block）</li><li>为新进程分配资源（内存、文件等）</li><li>初始化PCB数据结构</li><li>将新进程插入就绪队列</li></ul></li><li>创建新进程后<ul><li>父进程与子进程并发执行</li><li>父进程等待，直到某个或者全部子进程执行完毕。</li></ul></li></ul><h4 id="2-2-4-进程控制相关-API"><a href="#2-2-4-进程控制相关-API" class="headerlink" title="2.2.4 进程控制相关 API"></a>2.2.4 进程控制相关 API</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309071647392.jpg"></p><h5 id="2-2-4-1-关于-fork-创建新进程"><a href="#2-2-4-1-关于-fork-创建新进程" class="headerlink" title="2.2.4.1 关于 fork()-创建新进程"></a>2.2.4.1 关于 fork()-创建新进程</h5><ul><li>调用格式： pid &#x3D; fork()</li><li>在调用fork之后，父进程和子进程均在下一条语句上继续运行。</li><li>父、子进程的fork返回值不同<ul><li>失败：返回 -1</li><li>在子进程中返回时，pid为0；</li><li>在父进程中返回时，pid为所创建的子进程pid</li></ul></li></ul><p>两个关键点：</p><ol><li>运行顺序</li></ol><p>父子进程的运行是无关的，运行顺序也不固定。<br>若要求父子进程运行顺序一定，则要用到进程间通信。</p><ol start="2"><li>数据共享</li></ol><p>除了子进程标识符和其PCB结构中的某些特性参数不同之外，子进程是父进程的精确复制。</p><p><strong>调用 fork() 的例子</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> global <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> pid<span class="token punctuation">;</span>   <span class="token keyword">int</span> local <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span>“before fork\n”<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">printf</span><span class="token punctuation">(</span>“fork error\n”<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  global<span class="token operator">++</span><span class="token punctuation">;</span>  local<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">printf</span><span class="token punctuation">(</span>“global<span class="token operator">=</span><span class="token operator">%</span>d<span class="token punctuation">,</span>        local<span class="token operator">=</span><span class="token operator">%</span>d\n”<span class="token punctuation">,</span>        global<span class="token punctuation">,</span> local<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>父进程输出:<br>global&#x3D;4, local&#x3D;5</p><p>子进程输出:<br>global&#x3D;5, local&#x3D;4</p><p>原因就是fork后变量值的独立性,子进程中的修改不会影响父进程中的同名变量。</p><h5 id="2-2-4-2-写时拷贝"><a href="#2-2-4-2-写时拷贝" class="headerlink" title="2.2.4.2 写时拷贝"></a>2.2.4.2 写时拷贝</h5><ul><li>COW：copy-on-write</li><li>共享：精确拷贝</li><li>修改：创建新的memory map<ul><li>OS自动完成，用户透明</li></ul></li><li>例外<ul><li>文件句柄</li></ul></li></ul><h5 id="2-2-4-3-exec-执行一个文件的调用"><a href="#2-2-4-3-exec-执行一个文件的调用" class="headerlink" title="2.2.4.3 exec()-执行一个文件的调用"></a>2.2.4.3 exec()-执行一个文件的调用</h5><ul><li>子进程如何执行一个新的程序？<ul><li>通过exec() 调用族，加载新的程序文件</li></ul></li><li>子进程可以拥有自己的可执行代码，即用一个新进程覆盖调用进程。</li><li>参数包括新进程对应的文件和命令行参数<ul><li>成功调用时，不再返回；</li><li>否则，返回出错原因。</li></ul></li></ul><blockquote><p>在大多数程序中，系统调用fork和exec是结合在一起使用的。父进程生成一个子进程，然后通过调用exec覆盖该子进程</p></blockquote><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309071657740.jpg" alt="本例若exec 执行成功则不会打印 ending"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309071659846.jpg" alt="InterestingQuestion"></p><blockquote><p>“else { global +&#x3D; 2; }” is a pit. It won’t be executed.</p></blockquote><h4 id="2-2-5-进程的终止"><a href="#2-2-5-进程的终止" class="headerlink" title="2.2.5 进程的终止"></a>2.2.5 进程的终止</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309071801646.jpg"></p><p>进程的终止过程：</p><p>检索PCB，检查进程状态；</p><p>执行态$\to$中止；</p><p>有无子孙需终止；</p><p>归还资源给其父进程或系统；</p><p>从PCB队列中移出PCB。</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309072211069.jpg" alt="UNIX进程终止"></p><h4 id="2-2-6-waitpid"><a href="#2-2-6-waitpid" class="headerlink" title="2.2.6 waitpid()"></a>2.2.6 waitpid()</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309141657202.jpg" alt="example"><br>由于这个进程由当前会话创建，所以返回值 5 会在最后返回<br><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309141658216.jpg" alt="output"></p><h4 id="2-2-7-进程切换"><a href="#2-2-7-进程切换" class="headerlink" title="2.2.7 进程切换"></a>2.2.7 进程切换</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309141707711.jpg"></p><h4 id="2-2-8-Linux-中的系统调用过程"><a href="#2-2-8-Linux-中的系统调用过程" class="headerlink" title="2.2.8 Linux 中的系统调用过程"></a>2.2.8 Linux 中的系统调用过程</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309141708440.jpg"></p><h3 id="2-3-线程"><a href="#2-3-线程" class="headerlink" title="2.3 线程"></a>2.3 线程</h3><p>recap：</p><p>two features of process:</p><ol><li>资源所有权：一个进程包括一个保存进程映像的虚地址空间，并且不时地被分配给对资源的控制或所有权</li><li>调度&#x2F;执行：一个具有执行状态和调度优先级的进程是一个被操作系统调度并分配的实体</li></ol><blockquote><p>为区分这两个特点，调度并分派的部分通常称为线程或轻量级进程（light-weight process），而资源所有权的部分通常称为进程。</p></blockquote><h4 id="2-3-1-线程的优势"><a href="#2-3-1-线程的优势" class="headerlink" title="2.3.1 线程的优势"></a>2.3.1 线程的优势</h4><ol><li>减少并发执行时的时空开销<br>进程的创建、撤消、切换开销较大</li><li>线程是系统独立调度的基本单位<br>基本不拥有系统资源，只有少量资源（PC，寄存器，栈），<strong>共享其所属进程所拥有的全部资源。</strong></li></ol><blockquote><p>线程阻塞不一定会引起进程阻塞</p></blockquote><h4 id="2-3-2-线程数据"><a href="#2-3-2-线程数据" class="headerlink" title="2.3.2 线程数据"></a>2.3.2 线程数据</h4><ul><li>状态参数<ul><li>寄存器状态</li><li>堆栈</li><li>优先级</li><li>线程专有存储器<ul><li>TLS：Thread Local Storage</li></ul></li><li>信号屏蔽</li><li>运行状态</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309141715455.jpg"></p><h4 id="2-3-3-线程状态"><a href="#2-3-3-线程状态" class="headerlink" title="2.3.3 线程状态"></a>2.3.3 线程状态</h4><ol><li>派生（Spawn)：当产生一个新进程时，同时也为该进程派生了一个线程，随后，可以在同一个进程中派生另一个线程，新线程被放置在就绪队列中。</li><li>结束（Finish）：线程完成时，其寄存器信息和栈都被释放。</li><li>就绪（Ready）</li><li>运行（Running）</li><li>阻塞（Blocked)：当线程需要等待一个事件时，它将阻塞，此时处理器转而执行另一个就绪线程。</li></ol><h4 id="2-3-4-内核线程和用户线程的不同"><a href="#2-3-4-内核线程和用户线程的不同" class="headerlink" title="2.3.4 内核线程和用户线程的不同"></a>2.3.4 内核线程和用户线程的不同</h4><ol><li>调度开销</li></ol><ul><li>内核级线程切换类似于进程切换，开销较大。</li><li>用户级线程切换发生在同一用户进程内，无需进入内核，更快。</li></ul><ol start="2"><li>并发效率</li></ol><ul><li>用户线程：某一个线程阻塞，由于内核不知道这些线程的存在，因此将进程阻塞。</li><li>内核线程：某一线程阻塞，则阻塞该线程，进程（其它线程）仍可运行。</li></ul><ol start="3"><li>执行时间</li></ol><ul><li>用户级线程以进程为单位平均分配时间，对线程间并发执行不利（一个CPU）。</li><li>内核级线程以线程为单位分配时间（多个CPU）。</li></ul><h4 id="2-3-5-线程实例（以-Linux-为例）"><a href="#2-3-5-线程实例（以-Linux-为例）" class="headerlink" title="2.3.5 线程实例（以 Linux 为例）"></a>2.3.5 线程实例（以 Linux 为例）</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NUM_THREADS</span>     <span class="token expression"><span class="token number">5</span></span></span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">PrintHello</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>threadid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">long</span> tid<span class="token punctuation">;</span>   tid <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>threadid<span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World! It's me, thread #%ld!\n"</span><span class="token punctuation">,</span> tid<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token class-name">pthread_t</span> threads<span class="token punctuation">[</span>NUM_THREADS<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> rc<span class="token punctuation">;</span>   <span class="token keyword">long</span> t<span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>t<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> t<span class="token operator">&lt;</span>NUM_THREADS<span class="token punctuation">;</span> t<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"In main: creating thread %ld\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>      rc <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>threads<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> PrintHello<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>rc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ERROR; return code from pthread_create() is %d\n"</span><span class="token punctuation">,</span> rc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span>   <span class="token comment">/* Last thing that main() should do */</span>   <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有一个 trick，为了传入线程的 id 同时保证能够在线程函数中重新定义变量类型，将线程 id 当成引用<code>(void *)t</code> 传入进去来“欺骗”编译器。</p><h5 id="课后练习："><a href="#课后练习：" class="headerlink" title="课后练习："></a>课后练习：</h5><blockquote><p>阅读了解.NET Task异步工作机制，思考其与线程的关系</p></blockquote><h3 id="2-4-处理机调度"><a href="#2-4-处理机调度" class="headerlink" title="2.4 处理机调度"></a>2.4 处理机调度</h3><h4 id="2-4-1-调度方式"><a href="#2-4-1-调度方式" class="headerlink" title="2.4.1 调度方式"></a>2.4.1 调度方式</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309231739012.jpg"></p><p>三种调度的触发事件</p><ul><li>长程：任务创建</li><li>中程：交换</li><li>短程：时间片&#x2F;事件发生&#x2F;抢占</li></ul><h4 id="2-4-2-单处理机调度"><a href="#2-4-2-单处理机调度" class="headerlink" title="2.4.2 单处理机调度"></a>2.4.2 单处理机调度</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309231741618.jpg" alt="三级调度"></p><h4 id="2-4-3-调度原则"><a href="#2-4-3-调度原则" class="headerlink" title="2.4.3 调度原则"></a>2.4.3 调度原则</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309231742772.jpg"></p><h4 id="2-4-4-调度算法"><a href="#2-4-4-调度算法" class="headerlink" title="2.4.4 调度算法"></a>2.4.4 调度算法</h4><h5 id="2-4-4-1-FCFS"><a href="#2-4-4-1-FCFS" class="headerlink" title="2.4.4.1 FCFS"></a>2.4.4.1 FCFS</h5><p>先来先服务——FCFS(First-Come-First-Served)<br><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309231744510.jpg"><br>评价</p><ul><li>非抢占调度</li><li>对长进程有利，不利于短进程</li><li>适合CPU繁忙型进程，不适合I&#x2F;O繁忙型进程（系统角度）</li><li><strong>不能直接用于分时系统</strong></li><li>往往与其它调度算法综合使用</li></ul><h5 id="2-4-4-2-SJF"><a href="#2-4-4-2-SJF" class="headerlink" title="2.4.4.2 SJF"></a>2.4.4.2 SJF</h5><p>最短作业优先——SJF(Shortest Job First)</p><ol><li>非剥夺，当前进程结束后，选择所需处理时间最短的进程。</li><li>如果两个进程剩余时间相同，则使用FCFS来调度。</li></ol><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309231746915.jpg"></p><p>评价</p><ul><li>有利于短进程，提高了平均周转时间</li><li>长进程可能被饿死（starvation）</li><li>需要知道或估计每个进程的处理时间</li></ul><h5 id="2-4-4-3-RR"><a href="#2-4-4-3-RR" class="headerlink" title="2.4.4.3 RR"></a>2.4.4.3 RR</h5><p>轮转调度——RR(Round Robin)</p><ol><li>时间片调度(time slicing)：以一定的时间间隔周期性产生时钟中断，当前正在运行的进程被置于就绪队列尾，然后基于FCFS选择下一个就绪进程运行。</li><li>时间片的长度从几ms~几百ms</li><li>专门为分时系统设计</li></ol><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309231748909.jpg"><br>时间片长度变化的影响</p><ul><li>过长：退化为FCFS，进程在一个时间片内执行完</li><li>过短：用户的一次请求需要多个时间片才能处理完，上下文切换次数增加</li></ul><p>评价</p><ul><li>相对公平</li><li>偏向于CPU型的进程</li><li>中断开销</li></ul><h5 id="2-4-4-4-SRT"><a href="#2-4-4-4-SRT" class="headerlink" title="2.4.4.4 SRT"></a>2.4.4.4 SRT</h5><p>最短剩余时间调度——SRT(Shortest Remaining Time)</p><ol><li>对SJF增加了剥夺机制</li><li>选择预期剩余时间最短的进程，当一个新进程加入就绪队列时，它可能比当前运行的进程具有更短的剩余时间</li></ol><h5 id="2-4-4-5-基于优先权-x2F-级的调度算法"><a href="#2-4-4-5-基于优先权-x2F-级的调度算法" class="headerlink" title="2.4.4.5 基于优先权&#x2F;级的调度算法"></a>2.4.4.5 基于优先权&#x2F;级的调度算法</h5><ul><li>优先级<ul><li>每个进程设有一个优先级，调度程序选择具有较高优先级的进程。</li></ul></li><li>静态优先级(static)<ul><li>优先数在进程创建时分配，生存期内不变。</li><li>响应速度慢，开销小。</li><li>适合批处理进程</li></ul></li><li>动态优先级(dynamic)<ul><li>进程创建时继承优先级，生存期内可以修改。</li><li>响应速度快，开销大。</li></ul></li></ul><h5 id="2-4-4-6-HRRN"><a href="#2-4-4-6-HRRN" class="headerlink" title="2.4.4.6 HRRN"></a>2.4.4.6 HRRN</h5><p>高响应比优先算法——HRRN(Highest Response Ratio Next)</p><ol><li>非抢占式</li><li>响应比R  R＝周转时间&#x2F;服务时间&#x3D;(w＋s)&#x2F;s</li></ol><p>w＝等待时间, s＝服务时间</p><h4 id="2-4-5-实时调度"><a href="#2-4-5-实时调度" class="headerlink" title="2.4.5 实时调度"></a>2.4.5 实时调度</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309231756345.jpg"></p><h5 id="2-4-5-1-LLF"><a href="#2-4-5-1-LLF" class="headerlink" title="2.4.5.1 LLF"></a>2.4.5.1 LLF</h5><p>LLF : Least Laxity First</p><p>松弛度 &#x3D; 完成截止时间 - 当前时间 - 剩余执行时间</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309231757492.jpg"><br>类似 RR</p><h4 id="2-4-6-多处理机调度"><a href="#2-4-6-多处理机调度" class="headerlink" title="2.4.6 多处理机调度"></a>2.4.6 多处理机调度</h4><h5 id="2-4-6-1-SQMS-Single-Queue-Multi-Scheduling"><a href="#2-4-6-1-SQMS-Single-Queue-Multi-Scheduling" class="headerlink" title="2.4.6.1 SQMS(Single Queue Multi Scheduling)"></a>2.4.6.1 SQMS(Single Queue Multi Scheduling)</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309231759580.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309231800977.jpg"></p><h5 id="2-4-6-2-MQMS-Multiple-Queues-Multi-Scheduling"><a href="#2-4-6-2-MQMS-Multiple-Queues-Multi-Scheduling" class="headerlink" title="2.4.6.2 MQMS(Multiple Queues Multi Scheduling)"></a>2.4.6.2 MQMS(Multiple Queues Multi Scheduling)</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309231801813.jpg"><br>问题： 负载均衡 load imbalance</p><p>解决方案： Migration &amp; Work Stealing</p><h5 id="2-4-6-3-成组调度——Gang-scheduling"><a href="#2-4-6-3-成组调度——Gang-scheduling" class="headerlink" title="2.4.6.3 成组调度——Gang scheduling"></a>2.4.6.3 成组调度——Gang scheduling</h5><p>优点：</p><ul><li>对相互合作的进（线）程组调度，可以减小切换，减小系统开销。</li><li>每次分配一组CPU，减少了调度频率。</li></ul><h5 id="2-4-6-4-专用处理机分配——Dedicated-Processor-Assignment"><a href="#2-4-6-4-专用处理机分配——Dedicated-Processor-Assignment" class="headerlink" title="2.4.6.4 专用处理机分配——Dedicated Processor Assignment"></a>2.4.6.4 专用处理机分配——Dedicated Processor Assignment</h5><ul><li>特点：每个进（线）程专用处理机，使其切换小，提高效率。</li><li>主要用于大型计算，实时系统</li></ul><p>Sony PlayStation 3 (PPU&#x2F;SPU) $\to$ CELL<br>神威太湖之光：众核（4+256)</p><h3 id="2-5-进程并发"><a href="#2-5-进程并发" class="headerlink" title="2.5 进程并发"></a>2.5 进程并发</h3><h4 id="2-5-1-进程并发控制：互斥-mutual-exclusion-与同步-synchronization"><a href="#2-5-1-进程并发控制：互斥-mutual-exclusion-与同步-synchronization" class="headerlink" title="2.5.1 进程并发控制：互斥(mutual exclusion)与同步(synchronization)"></a>2.5.1 进程并发控制：互斥(mutual exclusion)与同步(synchronization)</h4><blockquote><ol><li>异步性</li><li>独占性</li><li>协作完成</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309231807130.jpg"></p><h3 id="2-6-进程、死锁与饥饿"><a href="#2-6-进程、死锁与饥饿" class="headerlink" title="2.6 进程、死锁与饥饿"></a>2.6 进程、死锁与饥饿</h3><h4 id="2-6-1-忙等、饥饿、死锁"><a href="#2-6-1-忙等、饥饿、死锁" class="headerlink" title="2.6.1 忙等、饥饿、死锁"></a>2.6.1 忙等、饥饿、死锁</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309231808671.jpg"></p><h5 id="2-6-1-1-活锁（livelock）"><a href="#2-6-1-1-活锁（livelock）" class="headerlink" title="2.6.1.1 活锁（livelock）"></a>2.6.1.1 活锁（livelock）</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309231808029.jpg"></p><h4 id="2-6-2-Dekker’s-algorithm"><a href="#2-6-2-Dekker’s-algorithm" class="headerlink" title="2.6.2 Dekker’s algorithm"></a>2.6.2 Dekker’s algorithm</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309271938692.jpg"></p><h4 id="2-6-3-Peterson’s-algorithm"><a href="#2-6-3-Peterson’s-algorithm" class="headerlink" title="2.6.3 Peterson’s algorithm"></a>2.6.3 Peterson’s algorithm</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309271939542.jpg"></p><h4 id="2-6-4-硬件方法"><a href="#2-6-4-硬件方法" class="headerlink" title="2.6.4 硬件方法"></a>2.6.4 硬件方法</h4><ul><li>硬件方法<ul><li>屏蔽中断</li><li>机器指令<ul><li>Test &amp; Set</li><li>Exchange<blockquote><p>原子性：all or nothing</p></blockquote></li></ul></li></ul></li></ul><h5 id="2-6-4-1-Test-amp-Set"><a href="#2-6-4-1-Test-amp-Set" class="headerlink" title="2.6.4.1 Test &amp; Set"></a>2.6.4.1 Test &amp; Set</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309271943372.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309271946187.jpg"></p><h5 id="2-6-4-2-Exchange"><a href="#2-6-4-2-Exchange" class="headerlink" title="2.6.4.2 Exchange"></a>2.6.4.2 Exchange</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309271946906.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309271948489.jpg"></p><h4 id="2-6-5-信号量-Semaphore"><a href="#2-6-5-信号量-Semaphore" class="headerlink" title="2.6.5 信号量(Semaphore)"></a>2.6.5 信号量(Semaphore)</h4><blockquote><p>原理： 多进程通过信号传递协调工作，根据信号指示停止执行（阻塞等待）或者向前推进（唤醒）</p></blockquote><ul><li><p>信号： 信号量 s</p><ul><li>+: 资源数量</li><li>-: 排队数量</li></ul></li><li><p>原语：</p><ul><li>wait(s): 等待信号，并占有资源</li><li>signal(s): 释放资源，并激发信号</li></ul></li></ul><h5 id="2-6-5-1-整数型信号量"><a href="#2-6-5-1-整数型信号量" class="headerlink" title="2.6.5.1 整数型信号量"></a>2.6.5.1 整数型信号量</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309271952246.jpg"></p><h5 id="2-6-5-2-记录型信号量"><a href="#2-6-5-2-记录型信号量" class="headerlink" title="2.6.5.2 记录型信号量"></a>2.6.5.2 记录型信号量</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309271954336.jpg"></p><h4 id="2-6-6-管程-Monitor"><a href="#2-6-6-管程-Monitor" class="headerlink" title="2.6.6 管程 Monitor"></a>2.6.6 管程 Monitor</h4><blockquote><p>共享资源用共享数据结构表示，资源管理程序用对该数据结构进行操作的一组过程来表示</p></blockquote><p>管程的特点：</p><ul><li>模块化（Modularization）<ul><li>管程是一个基本程序单位，可以单独编译;</li></ul></li><li>抽象数据类型（Abstraction)<ul><li>管程中不仅有数据，而且有对数据的操作;</li></ul></li><li>信息隐藏（Encapsulation）<ul><li>管程外可以调用管程内部定义的函数，但函数具体实现外部不可见; </li><li>局部数据变量只能被管程的过程访问，任何外部过程都不能访问。</li></ul></li></ul><p>在任何时候，只能有一个进程在管程中执行。</p><blockquote><p>条件变量提供同步支持（非默认锁）。条件变量包含在管程中，并且只有在管程中才能被访问：</p><ul><li>cwait(x)：调用进程的执行在条件x上挂起，管程现在可被另一进程使用。</li><li>csignal(x)：恢复阻塞在x上的进程。</li></ul></blockquote><p>条件变量不完全等同 “信号量”</p><p>csignal(x)时，如果等待x的队列为空，则信号无任何作用（丢失），而信号量会保留其值</p><h4 id="2-6-7-信号量的应用"><a href="#2-6-7-信号量的应用" class="headerlink" title="2.6.7 信号量的应用"></a>2.6.7 信号量的应用</h4><h5 id="2-6-7-1-信号量类型"><a href="#2-6-7-1-信号量类型" class="headerlink" title="2.6.7.1 信号量类型"></a>2.6.7.1 信号量类型</h5><ul><li>互斥信号量<ul><li>mutex</li><li>binary semaphore</li></ul></li><li>资源信号量<ul><li>general semaphore</li><li>counting semaphore</li></ul></li></ul><h5 id="2-6-7-2-图书馆问题"><a href="#2-6-7-2-图书馆问题" class="headerlink" title="2.6.7.2 图书馆问题"></a>2.6.7.2 图书馆问题</h5><p>图书馆有N个座位，一张登记表，要求：</p><ul><li>读者进入时需先登记，取得座位号；</li><li>出来时注销<br><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310152139313.jpg"></li></ul><h5 id="2-6-7-3-公交车场景"><a href="#2-6-7-3-公交车场景" class="headerlink" title="2.6.7.3 公交车场景"></a>2.6.7.3 公交车场景</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310152140166.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310152141457.jpg"></p><h4 id="2-6-8-经典同步问题"><a href="#2-6-8-经典同步问题" class="headerlink" title="2.6.8 经典同步问题"></a>2.6.8 经典同步问题</h4><h5 id="2-6-8-1-生产者-x2F-消费者问题"><a href="#2-6-8-1-生产者-x2F-消费者问题" class="headerlink" title="2.6.8.1 生产者&#x2F;消费者问题"></a>2.6.8.1 生产者&#x2F;消费者问题</h5><ul><li>生产者：满则等待，空则填充</li><li>消费者：空则等待，有则获取</li><li>不允许同时进入缓冲区</li></ul><ol><li>无限缓冲（Infinite Buffer）</li></ol><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310152143241.jpg"></p><p>方案<br><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310152143431.jpg"></p><ol start="2"><li>有限循环&#x2F;环形缓冲区</li></ol><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310152145681.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310152146906.jpg"></p><ol start="3"><li>有限循环P&#x2F;V操作<br><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310152147194.jpg"></li></ol><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>有3个进程PA，PB和PC合作解决文件打印问题：</p><ul><li>PA将文件记录从磁盘读入主存的缓冲区1，每执行一次读一个记录;</li><li>PB将缓冲区1的内容复制到缓冲区2，每执行一次复制一个记录；</li><li>PC将缓冲区2的内容打印出来，每执行一次打印一个记录。缓冲区的大小等于一个记录大小。</li></ul><p>请用P，V操作来保证文件的正确打印。</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310152153410.jpg"></p><p><strong>sem</strong></p><ol><li>empty1，empty2：分别表示缓冲区1及缓冲区2是否为空，初值为1。</li><li>full1，full2：分别表示缓冲区1及缓冲区2是否有记录可供处理，初值为0。</li><li>mutex1，mutex2：分别表示缓冲区1及缓冲区2的访问控制，初值为1。</li></ol><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310152154737.jpg"></p><h5 id="2-6-8-2-读者-x2F-写者问题-Readers-Writers-Problem"><a href="#2-6-8-2-读者-x2F-写者问题-Readers-Writers-Problem" class="headerlink" title="2.6.8.2 读者&#x2F;写者问题 Readers-Writers Problem"></a>2.6.8.2 读者&#x2F;写者问题 Readers-Writers Problem</h5><ul><li>三个角色<ul><li>一个共享的数据区；</li><li>Reader: 只读取这个数据区的进程；</li><li>Write: 只往数据区中写数据的进程；</li></ul></li><li>三个条件<ul><li>多个Reader可同时读数据区；</li><li>一次只有一个Writer可以往数据区写；</li><li>数据区不允许同时读写。</li></ul></li></ul><ol><li>读者优先<blockquote><p>允许读者插队</p></blockquote></li></ol><p><strong>信号量</strong></p><ul><li>wsem：互斥信号量，用于Writers互斥Writers和Readers，以及第一个Reader互斥Writers</li><li>readcount：统计同时读数据的Readers个数</li><li>mutex：对变量readcount互斥算术操作</li></ul><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310152157502.jpg"></p><ol start="2"><li>写者优先</li></ol><p><strong>新增信号量</strong></p><ul><li>rsem：信号量，当至少有一个写者申请写数据时互斥新的读者进入读数据</li><li>writecount：用于控制rsem信号量</li><li>mwc：信号量，控制对writecount的互斥加减操作</li></ul><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310152200197.jpg"></p><blockquote><p>P(z)多此一举</p></blockquote><h5 id="2-6-8-3-理发师问题-Sleeping-Barber-Problem"><a href="#2-6-8-3-理发师问题-Sleeping-Barber-Problem" class="headerlink" title="2.6.8.3 理发师问题 Sleeping Barber Problem"></a>2.6.8.3 理发师问题 Sleeping Barber Problem</h5><ul><li>角色和资源<ul><li>一个理发师</li><li>一个理发椅</li><li>一排座位</li><li>随机到来的客户</li></ul></li><li>场景<ul><li>理发师：有客干活，无客睡觉</li><li>客户：唤醒理发师，有位等待，无位离开</li></ul></li></ul><p><strong>信号量</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* # of customers waiting */</span>semaphore customers <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* barber status */</span>semaphore barbers <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token comment">/* mutual exclusion to access seats */</span>semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">/* # of available seats. */</span><span class="token keyword">int</span> nas <span class="token operator">=</span> N<span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310152210282.jpg"></p><h5 id="2-6-8-4-哲学家就餐问题-Dinning-Philosopher-Problem"><a href="#2-6-8-4-哲学家就餐问题-Dinning-Philosopher-Problem" class="headerlink" title="2.6.8.4 哲学家就餐问题 Dinning Philosopher Problem"></a>2.6.8.4 哲学家就餐问题 Dinning Philosopher Problem</h5><ul><li>5个哲学家围坐一张餐桌</li><li>5只餐叉（筷子）间隔摆放</li><li>思考或进餐</li><li>进餐时必须同时拿到两边的餐叉</li><li>思考时将餐叉放回原处<br><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310152210254.jpg"></li></ul><p><strong>服务生方法 Conductor&#x2F;Waiter Solution</strong></p><blockquote><p>最多允许4个哲学家同时进食</p></blockquote><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310152225199.jpg"></p><p><strong>资源分级方案1 Resource hierarchy solution</strong></p><ul><li>为资源（餐叉）分配一个偏序（partial order）或者分级（hierarchy）的关系，所有资源都按此顺序获取，按相反顺序释放。</li><li>给哲学家编号，奇数号的哲学家必须首先拿左边的筷子，偶数号的哲学家则反之。<br><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310152227591.jpg"><br><strong>普通方案</strong><br>为了避免死锁，把哲学家分为三种状态：</li></ul><ol><li>思考</li><li>饥饿</li><li>进食</li></ol><p>如果取筷子，每次要么拿到两只筷子，要么一只不拿。</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310152228458.jpg"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>state<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> HUNGRY <span class="token operator">&amp;&amp;</span>       state<span class="token punctuation">[</span>LEFT<span class="token punctuation">]</span> <span class="token operator">!=</span> EATING <span class="token operator">&amp;&amp;</span>       state<span class="token punctuation">[</span>RIGHT<span class="token punctuation">]</span> <span class="token operator">!=</span> EATING<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    state<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> EATING<span class="token punctuation">;</span>    <span class="token function">V</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-7-进程间通信-Inter-Process-Communication-IPC"><a href="#2-7-进程间通信-Inter-Process-Communication-IPC" class="headerlink" title="2.7 进程间通信 Inter Process Communication: IPC"></a>2.7 进程间通信 Inter Process Communication: IPC</h3><p>进程通信分为两类：</p><ol><li>低级通信：以信号量作为通信工具，交换的信息量少。</li><li>高级通信：操作系统所提供的一组通信命令，高效地传送大量数据。 <ol><li>共享存储（Shared Memory）</li><li>消息传递&#x2F;消息队列（Message Passing&#x2F;Message Queue）</li><li>管道（Pipe）</li><li>套接字（Socket）</li><li>文件（File）</li><li>信号（Signal）</li><li>内存映射文件（Memory Mapped File）</li></ol></li></ol><h4 id="2-7-1-共享存储（Shared-Memory）"><a href="#2-7-1-共享存储（Shared-Memory）" class="headerlink" title="2.7.1 共享存储（Shared Memory）"></a>2.7.1 共享存储（Shared Memory）</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310152301168.jpg"></p><h4 id="2-7-2-消息传递（Message-Passing）"><a href="#2-7-2-消息传递（Message-Passing）" class="headerlink" title="2.7.2 消息传递（Message Passing）"></a>2.7.2 消息传递（Message Passing）</h4><p>通信模式<br><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310152302945.jpg"></p><h4 id="2-7-3-消息缓冲队列通信机制"><a href="#2-7-3-消息缓冲队列通信机制" class="headerlink" title="2.7.3 消息缓冲队列通信机制"></a>2.7.3 消息缓冲队列通信机制</h4><p>消息缓冲队列通信机制中的数据结构 </p><pre class="line-numbers language-c" data-language="c"><code class="language-c">type message_buffer record     sender；<span class="token comment">//发送者进程标识符</span>     size；<span class="token comment">//消息长度</span>     text；<span class="token comment">//消息正文</span>     next；<span class="token comment">//指针</span> end  type PCB record    mq；<span class="token comment">//消息队列队首指针</span> mutex；<span class="token comment">//消息队列互斥信号量</span>    sm；<span class="token comment">//消息队列资源信号量</span>    ……end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310152304929.jpg"></p><h4 id="2-7-4-管道（Pipe）通信"><a href="#2-7-4-管道（Pipe）通信" class="headerlink" title="2.7.4 管道（Pipe）通信"></a>2.7.4 管道（Pipe）通信</h4><ul><li>用于连接一个读进程和一个写进程以实现他们之间通信的共享文件，又名pipe文件。</li><li>无名管道（unnamed pipe）<ul><li>$ ls | grep x</li></ul></li><li>命名管道（named pipe）<ul><li>$ mkfifo mypipe</li></ul></li></ul><h5 id="2-7-4-1-Shell-中的无名管道"><a href="#2-7-4-1-Shell-中的无名管道" class="headerlink" title="2.7.4.1 Shell 中的无名管道"></a>2.7.4.1 Shell 中的无名管道</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> –l <span class="token operator">|</span> <span class="token function">more</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310152306847.jpg"></p><h3 id="2-8-死锁避免"><a href="#2-8-死锁避免" class="headerlink" title="2.8 死锁避免"></a>2.8 死锁避免</h3><h4 id="2-8-1-银行家算法"><a href="#2-8-1-银行家算法" class="headerlink" title="2.8.1 银行家算法"></a>2.8.1 银行家算法</h4><p><a href="question">img</a></p><h4 id="2-8-2-资源分配算法"><a href="#2-8-2-资源分配算法" class="headerlink" title="2.8.2 资源分配算法"></a>2.8.2 资源分配算法</h4><ul><li>不安全序列</li></ul><h4 id="2-8-3-死锁定理"><a href="#2-8-3-死锁定理" class="headerlink" title="2.8.3 死锁定理"></a>2.8.3 死锁定理</h4><ul><li>资源状态图 （ 简化）</li></ul><h2 id="第三章：存储管理"><a href="#第三章：存储管理" class="headerlink" title="第三章：存储管理"></a>第三章：存储管理</h2><h3 id="操作系统的存储管理需求分析"><a href="#操作系统的存储管理需求分析" class="headerlink" title="操作系统的存储管理需求分析"></a>操作系统的存储管理需求分析</h3><h3 id="存储划分技术：分区技术"><a href="#存储划分技术：分区技术" class="headerlink" title="存储划分技术：分区技术"></a>存储划分技术：分区技术</h3><h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><h3 id="存储划分技术：简单分页技术"><a href="#存储划分技术：简单分页技术" class="headerlink" title="存储划分技术：简单分页技术"></a>存储划分技术：简单分页技术</h3><h3 id="存储划分技术：简单分段技术"><a href="#存储划分技术：简单分段技术" class="headerlink" title="存储划分技术：简单分段技术"></a>存储划分技术：简单分段技术</h3><h3 id="虚拟存储管理的软件策略"><a href="#虚拟存储管理的软件策略" class="headerlink" title="虚拟存储管理的软件策略"></a>虚拟存储管理的软件策略</h3><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h3 id="虚拟存储管理的页面清除与负载控制策略"><a href="#虚拟存储管理的页面清除与负载控制策略" class="headerlink" title="虚拟存储管理的页面清除与负载控制策略"></a>虚拟存储管理的页面清除与负载控制策略</h3><h2 id="第四章：I-x2F-O设备管理"><a href="#第四章：I-x2F-O设备管理" class="headerlink" title="第四章：I&#x2F;O设备管理"></a>第四章：I&#x2F;O设备管理</h2><h3 id="设备管理概述与I-x2F-O控制方式"><a href="#设备管理概述与I-x2F-O控制方式" class="headerlink" title="设备管理概述与I&#x2F;O控制方式"></a>设备管理概述与I&#x2F;O控制方式</h3><h3 id="I-x2F-O缓冲技术"><a href="#I-x2F-O缓冲技术" class="headerlink" title="I&#x2F;O缓冲技术"></a>I&#x2F;O缓冲技术</h3><h3 id="磁盘调度策略"><a href="#磁盘调度策略" class="headerlink" title="磁盘调度策略"></a>磁盘调度策略</h3><h3 id="磁盘容错技术"><a href="#磁盘容错技术" class="headerlink" title="磁盘容错技术"></a>磁盘容错技术</h3><h3 id="磁盘阵列RAID技术"><a href="#磁盘阵列RAID技术" class="headerlink" title="磁盘阵列RAID技术"></a>磁盘阵列RAID技术</h3><h2 id="第五章：文件管理"><a href="#第五章：文件管理" class="headerlink" title="第五章：文件管理"></a>第五章：文件管理</h2><h3 id="文件管理概述"><a href="#文件管理概述" class="headerlink" title="文件管理概述"></a>文件管理概述</h3><h3 id="文件的逻辑结构与访问方式"><a href="#文件的逻辑结构与访问方式" class="headerlink" title="文件的逻辑结构与访问方式"></a>文件的逻辑结构与访问方式</h3><h3 id="文件目录管理、文件共享和记录组块方式"><a href="#文件目录管理、文件共享和记录组块方式" class="headerlink" title="文件目录管理、文件共享和记录组块方式"></a>文件目录管理、文件共享和记录组块方式</h3><h3 id="文件的物理组织和外存空闲空间管理"><a href="#文件的物理组织和外存空闲空间管理" class="headerlink" title="文件的物理组织和外存空闲空间管理"></a>文件的物理组织和外存空闲空间管理</h3>]]></content>
      
      
      <categories>
          
          <category> Course </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大三上 </tag>
            
            <tag> 计算机操作系统 </tag>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Econometrics</title>
      <link href="/article/f6199005.html"/>
      <url>/article/f6199005.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202308301038752.jpg"> <img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202308301039303.jpg"></p><h2 id="成绩构成"><a href="#成绩构成" class="headerlink" title="成绩构成"></a>成绩构成</h2><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202308301040122.jpg"></p><h2 id="Lecture-1-Intro-第一章：计量经济学引论"><a href="#Lecture-1-Intro-第一章：计量经济学引论" class="headerlink" title="Lecture 1 Intro 第一章：计量经济学引论"></a>Lecture 1 Intro 第一章：计量经济学引论</h2><p>Outline</p><ul><li>The Nature and Purpose of Econometrics</li><li>Data</li><li>Returns in Financial Modeling</li><li>Steps involved in the formulation of econometric models45</li></ul><h3 id="1-1-计量经济学的概念与建模"><a href="#1-1-计量经济学的概念与建模" class="headerlink" title="1.1 计量经济学的概念与建模"></a>1.1 计量经济学的概念与建模</h3><p>Econometrics &#x3D; use of statistical methods to analyze economic data</p><h4 id="1-1-1-Steps-of-Econometric-Modeling"><a href="#1-1-1-Steps-of-Econometric-Modeling" class="headerlink" title="1.1.1 Steps of Econometric Modeling"></a>1.1.1 Steps of Econometric Modeling</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202308301047378.jpg"></p><h3 id="1-2-计量经济学在金融中的应用"><a href="#1-2-计量经济学在金融中的应用" class="headerlink" title="1.2 计量经济学在金融中的应用"></a>1.2 计量经济学在金融中的应用</h3><p>Econometrics</p><ul><li>Econometric and financial Econometric</li><li>Microeconometrics and Macroeconometrics</li><li>Theoretical econometrics and applied econometrics</li></ul><h3 id="1-3-数据及其获取"><a href="#1-3-数据及其获取" class="headerlink" title="1.3 数据及其获取"></a>1.3 数据及其获取</h3><p>The Nature of Econometrics and Economic Data</p><p>Typical goals of econometric analysis:</p><ol><li>Testing economic theories and hypotheses，estimating relationships between economic variables</li><li>Evaluating and implementing government and business policy</li><li>Forecasting economic variables</li></ol><p>Different kinds of economic data sets：</p><ul><li>Cross-sectional data</li><li>Time series data</li><li>Pooled cross sections</li><li>Panel&#x2F;Longitudinal data</li></ul><h3 id="1-4-相关软件简介"><a href="#1-4-相关软件简介" class="headerlink" title="1.4 相关软件简介"></a>1.4 相关软件简介</h3><h2 id="Lecture2-A-brief-review-of-classic-linear-regression-第二章：线性回归模型"><a href="#Lecture2-A-brief-review-of-classic-linear-regression-第二章：线性回归模型" class="headerlink" title="Lecture2 A brief review of classic linear regression 第二章：线性回归模型"></a>Lecture2 A brief review of classic linear regression 第二章：线性回归模型</h2><p>Outlines:</p><ul><li>Linear Regression</li><li>Ordinary Least Squares</li><li>The Assumptions Underlying CLRM</li><li>Properties of the OLS Estimator</li><li>Hypothesis Test</li></ul><h3 id="2-0-Find-a-line-of-best-fit"><a href="#2-0-Find-a-line-of-best-fit" class="headerlink" title="2.0 Find a line of best fit"></a>2.0 Find a line of best fit</h3><p>$$y &#x3D; \alpha + \beta x  \ Equation(1)$$</p><p>note: $\alpha$ and $\beta$ are “coefficients” where: $\alpha$ is a “constant” or “intercept” term $\beta$ is a “slope coefficient”.</p><p>$$\beta &#x3D; \frac{\Delta y}{\Delta x} &#x3D; \frac{y_{t+1}-y_{t}}{x_{t+1}-x_t}$$</p><h4 id="2-0-1-Add-a-random-disturbance-term-epsilon"><a href="#2-0-1-Add-a-random-disturbance-term-epsilon" class="headerlink" title="2.0.1 Add a random disturbance term $\epsilon$"></a>2.0.1 Add a random disturbance term $\epsilon$</h4><p>$$y &#x3D; \alpha + \beta x_t + \epsilon_t$$</p><p>where: t &#x3D; 1,…,T</p><p>The disturbance term can capture a number of features:</p><ul><li>Other potentially important explanatory variables may be missing (e.g., Z and W)</li><li>Measurement error</li><li>Incorrect functional form</li><li>Purely random and totally unpredictable occurrences</li></ul><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202308301055553.jpg"></p><h4 id="2-0-2-Single-Equation-Linear-Model"><a href="#2-0-2-Single-Equation-Linear-Model" class="headerlink" title="2.0.2 Single Equation Linear Model"></a>2.0.2 Single Equation Linear Model</h4><p>components:</p><ol><li>determinstic: $\alpha + \beta x$</li><li>stochastic&#x2F;random: $\epsilon_t$ why “determinstic”: conditional expectation which means expectation value of Y Given X</li></ol><h3 id="2-1-多元回归模型的建模与估计-Different-Ways-of-Expressing-the-Multiple-Linear-Regression-Model"><a href="#2-1-多元回归模型的建模与估计-Different-Ways-of-Expressing-the-Multiple-Linear-Regression-Model" class="headerlink" title="2.1 多元回归模型的建模与估计 Different Ways of Expressing the Multiple Linear Regression Model"></a>2.1 多元回归模型的建模与估计 Different Ways of Expressing the Multiple Linear Regression Model</h3><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309111719018.jpg"></p><h4 id="2-1-1-The-OLS-Estimator-for-the-Multiple-Regression-Model"><a href="#2-1-1-The-OLS-Estimator-for-the-Multiple-Regression-Model" class="headerlink" title="2.1.1 The OLS Estimator for the Multiple Regression Model"></a>2.1.1 The OLS Estimator for the Multiple Regression Model</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309111724086.jpg"></p><h4 id="2-1-2-Calculating-the-Standard-Errors-for-the-Multiple-Regression-Model"><a href="#2-1-2-Calculating-the-Standard-Errors-for-the-Multiple-Regression-Model" class="headerlink" title="2.1.2 Calculating the Standard Errors for the Multiple Regression Model"></a>2.1.2 Calculating the Standard Errors for the Multiple Regression Model</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309111727756.jpg"></p><h3 id="2-2-回归模型的拟合优度"><a href="#2-2-回归模型的拟合优度" class="headerlink" title="2.2 回归模型的拟合优度"></a>2.2 回归模型的拟合优度</h3><h3 id="2-3-OLS的经典假设与估计量性质"><a href="#2-3-OLS的经典假设与估计量性质" class="headerlink" title="2.3 OLS的经典假设与估计量性质"></a>2.3 OLS的经典假设与估计量性质</h3><h4 id="2-3-1-Ordinary-Least-Squares"><a href="#2-3-1-Ordinary-Least-Squares" class="headerlink" title="2.3.1 Ordinary Least Squares"></a>2.3.1 Ordinary Least Squares</h4><p>population regression -&gt; sample&#x2F;estimated regression</p><p>The empirical counterpart to Equation(1) is</p><p>$$\hat{Y_t} &#x3D; \hat{\alpha} + \hat{\beta}x_t + \hat{\epsilon_t}$$</p><p>Optimized Function :</p><p>$$Min\ L &#x3D; Min\sum\epsilon_t^2 &#x3D; Min ||Y_t - \hat{Y_t} ||^2 &#x3D; Min ||Y_t - \hat{\alpha} - \hat{\beta}x_t||^2$$</p><pre class="line-numbers language-none"><code class="language-none">求导，微分方程等于零解出 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>$$\beta &#x3D; \frac{\sum x_ty_t-T\overline x \overline y}{\sum x_t^2 - \overline x^2}$$</p><p>$$\alpha &#x3D; \overline Y_t - \beta \overline x_t$$</p><h4 id="2-3-2-CAPM-in-Econometric"><a href="#2-3-2-CAPM-in-Econometric" class="headerlink" title="2.3.2 CAPM in Econometric"></a>2.3.2 CAPM in Econometric</h4><p>$$r_i &#x3D; r_f + \beta(E(r_m)-r_f)+\epsilon_t$$</p><p>$$r_t - rf_t &#x3D; \hat \alpha + \hat \beta(E(r_m - rf_t))$$</p><p>where $\hat \beta &#x3D; \frac{cov(r_m,rf_t)}{var(r_t)}$</p><h4 id="2-3-3-The-relationship-between-Regression-and-Corelationship"><a href="#2-3-3-The-relationship-between-Regression-and-Corelationship" class="headerlink" title="2.3.3 The relationship between Regression and Corelationship"></a>2.3.3 The relationship between Regression and Corelationship</h4><p>$$\hat b &#x3D; \frac{cov(x,y)}{cov(x,x)} &#x3D; \frac{cov(x,y)}{\sqrt{cov(x,x)} \sqrt{cov(y,y)}} \times \frac{\sqrt{cov(y,y)}}{\sqrt{cov(x,x)}} &#x3D; r_{x,y} \frac{S_y}{S_x}$$</p><ul><li>PRF: Population Regression Function</li></ul><p>$$Y_t &#x3D; \hat \alpha + \hat \beta x_t + \hat \mu$$</p><ul><li>SRF: Sample Regression Function</li></ul><p>$$Y_t &#x3D; \hat \alpha + \hat \beta x_t $$</p><blockquote><p>sample is a selection set of population, we can use SRF to infer likely as PRF.</p></blockquote><h4 id="2-3-4-Estimators-amp-Estimates"><a href="#2-3-4-Estimators-amp-Estimates" class="headerlink" title="2.3.4 Estimators &amp; Estimates"></a>2.3.4 Estimators &amp; Estimates</h4><ul><li>Estimators（估计量）: random&#x2F;stochastic</li><li>Estimates（估计值）: actual numerical value</li></ul><h4 id="2-3-5-The-Assumptions-underlying-in-CLRM-Classic-Linear-Regression-Model"><a href="#2-3-5-The-Assumptions-underlying-in-CLRM-Classic-Linear-Regression-Model" class="headerlink" title="2.3.5 The Assumptions underlying in CLRM(Classic Linear Regression Model)"></a>2.3.5 The Assumptions underlying in CLRM(Classic Linear Regression Model)</h4><p>The seven classical assumptions are:</p><ol><li>The regression model is linear, is correctly specified, and has an additive error term</li><li>The error term has a zero population mean</li><li>All explanatory variables are uncorrelated with the error term</li><li>Observations of the error term are uncorrelated with each other (no serial correlation)</li><li>The error term has a constant variance (no heteroskedasticity)</li><li>No explanatory variable is a perfect linear function of any other explanatory variable(s) (no perfect multicollinearity)</li><li>The error term is normally distributed(this assumption is optional but usually is invoked)</li></ol><p>(2) $E(\epsilon_t) &#x3D; 0$</p><p>(3) $E(\epsilon_t|x_t) &#x3D; 0 or cov(\epsilon_t|x_t) &#x3D; 0$</p><p>(4) $cov(\epsilon_t|\epsilon_{t+k}) &#x3D; 0 \ k \geq 1$</p><p>(5) $var(\epsilon_t) &#x3D; \sigma^2$ special case: $var(\epsilon_t) &#x3D; \sigma_t^2$</p><p>(6) $x_i \neq r_1x_{k1} + r_2x_{k2} + r_3x_{k3}+ …$</p><p>(7) $\epsilon_t \ ~ N(0,\sigma^2)$</p><h4 id="2-3-6-Properties-of-OLS-Estimator"><a href="#2-3-6-Properties-of-OLS-Estimator" class="headerlink" title="2.3.6 Properties of OLS Estimator"></a>2.3.6 Properties of OLS Estimator</h4><p>If assumption 1 through 6 holds, $\hat \alpha$ and $\hat \beta$ are determined by OLS well known as BLUE</p><blockquote><p>BLUE: Best Linear Unbiased Estimator</p></blockquote><ol><li>estimator: $\hat \beta$ is an estimator of the value of $\beta$</li><li>linear: $\hat \beta$ is a linear variable</li><li>unbiased: in average, $\hat \alpha$ and $\hat \beta$ are true value of $\alpha$ , $\beta$.</li><li>best: means that the OLS estimator has minimum variance among the class of linear unbiased estimators</li></ol><blockquote><p>The Gauss-Markov theorem proves that the OLS estimator is best.</p></blockquote><p>$$ri_t - rf_t &#x3D; \alpha + \beta(rm_t - rf_t) + \epsilon_t$$</p><p>where $\alpha$ is market pricing and $\epsilon_t \ ~ iid (0,\sigma^2)$</p><p>$$Y_t &#x3D; \hat \alpha + \hat \beta X_t + \epsilon_t$$</p><p>$\epsilon_t \ ~ iid(0,\sigma^2)$ and $E(\overline X) &#x3D; 0$</p><p>We have $\hat \alpha$ is the mean value of $\epsilon_t$.</p><h4 id="2-3-7-Addition"><a href="#2-3-7-Addition" class="headerlink" title="2.3.7 Addition"></a>2.3.7 Addition</h4><p>$$\hat \beta &#x3D; (X’X)^{-1}X’Y &#x3D; (X’X)^{-1}X’(X\beta + \epsilon)$$</p><p>$$E(\hat \beta) &#x3D; \beta + E((X’X)^{-1}X’\epsilon) $$</p><p>where $E(\epsilon) &#x3D; 0$</p><p>Then we get $E(\hat \beta) &#x3D; \beta$</p><p>$$\hat \beta &#x3D; \beta + E((X’X)^{-1}X’\epsilon)$$</p><p>We know</p><p>$$Var(\hat \beta) &#x3D; Var(\beta + (X’X)^{-1}X’\epsilon) &#x3D; 0 + Var((X’X)^{-1}X’E(\epsilon \epsilon’)X(X’X)^{-1})$$</p><h2 id="epsilon-x3D-begin-bmatrix-epsilon-1-epsilon-2-…-epsilon-n-end-bmatrix"><a href="#epsilon-x3D-begin-bmatrix-epsilon-1-epsilon-2-…-epsilon-n-end-bmatrix" class="headerlink" title="$$\epsilon &#x3D;\begin{bmatrix}\epsilon_1  \\epsilon_2 \… \\epsilon_n \\end{bmatrix}"></a>$$<br>\epsilon &#x3D;<br>\begin{bmatrix}<br>\epsilon_1  \<br>\epsilon_2 \<br>… \<br>\epsilon_n \<br>\end{bmatrix}</h2><p>\begin{bmatrix}<br>0 \<br>0 \<br>… \<br>0 \<br>\end{bmatrix}<br>$$</p><h1 id="Var-epsilon-x3D-E-epsilon-epsilon’-x3D-E-begin-bmatrix-epsilon-1-2-amp-epsilon-1-epsilon-2-amp-…-amp-epsilon-1-epsilon-n-…-amp-epsilon-2-2-amp-…-amp-…-epsilon-n-epsilon-1-amp-…-amp-…-amp-epsilon-n-2-end-bmatrix"><a href="#Var-epsilon-x3D-E-epsilon-epsilon’-x3D-E-begin-bmatrix-epsilon-1-2-amp-epsilon-1-epsilon-2-amp-…-amp-epsilon-1-epsilon-n-…-amp-epsilon-2-2-amp-…-amp-…-epsilon-n-epsilon-1-amp-…-amp-…-amp-epsilon-n-2-end-bmatrix" class="headerlink" title="$$Var(\epsilon) &#x3D; E(\epsilon \epsilon’) &#x3D; E(\begin{bmatrix}\epsilon_1^2 &amp; \epsilon_1 \epsilon_2 &amp; … &amp; \epsilon_1 \epsilon_n  \… &amp; \epsilon_2^2 &amp; … &amp; … \\epsilon_n \epsilon_1 &amp; … &amp; … &amp; \epsilon_n^2\\end{bmatrix})"></a>$$<br>Var(\epsilon) &#x3D; E(\epsilon \epsilon’) &#x3D; E(\begin{bmatrix}<br>\epsilon_1^2 &amp; \epsilon_1 \epsilon_2 &amp; … &amp; \epsilon_1 \epsilon_n  \<br>… &amp; \epsilon_2^2 &amp; … &amp; … \<br>\epsilon_n \epsilon_1 &amp; … &amp; … &amp; \epsilon_n^2\<br>\end{bmatrix})</h1><h1 id="begin-bmatrix-sigma-2-amp-0-amp-…-amp-0-…-amp-…-amp-…-amp-…-0-amp-…-amp-…-amp-sigma-2-end-bmatrix"><a href="#begin-bmatrix-sigma-2-amp-0-amp-…-amp-0-…-amp-…-amp-…-amp-…-0-amp-…-amp-…-amp-sigma-2-end-bmatrix" class="headerlink" title="\begin{bmatrix}\sigma^2 &amp; 0 &amp; … &amp; 0  \… &amp; …&amp; … &amp; … \0 &amp; … &amp; … &amp; \sigma^2 \\end{bmatrix}"></a>\begin{bmatrix}<br>\sigma^2 &amp; 0 &amp; … &amp; 0  \<br>… &amp; …&amp; … &amp; … \<br>0 &amp; … &amp; … &amp; \sigma^2 \<br>\end{bmatrix}</h1><p>\sigma^2 I<br>&#x3D; \sigma^2(X’X)^{-1}<br>$$</p><p>We get $Var(\hat \beta) &#x3D; \sigma^2 \epsilon(X’X)^{-1}$</p><p>Cz</p><p>$$y &#x3D; \beta x + \epsilon$$</p><p>owing to $\epsilon\ iid(0,\sigma^2)$</p><p>and</p><p>$$y &#x3D; \hat \beta x + \hat \epsilon$$</p><p>owing to $\hat \sigma^2$</p><h4 id="2-3-8-Precision-and-Standard-Errors"><a href="#2-3-8-Precision-and-Standard-Errors" class="headerlink" title="2.3.8 Precision and Standard Errors"></a>2.3.8 Precision and Standard Errors</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309111735728.jpg"></p><h3 id="2-4-假设检验-Hypothesis-Testing"><a href="#2-4-假设检验-Hypothesis-Testing" class="headerlink" title="2.4 假设检验 Hypothesis Testing"></a>2.4 假设检验 Hypothesis Testing</h3><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309121944650.jpg"></p><h4 id="2-4-1-One-Sided-Hypothesis-Tests"><a href="#2-4-1-One-Sided-Hypothesis-Tests" class="headerlink" title="2.4.1 One-Sided Hypothesis Tests"></a>2.4.1 One-Sided Hypothesis Tests</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309121946221.jpg"></p><h4 id="2-4-2-The-Probability-Distribution-of-the-Least-Squares-Estimators"><a href="#2-4-2-The-Probability-Distribution-of-the-Least-Squares-Estimators" class="headerlink" title="2.4.2 The Probability Distribution of the Least Squares Estimators"></a>2.4.2 The Probability Distribution of the Least Squares Estimators</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309121948559.jpg"></p><h4 id="2-4-3-Testing-Hypotheses-The-Test-of-Significance-Approach"><a href="#2-4-3-Testing-Hypotheses-The-Test-of-Significance-Approach" class="headerlink" title="2.4.3 Testing Hypotheses: The Test of Significance Approach"></a>2.4.3 Testing Hypotheses: The Test of Significance Approach</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309121951487.jpg"></p><h4 id="2-4-4-The-Confidence-Interval-Approach-to-Hypothesis-Testing"><a href="#2-4-4-The-Confidence-Interval-Approach-to-Hypothesis-Testing" class="headerlink" title="2.4.4 The Confidence Interval Approach to Hypothesis Testing"></a>2.4.4 The Confidence Interval Approach to Hypothesis Testing</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309122002415.jpg"></p><h4 id="2-4-5-Test-Hypothesis"><a href="#2-4-5-Test-Hypothesis" class="headerlink" title="2.4.5 Test Hypothesis"></a>2.4.5 Test Hypothesis</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309122004226.jpg"></p><h4 id="2-4-6-The-Errors-That-We-Can-Make-Using-Hypothesis-Tests"><a href="#2-4-6-The-Errors-That-We-Can-Make-Using-Hypothesis-Tests" class="headerlink" title="2.4.6 The Errors That We Can Make Using Hypothesis Tests"></a>2.4.6 The Errors That We Can Make Using Hypothesis Tests</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309122005883.jpg"></p><h3 id="2-5-实践性教学环节"><a href="#2-5-实践性教学环节" class="headerlink" title="2.5 实践性教学环节"></a>2.5 实践性教学环节</h3><h2 id="Lecture-3-Further-development-and-analysis-of-the-classical-linear-regression-model-第三章：模型诊断检验"><a href="#Lecture-3-Further-development-and-analysis-of-the-classical-linear-regression-model-第三章：模型诊断检验" class="headerlink" title="Lecture 3: Further development and analysis of the classical linear regression model 第三章：模型诊断检验"></a>Lecture 3: Further development and analysis of the classical linear regression model 第三章：模型诊断检验</h2><p>Classical linear regression model assumption and diagnositics</p><ol><li>The regression model is linear, is correctly specified, and has an additive error term</li><li>The error term has a zero population mean</li><li>All explanatory variables are uncorrelated with the error term</li><li>Observations of the error term are uncorrelated with each other (no serial correlation)</li><li>The error term has a constant variance (no heteroskedasticity)</li><li>No explanatory variable is a perfect linear function of any other explanatory variable(s) (no perfect multicollinearity)</li><li>The error term is normally distributed(this assumption is optional but usually is invoked)</li></ol><h3 id="3-1-违背经典假设的情形"><a href="#3-1-违背经典假设的情形" class="headerlink" title="3.1 违背经典假设的情形"></a>3.1 违背经典假设的情形</h3><p>$$Y &#x3D; X\beta + \epsilon_t$$<br>$$\hat{\beta} &#x3D; (X’X)^{-1}X’Y &#x3D; \beta + (X’X)^{-1}X’\epsilon_t$$</p><p>$$Z &#x3D; Var(\hat{\beta}) &#x3D; E[(X’X)^{-1}X’\epsilon X(X’X)^{-1}] $$<br>$$&#x3D;(X’X)^{-1}X’E(\epsilon \epsilon’)X(X’X)^{-1} $$<br>$$&#x3D;(X’X)^{-1}X’\Omega X(X’X)^{-1}$$</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310182037860.jpg" alt="case1"><br><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310182037190.jpg" alt="case2"><br><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310182038750.jpg" alt="case3"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310182051700.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310182051690.jpg"></p><h3 id="3-2-多重共线性-Multicollinearity"><a href="#3-2-多重共线性-Multicollinearity" class="headerlink" title="3.2 多重共线性 Multicollinearity"></a>3.2 多重共线性 Multicollinearity</h3><h4 id="3-2-1-Types-of-multicollinearity"><a href="#3-2-1-Types-of-multicollinearity" class="headerlink" title="3.2.1 Types of multicollinearity"></a>3.2.1 Types of multicollinearity</h4><ul><li>Perfect multicollinearity<br>$$x_3 &#x3D; 2x_2$$</li><li>Imperfect multicollinearity<br>$$x_{1i} &#x3D; x_{2i} + w$$</li></ul><h4 id="3-2-2-5-Consequences-of-Multicollinearity"><a href="#3-2-2-5-Consequences-of-Multicollinearity" class="headerlink" title="3.2.2 5 Consequences of Multicollinearity"></a>3.2.2 5 Consequences of Multicollinearity</h4><ol><li>Estimates will <strong>remain unbiased</strong></li><li>Variances and Standard errors will <strong>increase</strong></li><li><strong>t-scores</strong> will fall</li><li>Estimates will be very <strong>sensitive</strong> to changes in specification</li><li>Overfit</li></ol><h4 id="3-2-3-Detection"><a href="#3-2-3-Detection" class="headerlink" title="3.2.3 Detection"></a>3.2.3 Detection</h4><ol><li><p>High Simple Correlation coefficients<br><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310182048701.jpg"></p></li><li><p>High Variance Inflation Factors(VIFs)</p></li></ol><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310182048459.jpg"></p><h4 id="3-2-4-Solutions-to-the-Problems-of-Multicollinearity"><a href="#3-2-4-Solutions-to-the-Problems-of-Multicollinearity" class="headerlink" title="3.2.4 Solutions to the Problems of Multicollinearity"></a>3.2.4 Solutions to the Problems of Multicollinearity</h4><ol><li>Ridge Regression&#x2F; PCA</li><li>Collect more data</li><li>Data Transform</li><li>drop one of the collinear variables</li></ol><h3 id="3-3-序列相关性-Serial-Correlationor-or-Autocorrelation"><a href="#3-3-序列相关性-Serial-Correlationor-or-Autocorrelation" class="headerlink" title="3.3 序列相关性 Serial Correlationor or Autocorrelation"></a>3.3 序列相关性 Serial Correlationor or Autocorrelation</h3><blockquote><p>We assumed of the CLRM’s errors that $Cov(u_i,u_j)&#x3D;0$ for $i\neq j$ ,i.e.This is essentially the same as saying there is no pattern in the errors.</p><p> Obviously we never have the actual u’s,so we use their sample counterpart, the residuals (the$\hat u$). If there are patterns in the residuals from a model, we say that they are autocorrelated.</p></blockquote><h4 id="3-3-1-Serial-Correlated"><a href="#3-3-1-Serial-Correlated" class="headerlink" title="3.3.1 Serial Correlated"></a>3.3.1 Serial Correlated</h4><ol><li>Pure serial correlation</li></ol><p>$$\epsilon_t &#x3D; \rho \epsilon_{t-1} + \mu$$<br>where $\rho$ is the first order autocorrelation coefficient</p><p>and we can state that<br>$$ -1 &lt; \rho &lt; 1$$<br>2. Impure serial correlation</p><p>caused by specification error such as:</p><ul><li>an omitted variable </li><li>an incorrect functional form</li></ul><h4 id="3-3-2-Detection-Autocorrelation"><a href="#3-3-2-Detection-Autocorrelation" class="headerlink" title="3.3.2 Detection Autocorrelation"></a>3.3.2 Detection Autocorrelation</h4><h5 id="3-3-2-1-The-Durbin-Watson-Test"><a href="#3-3-2-1-The-Durbin-Watson-Test" class="headerlink" title="3.3.2.1 The Durbin-Watson Test"></a>3.3.2.1 The Durbin-Watson Test</h5><blockquote><p>The Durbin-Watson(DW) is a test for first order autocorrelation-i.e.it assumes that the relationship is between an error and the previous one</p></blockquote><p>$$u_t &#x3D; \rho u_{t-1} + v_t$$<br>where $v_t\ N(0,\sigma_v^2)$</p><p>The DW test statistic actually tests<br>$$H_0: \rho &#x3D; 0 \ and\ H_1: \rho \neq 0$$</p><p>The test statistic is calculated by<br>$$DW &#x3D; \frac{\sum_{t&#x3D;2}^{T}(\hat{u_t} - \hat{u_{t-1}})^2}{\sum_{t&#x3D;2}^T\hat{u_t}^2}$$</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310181950339.jpg"></p><p>we can also write<br>$$DW \approx 2(1-\rho)$$</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310181955883.jpg"></p><h5 id="3-3-2-2-The-Breusch-Godfrey-Test"><a href="#3-3-2-2-The-Breusch-Godfrey-Test" class="headerlink" title="3.3.2.2 The Breusch-Godfrey Test"></a>3.3.2.2 The Breusch-Godfrey Test</h5><p>It’s a more general test for $r^{th}$ order autocorrelation<br>$$u_t &#x3D; \rho_1u_{t-1} + \rho_2u_{t-2} + … + \rho_ru_{t-r} + v_t$$<br>where $v_t \ N(0,\sigma_v^2)$</p><p>The Null and alternative hypotheses are:</p><ul><li>$H_0: \rho_1 &#x3D; 0 \ and\ \rho_2 &#x3D; 0 \ and … and\ \rho_r &#x3D; 0$</li><li>$H_1: \rho_1 \neq 0 \ or \ \rho_2 \neq 0\ or … or\ \rho_r \neq 0$</li></ul><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310182004620.jpg"></p><h5 id="3-3-2-3-LM-Test"><a href="#3-3-2-3-LM-Test" class="headerlink" title="3.3.2.3 LM-Test"></a>3.3.2.3 LM-Test</h5><h4 id="3-3-3-Remedies-for-Autocorrelation"><a href="#3-3-3-Remedies-for-Autocorrelation" class="headerlink" title="3.3.3 Remedies for Autocorrelation"></a>3.3.3 Remedies for Autocorrelation</h4><h5 id="3-3-3-1-Quasi-differenced"><a href="#3-3-3-1-Quasi-differenced" class="headerlink" title="3.3.3.1 Quasi-differenced"></a>3.3.3.1 Quasi-differenced</h5><p> <img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310182030815.jpg"></p><h5 id="3-3-3-2-GLS"><a href="#3-3-3-2-GLS" class="headerlink" title="3.3.3.2 GLS"></a>3.3.3.2 GLS</h5><p> $$y_t &#x3D; \beta x_t + \epsilon_t \ (1)$$<br> $$\epsilon_t &#x3D; \rho \epsilon_{t-1} + v_t \ (2)$$<br> Build<br> $$\rho y_{t-1} &#x3D; \rho \beta x_{t-1} + v_t\ (3)$$</p><p> $(1) - (3)$ we obtain<br> $$y_t - \rho y_{t-1} &#x3D; \beta(x_t - \rho x_{t-1}) + v_t\ (4)$$</p><p> $\beta$s in (1) and (4)  are not same one.</p><h5 id="3-3-3-3-Add-lag-dependent-variable"><a href="#3-3-3-3-Add-lag-dependent-variable" class="headerlink" title="3.3.3.3 Add lag dependent variable"></a>3.3.3.3 Add lag dependent variable</h5><h5 id="3-3-3-4-Newey-West-Heteroscedasticity-Autocorrelation-Consistent-Covariance-Estimator"><a href="#3-3-3-4-Newey-West-Heteroscedasticity-Autocorrelation-Consistent-Covariance-Estimator" class="headerlink" title="3.3.3.4 Newey-West Heteroscedasticity Autocorrelation Consistent Covariance Estimator"></a>3.3.3.4 Newey-West Heteroscedasticity Autocorrelation Consistent Covariance Estimator</h5><p> <img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310182035374.jpg"></p><h4 id="3-3-4"><a href="#3-3-4" class="headerlink" title="3.3.4"></a>3.3.4</h4><h5 id="3-3-4-1-Dynamic-Models"><a href="#3-3-4-1-Dynamic-Models" class="headerlink" title="3.3.4.1 Dynamic Models"></a>3.3.4.1 Dynamic Models</h5><p>Static models:<br>$$y_t &#x3D; \beta_1 + \beta_2x_{2t} + … + \beta_kx_{kt} + u_t$$</p><p>Dynamic models:<br>$$y_t &#x3D; \beta_1 + \beta_2x_{2t} + … + \beta_kx_{kt} + \gamma_1y_{t-1} +…+\gamma_kx_{kt-1} + u_t$$</p><p>which includes $(y_t - \rho y_{t-1})$ or $(y_t - \gamma_1 y_{t-1})$</p><h5 id="3-3-4-2-Models-in-First-Difference-Form"><a href="#3-3-4-2-Models-in-First-Difference-Form" class="headerlink" title="3.3.4.2 Models in First Difference Form"></a>3.3.4.2 Models in First Difference Form</h5><p>Denote the first difference of $\Delta y_t &#x3D; y_t - y_{t-1}$<br>and $\Delta x_{2t} &#x3D; x_{2t} - x_{2t-1}$</p><p>The model would now be:<br>$$\Delta y_t &#x3D; \beta_1 + \beta_2 \Delta x_{2t} + … + \beta_k \Delta x_{kt} + u_t$$</p><p>Sometimes the change in y purported to depend on previous values of y or xt as well as changes in x:<br>$$\Delta y_t &#x3D; \beta_1 + \beta_2 \Delta x_{2t-1} + … + \beta_k \Delta y_{t-1} + u_t$$</p><h3 id="3-4-异方差性-Heteroscedastisity"><a href="#3-4-异方差性-Heteroscedastisity" class="headerlink" title="3.4 异方差性 Heteroscedastisity"></a>3.4 异方差性 Heteroscedastisity</h3><h4 id="3-4-0-Difference-between-Heteroskedasiticity-and-Homoskedasiticity"><a href="#3-4-0-Difference-between-Heteroskedasiticity-and-Homoskedasiticity" class="headerlink" title="3.4.0 Difference between Heteroskedasiticity and Homoskedasiticity"></a>3.4.0 Difference between Heteroskedasiticity and Homoskedasiticity</h4><ol><li>Homoskedasiticity<br>$$\Omega &#x3D; E(\epsilon \epsilon’) &#x3D; \begin{bmatrix}<br>\epsilon_1  \<br>\epsilon_2 \<br>… \<br>\epsilon_n \<br>\end{bmatrix}</li></ol><p>[\epsilon_1, … , \epsilon_n] $$</p><p>$$&#x3D;\begin{bmatrix}<br>\sigma_1^2, … , 0 \<br>… \<br>0,…, \sigma_n^2 \<br>\end{bmatrix}<br>$$</p><p>$$&#x3D;\sigma^2\begin{bmatrix}<br>1, … , 0 \<br>… \<br>0,…, 1 \<br>\end{bmatrix}<br>$$</p><p>$$&#x3D;\sigma^2I$$</p><p>And<br>$$Var(\hat{\beta}) &#x3D; (X’X)^{-1}X’\sigma^2IX(X’X)^{-1} &#x3D; \sigma^2(X’X)^{-1}$$</p><ol start="2"><li>Heteroskedasiticity<br>$Cov(X_i,X_j) &#x3D; 0$<br>and<br>$Var(\epsilon_t) &#x3D; \sigma_t^2 &lt; \infty$</li></ol><p>$$\Omega &#x3D; E(\epsilon \epsilon’) &#x3D; \begin{bmatrix}<br>\sigma_1^2, … , 0 \<br>… \<br>0,…, \sigma_i^2 \<br>\end{bmatrix}<br>$$</p><h4 id="3-4-1-Pure-and-Impure-heteroscedastisity"><a href="#3-4-1-Pure-and-Impure-heteroscedastisity" class="headerlink" title="3.4.1 Pure and Impure heteroscedastisity"></a>3.4.1 Pure and Impure heteroscedastisity</h4><p>Impure caused by omitting explainary variable.</p><h4 id="3-4-2-Assumption-1-4-amp-5"><a href="#3-4-2-Assumption-1-4-amp-5" class="headerlink" title="3.4.2 Assumption 1-4 &amp; 5"></a>3.4.2 Assumption 1-4 &amp; 5</h4><p>If model observes 1-4 then we can say the model is BLUE If model observes 5 we can use test-statistic</p><h4 id="3-4-3-Detectation-of-heteroscedastisity"><a href="#3-4-3-Detectation-of-heteroscedastisity" class="headerlink" title="3.4.3 Detectation of heteroscedastisity"></a>3.4.3 Detectation of heteroscedastisity</h4><ol><li>Graphic Test</li><li>GQ-Test</li></ol><p>split samples into 2 parts and compare the varirance of these two parts. The null hypothesis is that the variances of the disturbances are equal,</p><p>$$H_0 : \sigma_1^2 &#x3D; \sigma_2^2$$</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309251646310.jpg"></p><ol start="3"><li>Park-Test</li></ol><p>$$e_i &#x3D; Y_i - \hat{Y_i} &#x3D; Y_i - (\hat{\beta_0} + \hat{\beta_1}X_{1i} +\hat{\beta_2}X_{2i})$$</p><p>$$ln(e_1^2) &#x3D; \alpha_0 + \alpha_a lnZ_1 + u_i$$</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309251647591.jpg"></p><ol start="4"><li>White-Test</li></ol><p>$$e_i^2 &#x3D; \alpha + \beta(X_1 + X_2 + X_3 + X_1X_2 + …) + u$$</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309251649078.jpg"></p><blockquote><p>The 3 and 4 mean that there’s omitted variable in error iterm.</p></blockquote><p><strong>LIKE</strong></p><p>$$Y &#x3D; \alpha + \beta X + u$$</p><p>and $u$ is composed of $x_i$ and $z_i$ which $z_i$ we don’t add it to explainary variable.</p><h4 id="3-4-4-Remedies-for-heteroskedastisity"><a href="#3-4-4-Remedies-for-heteroskedastisity" class="headerlink" title="3.4.4 Remedies for heteroskedastisity"></a>3.4.4 Remedies for heteroskedastisity</h4><p>There are two main remedies for pure heteroskedasticit:</p><p>1.Heteroskedasticity-corrected standard errors</p><p>2.Redefining the variables</p><p>$$\frac{y}{z_i} &#x3D; \frac{\alpha}{z_i} + \beta_1 \frac{x_1}{z_i} + …$$</p><ol><li>use $logs$ 缩放量纲</li><li>理论上 White</li></ol><p>$$Var(\hat{\beta}) &#x3D; \sigma^2(X’X)^{-1}$$</p><p>实际上由于异方差性，我们“数据驱动”的用实际数据计算：</p><p>Calculate $Var(\epsilon*) &#x3D; Var(\beta - \hat{\beta})$ directly.</p><p>$$Var(\hat{\beta}) &#x3D; E[(X’X)^{-1}X’(\epsilon \epsilon’)X(X’X)^{-1}]$$</p><p>$$&#x3D; (X’X)^{-1}X’E(\epsilon \epsilon’)X(X’X)^{-1}$$</p><p>$$&#x3D; (X’X)^{-1}(\sum\hat{\epsilon_i}^2X_iX_i’)(X’X)^{-1}$$</p><p>$$\to^{\beta}$$</p><p>依概率收敛于$(\sum\epsilon_iX_iX_i’)$</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309251639698.jpg"></p><ol><li><p>Refomulating the Equation<br>$$\frac{Y_i}{Pop} &#x3D; \alpha_0 + \beta_1\frac{Reg_i}{Pop} + \beta_2 Price_i + \epsilon_i$$</p></li><li><p>Weighted Least Square<br>$$\frac{Y_i}{Abs(\epsilon_i)} &#x3D; \alpha_0 + \beta_1Reg_i+ \beta_2 Price_i + \frac{\epsilon_i}{Abs(\epsilon_i)}$$</p></li><li><p>A double-log functional form<br>$$Y &#x3D; \alpha_0 + \beta_1lnReg_i + \beta_2 ln Price_i + \epsilon_i $$</p></li><li><p>White Method above</p></li></ol><h3 id="3-5-模型设定问题"><a href="#3-5-模型设定问题" class="headerlink" title="3.5 模型设定问题"></a>3.5 模型设定问题</h3><h3 id="3-6-参数稳定性检验"><a href="#3-6-参数稳定性检验" class="headerlink" title="3.6 参数稳定性检验"></a>3.6 参数稳定性检验</h3><h3 id="3-7-测量误差"><a href="#3-7-测量误差" class="headerlink" title="3.7 测量误差"></a>3.7 测量误差</h3><h3 id="3-8-计量经济学建模策略"><a href="#3-8-计量经济学建模策略" class="headerlink" title="3.8 计量经济学建模策略"></a>3.8 计量经济学建模策略</h3><h3 id="3-9-实践性教学环节"><a href="#3-9-实践性教学环节" class="headerlink" title="3.9 实践性教学环节"></a>3.9 实践性教学环节</h3><h2 id="第四章：含虚拟变量的回归模型"><a href="#第四章：含虚拟变量的回归模型" class="headerlink" title="第四章：含虚拟变量的回归模型"></a>第四章：含虚拟变量的回归模型</h2><h3 id="虚拟变量模型的设计"><a href="#虚拟变量模型的设计" class="headerlink" title="虚拟变量模型的设计"></a>虚拟变量模型的设计</h3><h3 id="虚拟变量的应用"><a href="#虚拟变量的应用" class="headerlink" title="虚拟变量的应用"></a>虚拟变量的应用</h3><h3 id="二元选择模型"><a href="#二元选择模型" class="headerlink" title="二元选择模型"></a>二元选择模型</h3><h3 id="多元选择模型"><a href="#多元选择模型" class="headerlink" title="多元选择模型"></a>多元选择模型</h3><h3 id="实践性教学环节"><a href="#实践性教学环节" class="headerlink" title="实践性教学环节"></a>实践性教学环节</h3><h2 id="Lecture-5-Autorelation-第五章：时间序列模型"><a href="#Lecture-5-Autorelation-第五章：时间序列模型" class="headerlink" title="Lecture 5 Autorelation 第五章：时间序列模型"></a>Lecture 5 Autorelation 第五章：时间序列模型</h2><h3 id="ARMA模型"><a href="#ARMA模型" class="headerlink" title="ARMA模型"></a>ARMA模型</h3><h3 id="平稳性与单位根检验"><a href="#平稳性与单位根检验" class="headerlink" title="平稳性与单位根检验"></a>平稳性与单位根检验</h3><h3 id="ARIMA模型"><a href="#ARIMA模型" class="headerlink" title="ARIMA模型"></a>ARIMA模型</h3><h3 id="时间序列模型预测"><a href="#时间序列模型预测" class="headerlink" title="时间序列模型预测"></a>时间序列模型预测</h3><h3 id="协整及其检验"><a href="#协整及其检验" class="headerlink" title="协整及其检验"></a>协整及其检验</h3><h3 id="误差修正模型"><a href="#误差修正模型" class="headerlink" title="误差修正模型"></a>误差修正模型</h3><h3 id="实践性教学环节-1"><a href="#实践性教学环节-1" class="headerlink" title="实践性教学环节"></a>实践性教学环节</h3><h2 id="第六章：多方程模型"><a href="#第六章：多方程模型" class="headerlink" title="第六章：多方程模型"></a>第六章：多方程模型</h2><h3 id="联立方程模型"><a href="#联立方程模型" class="headerlink" title="联立方程模型"></a>联立方程模型</h3><h3 id="向量自回归模型"><a href="#向量自回归模型" class="headerlink" title="向量自回归模型"></a>向量自回归模型</h3><h3 id="脉冲响应和方差分解"><a href="#脉冲响应和方差分解" class="headerlink" title="脉冲响应和方差分解"></a>脉冲响应和方差分解</h3><h3 id="实践性教学环节-2"><a href="#实践性教学环节-2" class="headerlink" title="实践性教学环节"></a>实践性教学环节</h3><h2 id="第七章：波动性与相关性建模"><a href="#第七章：波动性与相关性建模" class="headerlink" title="第七章：波动性与相关性建模"></a>第七章：波动性与相关性建模</h2><h3 id="波动率建模"><a href="#波动率建模" class="headerlink" title="波动率建模"></a>波动率建模</h3><h3 id="ARCH模型与GARCH模型"><a href="#ARCH模型与GARCH模型" class="headerlink" title="ARCH模型与GARCH模型"></a>ARCH模型与GARCH模型</h3><h3 id="GARCH模型的扩展"><a href="#GARCH模型的扩展" class="headerlink" title="GARCH模型的扩展"></a>GARCH模型的扩展</h3><h3 id="多元GARCH模型"><a href="#多元GARCH模型" class="headerlink" title="多元GARCH模型"></a>多元GARCH模型</h3><h3 id="实践性教学环节-3"><a href="#实践性教学环节-3" class="headerlink" title="实践性教学环节"></a>实践性教学环节</h3>]]></content>
      
      
      <categories>
          
          <category> Course </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大三上 </tag>
            
            <tag> 计量经济学 </tag>
            
            <tag> Econometrics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金融市场与机构</title>
      <link href="/article/53aac4c6.html"/>
      <url>/article/53aac4c6.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202308311649113.jpg"></p><h2 id="1-第一章：导论"><a href="#1-第一章：导论" class="headerlink" title="1 第一章：导论"></a>1 第一章：导论</h2><h3 id="1-1-金融内涵的演进与发展"><a href="#1-1-金融内涵的演进与发展" class="headerlink" title="1.1 金融内涵的演进与发展"></a>1.1 金融内涵的演进与发展</h3><h3 id="1-2-金融体系概览"><a href="#1-2-金融体系概览" class="headerlink" title="1.2 金融体系概览"></a>1.2 金融体系概览</h3><h4 id="1-2-1-金融体系的组成"><a href="#1-2-1-金融体系的组成" class="headerlink" title="1.2.1 金融体系的组成"></a>1.2.1 金融体系的组成</h4><ul><li>金融市场</li><li>金融机构</li><li>监管部门</li></ul><h4 id="1-2-2-金融市场的参与者"><a href="#1-2-2-金融市场的参与者" class="headerlink" title="1.2.2 金融市场的参与者"></a>1.2.2 金融市场的参与者</h4><ul><li>居民&#x2F;个人： 资金的供应者</li><li>政府： 资金的需求者</li><li>企业： 资金的需求者</li><li>金融机构： 既是也是，中介</li><li>金融监管机构</li></ul><h4 id="1-2-3-金融资产"><a href="#1-2-3-金融资产" class="headerlink" title="1.2.3 金融资产"></a>1.2.3 金融资产</h4><p>分为金融资产和实物资产</p><ul><li>收益</li><li>风险</li><li>流动性</li></ul><h4 id="1-2-4-金融市场的功能"><a href="#1-2-4-金融市场的功能" class="headerlink" title="1.2.4 金融市场的功能"></a>1.2.4 金融市场的功能</h4><p>实现资源的有效分配，关键是定价，定价的基础是信息。<br><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212282028330.png"></p><h2 id="2-第二章：利率"><a href="#2-第二章：利率" class="headerlink" title="2 第二章：利率"></a>2 第二章：利率</h2><h3 id="2-1-利率的界定与作用"><a href="#2-1-利率的界定与作用" class="headerlink" title="2.1 利率的界定与作用"></a>2.1 利率的界定与作用</h3><p>$$Finsher Equation: 1 + i &#x3D; (1+r)(1+I)$$<br>$i$: nominal interest rate</p><p>$r$: real interest rate</p><p>$I$: Inflation rate</p><h3 id="2-2-利率的决定理论"><a href="#2-2-利率的决定理论" class="headerlink" title="2.2 利率的决定理论"></a>2.2 利率的决定理论</h3><ol><li>古典利率理论</li><li>可贷资金理论</li><li>凯恩斯的利率理论</li><li>流动性偏好理论</li></ol><h3 id="2-3-利率的风险与期限（term-structure）结构"><a href="#2-3-利率的风险与期限（term-structure）结构" class="headerlink" title="2.3 利率的风险与期限（term structure）结构"></a>2.3 利率的风险与期限（term structure）结构</h3><h4 id="2-3-1-利率的风险结构"><a href="#2-3-1-利率的风险结构" class="headerlink" title="2.3.1 利率的风险结构"></a>2.3.1 利率的风险结构</h4><ol><li>流动性 liquidity</li><li>所得税 Income Tax Considerations</li><li>风险升水 Risk Premium</li></ol><h4 id="2-3-2-利率的期限结构"><a href="#2-3-2-利率的期限结构" class="headerlink" title="2.3.2 利率的期限结构"></a>2.3.2 利率的期限结构</h4><h3 id="2-4-我国的利率市场化"><a href="#2-4-我国的利率市场化" class="headerlink" title="2.4 我国的利率市场化"></a>2.4 我国的利率市场化</h3><h2 id="3-第三章：中央银行与货币政策"><a href="#3-第三章：中央银行与货币政策" class="headerlink" title="3 第三章：中央银行与货币政策"></a>3 第三章：中央银行与货币政策</h2><h3 id="3-1-中央银行的形成和发展"><a href="#3-1-中央银行的形成和发展" class="headerlink" title="3.1 中央银行的形成和发展"></a>3.1 中央银行的形成和发展</h3><p>中央银行形成的必要性：</p><ol><li>银行券（bank note）的统一发行</li><li>全国统一的清算机构</li><li>对商业银行提供最后的流动性支持</li><li>对金融机构监督、协调</li></ol><h3 id="3-2-中央银行的职能"><a href="#3-2-中央银行的职能" class="headerlink" title="3.2 中央银行的职能"></a>3.2 中央银行的职能</h3><ul><li>货币发行</li><li>宏观调控</li></ul><h3 id="3-3-中央银行的独立性问题"><a href="#3-3-中央银行的独立性问题" class="headerlink" title="3.3 中央银行的独立性问题"></a>3.3 中央银行的独立性问题</h3><ul><li>美国联邦储备委员会</li><li>中央银行货币政策委员会</li></ul><h3 id="3-4-货币供给（M1-的货币乘数）"><a href="#3-4-货币供给（M1-的货币乘数）" class="headerlink" title="3.4 货币供给（M1 的货币乘数）"></a>3.4 货币供给（M1 的货币乘数）</h3><p>$$m &#x3D; \frac{1+c}{rr+rr_t + e + c}$$</p><p>$M &#x3D; mB$</p><p>$B &#x3D; R + C$</p><p>利率倒挂、存款准备金率</p><h3 id="3-5-货币政策"><a href="#3-5-货币政策" class="headerlink" title="3.5 货币政策"></a>3.5 货币政策</h3><p><a href="img">货币增发</a></p><h4 id="3-5-1-Tobin’s-Q"><a href="#3-5-1-Tobin’s-Q" class="headerlink" title="3.5.1 Tobin’s Q"></a>3.5.1 Tobin’s Q</h4><p>$$Q &#x3D; \frac{市值}{资本重置成本} $$<br>Compared to 1</p><p>$$货币增发 \to 股票价格\uparrow \to Q\uparrow \to 投资\uparrow \to GDP \uparrow$$</p><h2 id="4-第四章：货币市场"><a href="#4-第四章：货币市场" class="headerlink" title="4 第四章：货币市场"></a>4 第四章：货币市场</h2><h3 id="4-1-货币市场概述"><a href="#4-1-货币市场概述" class="headerlink" title="4.1 货币市场概述"></a>4.1 货币市场概述</h3><ol><li>货币市场（1 年期）特征</li><li>货币市场功能：<ol><li>短期融资</li><li>政策工具（央行：1.法定存款准备金 2. 再贴现率 3. 公开市场业务）</li></ol></li></ol><h3 id="4-2-同业拆借市场"><a href="#4-2-同业拆借市场" class="headerlink" title="4.2 同业拆借市场"></a>4.2 同业拆借市场</h3><h3 id="4-3-票据市场"><a href="#4-3-票据市场" class="headerlink" title="4.3 票据市场"></a>4.3 票据市场</h3><h4 id="4-3-1-商业承兑票据（Commercial-Paper）"><a href="#4-3-1-商业承兑票据（Commercial-Paper）" class="headerlink" title="4.3.1 商业承兑票据（Commercial Paper）"></a>4.3.1 商业承兑票据（Commercial Paper）</h4><p>270天内， 平均 20-50 天<br>美国有四家评级机构</p><h4 id="4-3-2-银行承兑票据"><a href="#4-3-2-银行承兑票据" class="headerlink" title="4.3.2 银行承兑票据"></a>4.3.2 银行承兑票据</h4><h4 id="4-3-3-短期政府债券市场（T-Bills）"><a href="#4-3-3-短期政府债券市场（T-Bills）" class="headerlink" title="4.3.3 短期政府债券市场（T-Bills）"></a>4.3.3 短期政府债券市场（T-Bills）</h4><h4 id="4-3-4-大额可转让定期市场-Negotiable-Certificates-of-Deposits"><a href="#4-3-4-大额可转让定期市场-Negotiable-Certificates-of-Deposits" class="headerlink" title="4.3.4 大额可转让定期市场(Negotiable Certificates of Deposits)"></a>4.3.4 大额可转让定期市场(Negotiable Certificates of Deposits)</h4><p>简称 CDs </p><p><a href="%E4%BA%A4%E6%98%93%E5%9B%BE">img</a></p><h3 id="4-4-回购市场"><a href="#4-4-回购市场" class="headerlink" title="4.4 回购市场"></a>4.4 回购市场</h3><ul><li>回购协议（repurchase agreement）</li></ul><p><a href="%E4%BA%A4%E6%98%93%E5%9B%BE">img</a></p><p>本质为短期抵押贷款<br>抵押品为证券</p><h2 id="第五章：股票市场"><a href="#第五章：股票市场" class="headerlink" title="第五章：股票市场"></a>第五章：股票市场</h2><h3 id="股票市场概述"><a href="#股票市场概述" class="headerlink" title="股票市场概述"></a>股票市场概述</h3><h3 id="股票的发行"><a href="#股票的发行" class="headerlink" title="股票的发行"></a>股票的发行</h3><h3 id="股票的交易"><a href="#股票的交易" class="headerlink" title="股票的交易"></a>股票的交易</h3><h3 id="股票的定价"><a href="#股票的定价" class="headerlink" title="股票的定价"></a>股票的定价</h3><h3 id="我国的股票市场"><a href="#我国的股票市场" class="headerlink" title="我国的股票市场"></a>我国的股票市场</h3><h2 id="第六章：商业银行"><a href="#第六章：商业银行" class="headerlink" title="第六章：商业银行"></a>第六章：商业银行</h2><h3 id="商业银行的产生与发展"><a href="#商业银行的产生与发展" class="headerlink" title="商业银行的产生与发展"></a>商业银行的产生与发展</h3><h3 id="商业银行的作用"><a href="#商业银行的作用" class="headerlink" title="商业银行的作用"></a>商业银行的作用</h3><h3 id="商业银行的资产负债业务"><a href="#商业银行的资产负债业务" class="headerlink" title="商业银行的资产负债业务"></a>商业银行的资产负债业务</h3><h3 id="商业银行的中间业务和表外业务"><a href="#商业银行的中间业务和表外业务" class="headerlink" title="商业银行的中间业务和表外业务"></a>商业银行的中间业务和表外业务</h3><h3 id="商业银行的经营与管理"><a href="#商业银行的经营与管理" class="headerlink" title="商业银行的经营与管理"></a>商业银行的经营与管理</h3><h2 id="第七章：证券经营机构"><a href="#第七章：证券经营机构" class="headerlink" title="第七章：证券经营机构"></a>第七章：证券经营机构</h2><h3 id="证券机构概述"><a href="#证券机构概述" class="headerlink" title="证券机构概述"></a>证券机构概述</h3><h3 id="证券机构的基本功能"><a href="#证券机构的基本功能" class="headerlink" title="证券机构的基本功能"></a>证券机构的基本功能</h3><h3 id="证券机构的业务性质及融资渠道"><a href="#证券机构的业务性质及融资渠道" class="headerlink" title="证券机构的业务性质及融资渠道"></a>证券机构的业务性质及融资渠道</h3><h3 id="证券机构的业务经营"><a href="#证券机构的业务经营" class="headerlink" title="证券机构的业务经营"></a>证券机构的业务经营</h3><h2 id="第八章：金融市场监督"><a href="#第八章：金融市场监督" class="headerlink" title="第八章：金融市场监督"></a>第八章：金融市场监督</h2><h3 id="金融监管概述"><a href="#金融监管概述" class="headerlink" title="金融监管概述"></a>金融监管概述</h3><h3 id="金融监管的经济学分析"><a href="#金融监管的经济学分析" class="headerlink" title="金融监管的经济学分析"></a>金融监管的经济学分析</h3><h3 id="金融监管体系"><a href="#金融监管体系" class="headerlink" title="金融监管体系"></a>金融监管体系</h3><h3 id="我国的金融监管"><a href="#我国的金融监管" class="headerlink" title="我国的金融监管"></a>我国的金融监管</h3>]]></content>
      
      
      <categories>
          
          <category> Course </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大三上 </tag>
            
            <tag> 金融市场与机构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Derivatives</title>
      <link href="/article/f1b79b2a.html"/>
      <url>/article/f1b79b2a.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309011440006.jpg"></p><h2 id="第一章：引言"><a href="#第一章：引言" class="headerlink" title="第一章：引言"></a>第一章：引言</h2><p>TextBook: Options, Futures and other derivatives 10th. Pearson</p><blockquote><p>Derivatives are contracts which depend on varies values of underlying assets.</p></blockquote><ul><li>CCPs: central counterparties</li></ul><p>$$A&lt;-&gt; CCPs &lt;-&gt; B$$</p><ul><li>SEFs: swap executive facilities</li></ul><h3 id="1-1-types-of-traders-in-financial-market-and-their-function"><a href="#1-1-types-of-traders-in-financial-market-and-their-function" class="headerlink" title="1.1 types of traders in financial market and their function"></a>1.1 types of traders in financial market and their function</h3><ol><li>hedgers: hedging strategies using forward&#x2F;future contracts, option</li><li>speculators: same</li><li>arbitrageurs: same traders introduce information into market while trading and help the market evolve to effective market.</li></ol><h2 id="第二章：期货市场和利用期货合约套期保值"><a href="#第二章：期货市场和利用期货合约套期保值" class="headerlink" title="第二章：期货市场和利用期货合约套期保值"></a>第二章：期货市场和利用期货合约套期保值</h2><h3 id="2-1-外汇市场攻击路线"><a href="#2-1-外汇市场攻击路线" class="headerlink" title="2.1 外汇市场攻击路线"></a>2.1 外汇市场攻击路线</h3><h4 id="2-1-1-即期外汇市场攻击路线"><a href="#2-1-1-即期外汇市场攻击路线" class="headerlink" title="2.1.1 即期外汇市场攻击路线"></a>2.1.1 即期外汇市场攻击路线</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309072231059.jpg"></p><h4 id="2-1-2-远期外汇市场和外汇期货市场的攻击路线"><a href="#2-1-2-远期外汇市场和外汇期货市场的攻击路线" class="headerlink" title="2.1.2 远期外汇市场和外汇期货市场的攻击路线"></a>2.1.2 远期外汇市场和外汇期货市场的攻击路线</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309072232365.jpg"></p><h4 id="2-1-3-汇市和股市发动联合攻击的路线"><a href="#2-1-3-汇市和股市发动联合攻击的路线" class="headerlink" title="2.1.3 汇市和股市发动联合攻击的路线"></a>2.1.3 汇市和股市发动联合攻击的路线</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309072233962.jpg"></p><h3 id="2-2-期货交易流程"><a href="#2-2-期货交易流程" class="headerlink" title="2.2 期货交易流程"></a>2.2 期货交易流程</h3><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309072234082.jpg"></p><h3 id="2-3-The-Specification-of-the-Futures-Contract"><a href="#2-3-The-Specification-of-the-Futures-Contract" class="headerlink" title="2.3 The Specification of the Futures Contract"></a>2.3 The Specification of the Futures Contract</h3><ul><li>Key Concept<ul><li>Daily price Movement Limits<ul><li>Limit down（跌停板）</li><li>Limit up（涨停板）</li><li>A limit move（涨停板变动）</li><li>The purpose of daily price limits is to prevent large price movements from occurring because of speculative excesses.</li></ul></li><li>Position Limits<ul><li>The purpose of the limits is to prevent speculators from exercising undue(不适当的) influence on the market.</li></ul></li></ul></li></ul><h3 id="2-4-Margin"><a href="#2-4-Margin" class="headerlink" title="2.4 Margin"></a>2.4 Margin</h3><p>Terminology</p><ul><li>Margin account（保证金帐户）</li><li>Initial margin（初始保证金）</li><li>Marking to market（盯市）</li><li>Maintenance margin（维持保证金）</li><li>Margin call（保证金催付）</li><li>Variation margin（变动保证金） 规律：</li></ul><ol><li>持仓越多，保证金比率越高</li><li>距离交割日越近，保证金比率越高</li></ol><h4 id="2-4-1-The-Operation-of-Margins"><a href="#2-4-1-The-Operation-of-Margins" class="headerlink" title="2.4.1 The Operation of Margins"></a>2.4.1 The Operation of Margins</h4><ul><li>Price（价格）</li><li>Settlement price（结算价格）</li><li>Lifetime highs and lows（有效期内的最高价和最低价）</li><li>Open interest and volume of trading（未平仓合约数和交易量）</li><li>Patterns of futures prices（期货价格模式）</li></ul><p>Some terminology</p><ul><li>Opening price（开盘价）</li><li>Settlement price（结算价格）</li><li>the price just before the final bell each day used for the daily settlement process</li><li>Open interest(未平仓合约数)</li><li>the total number of contracts outstanding</li><li>equal to number of long positions or number of short positions</li><li>Normal market(正常市场）</li><li>Inverted market（逆转市场）</li></ul><h4 id="2-4-2-Convergence-Of-Futures-Price-to-Spot-Price"><a href="#2-4-2-Convergence-Of-Futures-Price-to-Spot-Price" class="headerlink" title="2.4.2 Convergence Of Futures Price to Spot Price"></a>2.4.2 Convergence Of Futures Price to Spot Price</h4><p>As the delivery month of a futures contract is approached, the futures price （期货价格）converges to the spot price （现货价格）of the underlying asset. When the delivery period is reached, the futures price equals – or is very close to – the spot price.</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309072244313.jpg"></p><h3 id="2-5-Basis-Risk"><a href="#2-5-Basis-Risk" class="headerlink" title="2.5 Basis Risk"></a>2.5 Basis Risk</h3><p>$$b &#x3D; S - F$$</p><p>where:</p><ul><li>b : Basis 基差</li><li>S: spot price of asset to be hedged</li><li>F: Futures price of contract used</li></ul><p>Some notation:</p><ul><li>F1 : Futures Price at time t1</li><li>F2 : Futures Price at time t2</li><li>S1 : Spot Price at time t1</li><li>S2 : Spot price at time t2</li><li>b1 : Basis at time t1</li><li>b2 : Basis at time t2</li></ul><blockquote><p>We ignore the time value of money（货币时间价值）</p></blockquote><h4 id="2-5-1-A-Short-Position-Hedger"><a href="#2-5-1-A-Short-Position-Hedger" class="headerlink" title="2.5.1 A Short Position Hedger"></a>2.5.1 A Short Position Hedger</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309072248201.jpg"></p><p>The asset that gives rise to the hedger’s exposure is sometimes different from the asset underlying the hedge. The basis risk is then usually greater.</p><p>$$The\ effective\ price &#x3D; S2 + F1 – F2$$</p><p>$$The\ effective\ price &#x3D; F1 + (S2* – F2 ) + (S2 – S2* )$$</p><ul><li>S2* : The price of the asset underlying the futures contract at time $t_2$.</li><li>S2 : The price of the asset being hedged at time $t_2$.</li></ul><h4 id="2-5-2-Minimum-Variance-Hedge-Ratio"><a href="#2-5-2-Minimum-Variance-Hedge-Ratio" class="headerlink" title="2.5.2 Minimum Variance Hedge Ratio"></a>2.5.2 Minimum Variance Hedge Ratio</h4><p>if an investor is to sell one unit of the asset, she has to short h units of the futures. The portfolio position at time $t_0$ is worth</p><p>$$\pi(t_0) &#x3D; S(t_0) - hF(t_0,T)$$</p><p>where position at time $t_1$ will be worth <img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309072253178.jpg"></p><p>The change in the value of the position will therefore be, and a short position will be</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309072255761.jpg"></p><p>In both cases the variance of $\Delta \pi$ is equal to</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309072256920.jpg"></p><p>Proportion of the exposure that should optimally be hedged is</p><p>$$h &#x3D; \rho \frac{\sigma_S}{\sigma_F}$$</p><p>Optimal Number of Contracts <img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309072258385.jpg"></p><h4 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309072259598.jpg"></p><h3 id="2-6-The-Capital-Market-Line-CML"><a href="#2-6-The-Capital-Market-Line-CML" class="headerlink" title="2.6 The Capital Market Line(CML)"></a>2.6 The Capital Market Line(CML)</h3><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309072300279.jpg"></p><h3 id="2-7-Hedging-an-Equity-Portfolio"><a href="#2-7-Hedging-an-Equity-Portfolio" class="headerlink" title="2.7 Hedging an Equity Portfolio"></a>2.7 Hedging an Equity Portfolio</h3><p>Stock index futures can be used to hedge a well-diversified equity portfolio. Define:</p><ul><li>$V_A$: Current value of the portfolio</li><li>$V_F$ : Current value of one futures contract (the futures price times the contract size)</li></ul><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309072312598.jpg"></p><h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309072313518.jpg"> <img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309072313688.jpg"><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309072314474.jpg"></p><h2 id="第三章：远期和期货价格-Forward-and-Futures-Price"><a href="#第三章：远期和期货价格-Forward-and-Futures-Price" class="headerlink" title="第三章：远期和期货价格 Forward and Futures Price"></a>第三章：远期和期货价格 Forward and Futures Price</h2><h3 id="3-1-Consumption-vs-Investment-Assets"><a href="#3-1-Consumption-vs-Investment-Assets" class="headerlink" title="3.1 Consumption vs Investment Assets"></a>3.1 Consumption vs Investment Assets</h3><ul><li>Investment assets are held by significant numbers of people purely for investment purposes (Examples: Stocks, Bonds, gold, silver)</li><li>Consumption assets are held primarily for consumption (Examples: copper, oil)</li></ul><h3 id="3-2-Financial-futures-price"><a href="#3-2-Financial-futures-price" class="headerlink" title="3.2  Financial futures price"></a>3.2  Financial futures price</h3><h4 id="3-2-1-Measuring-Interest-Rates"><a href="#3-2-1-Measuring-Interest-Rates" class="headerlink" title="3.2.1 Measuring Interest Rates"></a>3.2.1 Measuring Interest Rates</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309191851793.jpg"></p><h4 id="3-2-2-Continuous-Compounding"><a href="#3-2-2-Continuous-Compounding" class="headerlink" title="3.2.2 Continuous Compounding"></a>3.2.2 Continuous Compounding</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309191852910.jpg"></p><h3 id="3-3-Some-Inference"><a href="#3-3-Some-Inference" class="headerlink" title="3.3 Some Inference"></a>3.3 Some Inference</h3><p>$$\beta_{im} &#x3D; \frac{\sigma_{im}}{\sigma_{m}^2} &#x3D; \rho \frac{\sigma_i \sigma_m}{\sigma_{m}^2} &#x3D;\rho \frac{ \sigma_i}{\sigma_m} &#x3D; h^*$$</p><p>$$N^* &#x3D; \beta_{im}\frac{V_A}{V_F} &#x3D; \frac{h^* V_A}{V_F}$$</p><p>$$R &#x3D; \frac{P_{t+1}-P_t + D}{P_t}$$<br>$$E(ri) &#x3D; r_f + \beta_{im}(E(r_m) -r_f)$$</p><h3 id="3-4-The-Arbitrage-Formula"><a href="#3-4-The-Arbitrage-Formula" class="headerlink" title="3.4 The Arbitrage Formula"></a>3.4 The Arbitrage Formula</h3><h4 id="3-4-1-For-financial-futures"><a href="#3-4-1-For-financial-futures" class="headerlink" title="3.4.1 For financial futures"></a>3.4.1 For financial futures</h4><p>$$ F_0 &#x3D; S_0 e^{rT}$$</p><p>$$ F_0 &#x3D; S_0 e^{(r-q)T}$$<br>where q is the average yield during the life of the contract (expressed with continuous compounding)</p><p>Bond<br>$$ F_0 &#x3D; (S_0-I) e^{rT}$$</p><p>Stock Index<br>$$ F_0 &#x3D; S_0 e^{rT}\ where\ the\ S_0 \ is\ Stock\ Index$$</p><p>Forwards and Futures on Currencies<br>$$ F_0 &#x3D; S_0 e^{(r-r_f)T}$$</p><h4 id="3-4-2-For-physical-futures"><a href="#3-4-2-For-physical-futures" class="headerlink" title="3.4.2 For physical futures"></a>3.4.2 For physical futures</h4><p>Futures on Commodities<br>$$ F_0 &#x3D; (S_0 + u) e^{rT}$$<br>or<br>$$ F_0 &#x3D; S_0 e^{(r+u)T}$$<br>where u is storage cost</p><p>Convenience Yield<br>$$ F_0 &#x3D; S_0 e^{(r+u - y)T}$$</p><p>Carry on Cost(interest rate+storage cost)<br>$$ F_0 &#x3D; S_0 e^{(c-y)T}$$</p><h2 id="第四章：期权价格特征-Option-Price-Characteristics"><a href="#第四章：期权价格特征-Option-Price-Characteristics" class="headerlink" title="第四章：期权价格特征 Option Price Characteristics"></a>第四章：期权价格特征 Option Price Characteristics</h2><p>Question: Is $F_0 &#x3D;^? E(S_T)$</p><table><thead><tr><th></th><th>$F_0e^{-rT}$</th><th>+ long</th></tr></thead><tbody><tr><td>T</td><td>$F_0$</td><td>$S_T$</td></tr><tr><td>0</td><td>$F_0e^{-rT}$</td><td>$S_Te^{-kT}$</td></tr></tbody></table><p>$k &#x3D; r_f + \beta(r_m - r_f)$</p><blockquote><p>k is investor’s expected return</p></blockquote><h3 id="4-1-Option"><a href="#4-1-Option" class="headerlink" title="4.1 Option"></a>4.1 Option</h3><h4 id="4-1-1-The-situations-of-option"><a href="#4-1-1-The-situations-of-option" class="headerlink" title="4.1.1 The situations of option"></a>4.1.1 The situations of option</h4><ul><li>Out of money 虚值（若立即执行会亏损）</li><li>In the money 实值</li><li>At the money 两平</li></ul><h3 id="4-2-The-value-of-option"><a href="#4-2-The-value-of-option" class="headerlink" title="4.2 The value of option"></a>4.2 The value of option</h3><ul><li><p>Instrisic Value<br>call option :<br>$$max(S-X,0)$$<br>$$max(S - Xe^{-rT}, 0)$$<br>put option:<br>$$max(X-S,0)$$<br>$$max(Xe^{-rT} - S, 0)$$</p></li><li><p>Time Value</p></li></ul><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309231717452.jpg"></p><h4 id="4-2-1-Effect-of-Variables-on-Option-Pricing"><a href="#4-2-1-Effect-of-Variables-on-Option-Pricing" class="headerlink" title="4.2.1 Effect of Variables on Option Pricing"></a>4.2.1 Effect of Variables on Option Pricing</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309231718197.jpg"></p><h2 id="第五章：期权交易策略"><a href="#第五章：期权交易策略" class="headerlink" title="第五章：期权交易策略"></a>第五章：期权交易策略</h2><h3 id="5-1-Upper-and-Lower-Bounds-for-Option-Prices"><a href="#5-1-Upper-and-Lower-Bounds-for-Option-Prices" class="headerlink" title="5.1 Upper and Lower Bounds for Option Prices"></a>5.1 Upper and Lower Bounds for Option Prices</h3><blockquote><p>Assumption:</p><ol><li>There are no transactions costs</li><li>All trading profits(net of trading losses) are subject to the same tax rate</li><li>Borrowing and lending are possible at the risk-free interest rate</li></ol></blockquote><h4 id="5-1-1-Upper-Bounds-for-Call-Option"><a href="#5-1-1-Upper-Bounds-for-Call-Option" class="headerlink" title="5.1.1 Upper Bounds for Call Option"></a>5.1.1 Upper Bounds for Call Option</h4><blockquote><p>For call option, at any case, the option can never be worth more than the stock</p></blockquote><p>$$c ≤  S0 \ and\ C ≤ S0$$<br>For put option</p><p>$P ≤ X$  for American option </p><p>$p ≤ Xe^{-rT}$ for European option</p><h4 id="5-1-2-Lower-Bounds-for-Call-Option"><a href="#5-1-2-Lower-Bounds-for-Call-Option" class="headerlink" title="5.1.2 Lower  Bounds for Call Option"></a>5.1.2 Lower  Bounds for Call Option</h4><blockquote><p>A lower bound （下界）for the price of a European call option  on a non-dividend-paying stock: </p></blockquote><p>$$ c \geq max(S_0  - Xe^{-rt},0)$$</p><ul><li>Portfolio A: one call option with strike price X and an amount of cash equal to $Xe^{-rt}$</li><li>Portfolio B: one share</li></ul><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309231727174.jpg" alt="Question"></p><h3 id="5-2-Put-Call-Parity"><a href="#5-2-Put-Call-Parity" class="headerlink" title="5.2 Put-Call Parity"></a>5.2 Put-Call Parity</h3><p>$$ C + Xe^{-rT} &#x3D; P + S$$</p><h2 id="第六章：二叉树模型介绍"><a href="#第六章：二叉树模型介绍" class="headerlink" title="第六章：二叉树模型介绍"></a>第六章：二叉树模型介绍</h2><h3 id="6-1-Binomial-Trees-Pricing-Model"><a href="#6-1-Binomial-Trees-Pricing-Model" class="headerlink" title="6.1 Binomial Trees Pricing Model"></a>6.1 Binomial Trees Pricing Model</h3><h4 id="6-1-1-Risk-Neutral-Valuation"><a href="#6-1-1-Risk-Neutral-Valuation" class="headerlink" title="6.1.1 Risk-Neutral Valuation"></a>6.1.1 Risk-Neutral Valuation</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309231732601.jpg"></p><h4 id="6-1-2-Self-Financing"><a href="#6-1-2-Self-Financing" class="headerlink" title="6.1.2 Self-Financing"></a>6.1.2 Self-Financing</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309231733369.jpg"></p><h2 id="第七章：股价行为模型-Model-of-behavior-of-stock-price"><a href="#第七章：股价行为模型-Model-of-behavior-of-stock-price" class="headerlink" title="第七章：股价行为模型 Model of behavior of stock price"></a>第七章：股价行为模型 Model of behavior of stock price</h2><h3 id="7-1-Markov-Property-and-Wiener-Process"><a href="#7-1-Markov-Property-and-Wiener-Process" class="headerlink" title="7.1 Markov Property and Wiener Process"></a>7.1 Markov Property and Wiener Process</h3><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072217273.jpg"></p><blockquote><p>A Markov process （马尔可夫过程）is a particular type of stochastic process where only the present value of a variable is relevant for predicting the future</p></blockquote><h4 id="7-1-1-Weak-Form-Market-Efficiency"><a href="#7-1-1-Weak-Form-Market-Efficiency" class="headerlink" title="7.1.1 Weak-Form Market Efficiency"></a>7.1.1 Weak-Form Market Efficiency</h4><blockquote><p>Weak-Form Market Efficiency(弱市场有效) means that  the set of information only contains history of price and revenue ; that is, the present price reflects the information about all the history record of securities.</p></blockquote><h4 id="7-1-2-A-Wiener-Process"><a href="#7-1-2-A-Wiener-Process" class="headerlink" title="7.1.2 A Wiener Process"></a>7.1.2 A Wiener Process</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072222486.jpg"></p><h5 id="7-1-2-1-Properties-of-a-Wiener-Process"><a href="#7-1-2-1-Properties-of-a-Wiener-Process" class="headerlink" title="7.1.2.1 Properties of a Wiener Process"></a>7.1.2.1 Properties of a Wiener Process</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072223166.jpg"></p><p>$$dz &#x3D; \epsilon \sqrt{dt}$$<br>$E[(dz)] &#x3D; 0$ and $var[(dz)] &#x3D; dt$</p><h3 id="7-2-Process-for-Stock-Price"><a href="#7-2-Process-for-Stock-Price" class="headerlink" title="7.2 Process for Stock Price"></a>7.2 Process for Stock Price</h3><h4 id="7-2-1-Ito-Process"><a href="#7-2-1-Ito-Process" class="headerlink" title="7.2.1 Ito Process"></a>7.2.1 Ito Process</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072231614.jpg"></p><h4 id="7-2-2-An-Ito-Process-for-Stock-Prices"><a href="#7-2-2-An-Ito-Process-for-Stock-Prices" class="headerlink" title="7.2.2 An Ito Process for Stock Prices"></a>7.2.2 An Ito Process for Stock Prices</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072232556.jpg"></p><h3 id="7-3-Ito’s-Lemma"><a href="#7-3-Ito’s-Lemma" class="headerlink" title="7.3 Ito’s Lemma"></a>7.3 Ito’s Lemma</h3><blockquote><p>If we know the stochastic process followed by x, Ito’s lemma tells us the stochastic process followed by some function G (x, t )</p></blockquote><blockquote><p>Since a derivative security is a function of the price of the underlying asset and time, Ito’s lemma plays an important role in the analysis of derivative securities</p></blockquote><p><strong>1 A Taylor’s series expansion of G(x, t) gives</strong><br><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072236140.jpg"></p><p><strong>2 Substituting for $\Delta x$</strong></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072237711.jpg"></p><p><strong>3 The $\epsilon^2 \Delta t$ Term</strong></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072239952.jpg"></p><p><strong>4 Taking Limits</strong><br><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072240150.jpg"></p><h2 id="第八章：Black-Scholes公式-Black-Scholes-formula"><a href="#第八章：Black-Scholes公式-Black-Scholes-formula" class="headerlink" title="第八章：Black-Scholes公式 Black-Scholes formula"></a>第八章：Black-Scholes公式 Black-Scholes formula</h2><h3 id="8-1-Lognormal-Property"><a href="#8-1-Lognormal-Property" class="headerlink" title="8.1 Lognormal Property"></a>8.1 Lognormal Property</h3><h4 id="8-1-1-The-Stock-Price-Assumption"><a href="#8-1-1-The-Stock-Price-Assumption" class="headerlink" title="8.1.1 The Stock Price Assumption"></a>8.1.1 The Stock Price Assumption</h4><p>$$\Delta S &#x3D; \mu S\Delta t + \sigma S \epsilon \sqrt{\Delta t}$$</p><p>In a short period of time of length $\Delta t$, the return on the stock is normally distributed:<br>$$\frac{\Delta S}{S} &#x2F;~ \phi(\mu \Delta t, \sigma \sqrt{\Delta t})$$</p><h4 id="8-1-2-Application-of-Ito’s-Lemma-to-a-Stock-Price-Process"><a href="#8-1-2-Application-of-Ito’s-Lemma-to-a-Stock-Price-Process" class="headerlink" title="8.1.2 Application of Ito’s Lemma to a Stock Price Process"></a>8.1.2 Application of Ito’s Lemma to a Stock Price Process</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072248620.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072252013.jpg"></p><h4 id="8-1-3-The-lognormal-Distribution"><a href="#8-1-3-The-lognormal-Distribution" class="headerlink" title="8.1.3 The lognormal Distribution"></a>8.1.3 The lognormal Distribution</h4><p>It follows from this assumption that<br><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072253489.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072254894.jpg" alt="The Plot of Lognormal Distribution"></p><h3 id="8-2-Derivation-of-The-Black-Scholes-Merton-Differential-Equation"><a href="#8-2-Derivation-of-The-Black-Scholes-Merton-Differential-Equation" class="headerlink" title="8.2 Derivation of The Black-Scholes-Merton Differential Equation"></a>8.2 Derivation of The Black-Scholes-Merton Differential Equation</h3><h4 id="8-2-1-The-Black-Scholes-x2F-Merton-Model-Hedging-Approach"><a href="#8-2-1-The-Black-Scholes-x2F-Merton-Model-Hedging-Approach" class="headerlink" title="8.2.1 The Black-Scholes&#x2F;Merton Model-Hedging Approach"></a>8.2.1 The Black-Scholes&#x2F;Merton Model-Hedging Approach</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072259304.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072300783.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072300885.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072301006.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072301956.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072301501.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072302686.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072302352.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072303040.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072303516.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072303902.jpg"></p><h4 id="8-2-2-Properties-of-Black-Scholes-x2F-Merton-Formula"><a href="#8-2-2-Properties-of-Black-Scholes-x2F-Merton-Formula" class="headerlink" title="8.2.2 Properties of Black-Scholes&#x2F;Merton Formula"></a>8.2.2 Properties of Black-Scholes&#x2F;Merton Formula</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072304032.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310072304618.jpg"></p><h3 id="8-3-Implied-Volatility"><a href="#8-3-Implied-Volatility" class="headerlink" title="8.3 Implied Volatility"></a>8.3 Implied Volatility</h3><blockquote><p>The implied volatility of an option is the volatility for which the Black-Scholes price equals the market price</p></blockquote><h2 id="第九章：股票指数期权和货币期权-Options-On-Stock-Indices-Currencies-and-Futures"><a href="#第九章：股票指数期权和货币期权-Options-On-Stock-Indices-Currencies-and-Futures" class="headerlink" title="第九章：股票指数期权和货币期权 Options On Stock Indices, Currencies, and Futures"></a>第九章：股票指数期权和货币期权 Options On Stock Indices, Currencies, and Futures</h2><h3 id="9-1-Options-on-stock-providing-dividend"><a href="#9-1-Options-on-stock-providing-dividend" class="headerlink" title="9.1 Options on stock providing dividend"></a>9.1 Options on stock providing dividend</h3><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310172044599.jpg"></p><h4 id="9-1-1-European-Options-on-Stocks-Providing-a-Dividend-Yield"><a href="#9-1-1-European-Options-on-Stocks-Providing-a-Dividend-Yield" class="headerlink" title="9.1.1 European Options on Stocks Providing a Dividend Yield"></a>9.1.1 European Options on Stocks Providing a Dividend Yield</h4><ul><li>The stock starts at price $S_0$ and provides a dividend yield &#x3D; q</li><li>The stock starts at prices $S_0e^{-qT}$ and provides no income</li></ul><h4 id="9-1-2-Lower-Bounds-For-Option-Prices"><a href="#9-1-2-Lower-Bounds-For-Option-Prices" class="headerlink" title="9.1.2 Lower Bounds For Option Prices"></a>9.1.2 Lower Bounds For Option Prices</h4><ul><li>$c \geq max(S_0 - Xe^{-rT}, 0)$</li><li>$c \geq max(S_0e^{-qT} - Xe^{-rT}, 0)$</li></ul><p>Lower Bound for calls:<br>$$c \geq S_0 e^{-qT} - Xe^{-rT}$$</p><ul><li>$p \geq max(Xe^{-rT} - S_0 , 0)$</li><li>$p \geq max(Xe^{-rT} - S_0e^{-qT}  , 0)$</li></ul><p>Lower Bound for puts:<br>$$p \geq  Xe^{-rT} - S_0 e^{-qT} $$</p><p><strong>Put Call Parity</strong><br>$$c + Xe^{-rT} &#x3D; p + S_0e^{-qT}$$</p><p><strong>American options Put Call Parity</strong><br>$$S_0e^{-qT} - X \leq C - P \leq S_0 - Xe^{-rT}$$</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310172119014.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310172120430.jpg"></p><h3 id="9-2-Options-on-stock-indices"><a href="#9-2-Options-on-stock-indices" class="headerlink" title="9.2 Options on stock indices"></a>9.2 Options on stock indices</h3><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310172124281.jpg"></p><h3 id="9-3-Currency-Options"><a href="#9-3-Currency-Options" class="headerlink" title="9.3 Currency Options"></a>9.3 Currency Options</h3><h3 id="9-4-Futures-Option"><a href="#9-4-Futures-Option" class="headerlink" title="9.4 Futures Option"></a>9.4 Futures Option</h3><h4 id="9-4-1-Put-Call-Parity-for-Futures-Options"><a href="#9-4-1-Put-Call-Parity-for-Futures-Options" class="headerlink" title="9.4.1 Put-Call Parity for Futures Options"></a>9.4.1 Put-Call Parity for Futures Options</h4><p>$$c + Ke^{-rT} &#x3D; p + F_0e^{-rT}$$<br>$$F_0e^{-rT} - X \leq C - P \leq F_0 - X e^{-rT}$$</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310172133997.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310172134257.jpg"></p><p>Value of the portfolio at time T is<br>$$F_0u\Delta - F_0\Delta - f_u &#x3D; -f$$<br>and we obtain $f &#x3D; -(F_0u\Delta - F_0\Delta - f_u)e^{-rT}$</p><p><strong>Generalization</strong></p><p>substituting the $\Delta$ we obtain<br>$$f &#x3D; [pf_u + (1-p)f_d]e^{-rT}$$<br>$p &#x3D; \frac{1-d}{u-d}$</p><h2 id="第十章：希腊字母-Greek-Letters"><a href="#第十章：希腊字母-Greek-Letters" class="headerlink" title="第十章：希腊字母 Greek Letters"></a>第十章：希腊字母 Greek Letters</h2><h3 id="10-1-Common-Strategies-for-Risk"><a href="#10-1-Common-Strategies-for-Risk" class="headerlink" title="10.1 Common Strategies for Risk"></a>10.1 Common Strategies for Risk</h3><h4 id="10-1-1-Stop-Loss-Strategy-止损策略"><a href="#10-1-1-Stop-Loss-Strategy-止损策略" class="headerlink" title="10.1.1 Stop-Loss Strategy 止损策略"></a>10.1.1 Stop-Loss Strategy 止损策略</h4><p>低抛高买</p><h3 id="10-2-Delta-Hedging"><a href="#10-2-Delta-Hedging" class="headerlink" title="10.2 Delta Hedging"></a>10.2 Delta Hedging</h3><blockquote><p>Delta ($\Delta$) （德尔塔对冲）is the rate of change of the option price with respect to the underlying asset. </p></blockquote><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310172142154.jpg"></p><h4 id="10-2-1-Example"><a href="#10-2-1-Example" class="headerlink" title="10.2.1 Example"></a>10.2.1 Example</h4><blockquote><p>An investor has sold 20 call option contracts( 2,000 options ) on a certain stock. The option price is $10, the stock price is $100, and the option’s delta is 0.6. The investor wishes to hedge the position.</p></blockquote><p><strong>The strategy</strong></p><p>The investor immediately buys 0.6<em>2000&#x3D;1200 shares. It means that over the next short period of time, the call price will tend to change by 60% of the stock price and the loss (gain) on the call will be offset by the gain (loss) on the stock. As time passes, delta will change and the position in the stock will have to be adjusted. For example, if after three days the delta increases to 0.65, a further 0.05</em>2000&#x3D;100 shares will have to be bought.</p><h4 id="10-2-2-Dynamic-Hedging"><a href="#10-2-2-Dynamic-Hedging" class="headerlink" title="10.2.2 Dynamic Hedging"></a>10.2.2 Dynamic Hedging</h4><p>$$\Pi &#x3D; -f  + nS$$<br>$$\frac{\delta \Pi}{\delta S} &#x3D; -\frac{\delta f}{\delta S} + n &#x3D; 0$$<br>$$n &#x3D; \frac{\delta f}{\delta S}$$</p><ol><li><p>For a European call option on a non-dividend-paying stock<br>$$\Delta &#x3D; N(d_1)$$</p></li><li><p>For a European put option on a non-dividend-paying stock<br>$$\Delta &#x3D; N(d_1) - 1$$</p></li><li><p>The delta of a European call on a stock paying dividends at rate q<br>$$ \Delta &#x3D; \frac{\delta f}{\delta S} &#x3D; N(d_1)e^{-qT}$$</p></li><li><p>The delta of a European put on a stock paying dividends at rate q<br>$$ \Delta &#x3D; \frac{\delta f}{\delta S} &#x3D; [N(d_1)-1]e^{-qT}$$</p></li></ol><h3 id="10-3-Theta-Gamma-Vega-and-Rho"><a href="#10-3-Theta-Gamma-Vega-and-Rho" class="headerlink" title="10.3 Theta, Gamma, Vega and Rho"></a>10.3 Theta, Gamma, Vega and Rho</h3><h4 id="10-3-1-Theta"><a href="#10-3-1-Theta" class="headerlink" title="10.3.1 Theta"></a>10.3.1 Theta</h4><blockquote><p>Theta ($\Theta$ ) of a derivative  (or portfolio of derivatives $\Pi$ ) is the rate of change of the value with respect to the passage of time, it is usually negative</p></blockquote><p>$$\Theta &#x3D; \frac{\delta f}{\delta t}$$<br>or<br>$$\Theta &#x3D; \frac{\delta \pi}{\delta t}$$</p><h4 id="10-3-2-Gamma"><a href="#10-3-2-Gamma" class="headerlink" title="10.3.2 Gamma"></a>10.3.2 Gamma</h4><blockquote><p>Gamma ($\Gamma$ ) is the rate of change of delta ($\Delta$) with respect to the price of the underlying asset</p></blockquote><p>$$\Gamma &#x3D; \frac{\delta^2 \Pi}{\delta S^2}$$</p><p><strong>Gamma Addresses Delta Hedging Errors Caused By Curvature</strong><br><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310172159784.jpg"></p><h5 id="10-3-2-1-Taylor-Series-Expansions-and-Hedge-Parameters"><a href="#10-3-2-1-Taylor-Series-Expansions-and-Hedge-Parameters" class="headerlink" title="10.3.2.1 Taylor Series Expansions and Hedge Parameters"></a>10.3.2.1 Taylor Series Expansions and Hedge Parameters</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310172201810.jpg"></p><h5 id="10-3-2-2-Relationship-Among-Delta-Gamma-and-Theta"><a href="#10-3-2-2-Relationship-Among-Delta-Gamma-and-Theta" class="headerlink" title="10.3.2.2 Relationship  Among Delta, Gamma, and Theta"></a>10.3.2.2 Relationship  Among Delta, Gamma, and Theta</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310172203200.jpg"></p><h4 id="10-3-3-Vega"><a href="#10-3-3-Vega" class="headerlink" title="10.3.3 Vega"></a>10.3.3 Vega</h4><blockquote><p>Vega is the rate of change of the value of a derivatives portfolio with respect to volatility</p></blockquote><p>$$V &#x3D; \frac{\delta \Pi}{\delta \sigma}$$<br>Cause $Latex$ not support Vega using V substituting for Vega </p><h4 id="10-3-4-Example-Managing-Delta-Gamma-amp-Vega"><a href="#10-3-4-Example-Managing-Delta-Gamma-amp-Vega" class="headerlink" title="10.3.4 [Example] Managing  Delta, Gamma, &amp; Vega"></a>10.3.4 [Example] Managing  Delta, Gamma, &amp; Vega</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310172210937.jpg"></p><h4 id="10-3-5-Rho"><a href="#10-3-5-Rho" class="headerlink" title="10.3.5 Rho"></a>10.3.5 Rho</h4><blockquote><p>Rho is the rate of change of the value of a derivative with respect to the interest rate</p></blockquote><p>$$\rho &#x3D; \frac{\delta \Pi}{\delta r}$$</p><h2 id="第十一章：Value-at-Risk-VaR-amp-Trading-Strategies-of-Option"><a href="#第十一章：Value-at-Risk-VaR-amp-Trading-Strategies-of-Option" class="headerlink" title="第十一章：Value-at-Risk(VaR) &amp; Trading Strategies of Option"></a>第十一章：Value-at-Risk(VaR) &amp; Trading Strategies of Option</h2><h3 id="10-1-VaR"><a href="#10-1-VaR" class="headerlink" title="10.1 VaR"></a>10.1 VaR</h3><h4 id="10-1-1-Types-of-VaR"><a href="#10-1-1-Types-of-VaR" class="headerlink" title="10.1.1 Types of VaR"></a>10.1.1 Types of VaR</h4><blockquote><p>VaR: 在正常市场条件下和一定的置信水平上，测算出给定时间内预期发生最坏情况的损失</p></blockquote><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310192241495.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310192243098.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310192244862.jpg"></p><h4 id="10-1-2-Example-S-D-of-Portfolio"><a href="#10-1-2-Example-S-D-of-Portfolio" class="headerlink" title="10.1.2 Example S.D. of Portfolio"></a>10.1.2 Example S.D. of Portfolio</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310192246528.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310192247223.jpg"></p><h3 id="10-2-Trading-Strategies-Involving-Options"><a href="#10-2-Trading-Strategies-Involving-Options" class="headerlink" title="10.2 Trading Strategies Involving Options"></a>10.2 Trading Strategies Involving Options</h3><h4 id="10-2-1-Spread-Two-or-more-options-of-the-same-type"><a href="#10-2-1-Spread-Two-or-more-options-of-the-same-type" class="headerlink" title="10.2.1 Spread ( Two or more options of the same type)"></a>10.2.1 Spread ( Two or more options of the same type)</h4><h5 id="10-2-1-1-Bull-Spread-Using-Calls"><a href="#10-2-1-1-Bull-Spread-Using-Calls" class="headerlink" title="10.2.1.1 Bull Spread Using Calls"></a>10.2.1.1 Bull Spread Using Calls</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310192249955.jpg"></p><h5 id="10-2-1-2-Bull-Spread-Using-Puts"><a href="#10-2-1-2-Bull-Spread-Using-Puts" class="headerlink" title="10.2.1.2 Bull Spread Using Puts"></a>10.2.1.2 Bull Spread Using Puts</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310192250334.jpg"></p><h5 id="10-2-1-3-Bear-Spread-Using-Calls"><a href="#10-2-1-3-Bear-Spread-Using-Calls" class="headerlink" title="10.2.1.3 Bear Spread Using Calls"></a>10.2.1.3 Bear Spread Using Calls</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310192251822.jpg"></p><h5 id="10-2-1-4-Bear-Spread-Using-Puts"><a href="#10-2-1-4-Bear-Spread-Using-Puts" class="headerlink" title="10.2.1.4 Bear Spread Using Puts"></a>10.2.1.4 Bear Spread Using Puts</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310192251149.jpg"></p><h5 id="10-2-1-5-Butterfly-Spread-Using-Calls"><a href="#10-2-1-5-Butterfly-Spread-Using-Calls" class="headerlink" title="10.2.1.5 Butterfly Spread Using Calls"></a>10.2.1.5 Butterfly Spread Using Calls</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310192252358.jpg"></p><h5 id="10-2-1-6-Butterfly-Spread-Using-Puts"><a href="#10-2-1-6-Butterfly-Spread-Using-Puts" class="headerlink" title="10.2.1.6 Butterfly Spread Using Puts"></a>10.2.1.6 Butterfly Spread Using Puts</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310192253415.jpg"></p><h5 id="10-2-1-7-Calendar-Spread-Using-Calls"><a href="#10-2-1-7-Calendar-Spread-Using-Calls" class="headerlink" title="10.2.1.7 Calendar Spread Using Calls"></a>10.2.1.7 Calendar Spread Using Calls</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310192253707.jpg"></p><h5 id="10-2-1-8-Calendar-Spread-Using-Puts"><a href="#10-2-1-8-Calendar-Spread-Using-Puts" class="headerlink" title="10.2.1.8 Calendar Spread Using Puts"></a>10.2.1.8 Calendar Spread Using Puts</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310192253505.jpg"></p><h4 id="10-2-2-Combination-Mixture-of-calls-amp-puts"><a href="#10-2-2-Combination-Mixture-of-calls-amp-puts" class="headerlink" title="10.2.2 Combination ( Mixture of calls &amp; puts )"></a>10.2.2 Combination ( Mixture of calls &amp; puts )</h4><h5 id="10-2-2-1-A-Straddle（跨式）-Combination"><a href="#10-2-2-1-A-Straddle（跨式）-Combination" class="headerlink" title="10.2.2.1 A Straddle（跨式） Combination"></a>10.2.2.1 A Straddle（跨式） Combination</h5><blockquote><p>A straddle is appropriate when an investor is expecting a large move in a stock price but does not know in which direction the move will be</p></blockquote><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310192256536.jpg"></p><h5 id="10-2-2-2-Strip"><a href="#10-2-2-2-Strip" class="headerlink" title="10.2.2.2 Strip"></a>10.2.2.2 Strip</h5><blockquote><p>A strip consists of a long position in one call and two puts with the same strike price and expiration date</p></blockquote><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310192257945.jpg"></p><h5 id="10-2-2-3-A-Strangle-（勒式）Combination"><a href="#10-2-2-3-A-Strangle-（勒式）Combination" class="headerlink" title="10.2.2.3 A Strangle （勒式）Combination"></a>10.2.2.3 A Strangle （勒式）Combination</h5><blockquote><p>A strangle is a similar strategy to a straddle. The investor is betting that there will be a large price move, but is uncertain whether it will be an increase or a decrease</p></blockquote><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310192258605.jpg"></p><h2 id="第十二章：数值方法"><a href="#第十二章：数值方法" class="headerlink" title="第十二章：数值方法"></a>第十二章：数值方法</h2><h2 id="实验一：期权定价的蒙特卡洛模拟和有限差分方法"><a href="#实验一：期权定价的蒙特卡洛模拟和有限差分方法" class="headerlink" title="实验一：期权定价的蒙特卡洛模拟和有限差分方法"></a>实验一：期权定价的蒙特卡洛模拟和有限差分方法</h2>]]></content>
      
      
      <categories>
          
          <category> Course </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大三上 </tag>
            
            <tag> 金融衍生工具 </tag>
            
            <tag> Derivatives </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公司金融</title>
      <link href="/article/1b5aea18.html"/>
      <url>/article/1b5aea18.html</url>
      
        <content type="html"><![CDATA[<h2 id="Lecture1-第一章：公司目标和治理"><a href="#Lecture1-第一章：公司目标和治理" class="headerlink" title="Lecture1 第一章：公司目标和治理"></a>Lecture1 第一章：公司目标和治理</h2><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202308291710304.jpg"></p><p>brealey 公司金融机械工业出版社两册 tirole 公司金融理论参考</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202308291710167.jpg"></p><h3 id="1-1-公司财务管理的目标"><a href="#1-1-公司财务管理的目标" class="headerlink" title="1.1 公司财务管理的目标"></a>1.1 公司财务管理的目标</h3><blockquote><p>股东利益最大化</p></blockquote><h3 id="1-2-所有权与经营权的分离"><a href="#1-2-所有权与经营权的分离" class="headerlink" title="1.2 所有权与经营权的分离"></a>1.2 所有权与经营权的分离</h3><h4 id="1-2-1-企业的组织形式"><a href="#1-2-1-企业的组织形式" class="headerlink" title="1.2.1 企业的组织形式"></a>1.2.1 企业的组织形式</h4><ol><li>业主独资</li><li>合伙制 普通合伙和有限合伙 以上企业对债务人承担无限责任</li><li>公司 区别于其所有者的法人，股东承担有限责任 代理关系： 股东：持有股份，具有投票权和分红权，权利有限 经理：又有经营权&#x2F;控制权</li></ol><h4 id="1-2-2-公司的层级结构"><a href="#1-2-2-公司的层级结构" class="headerlink" title="1.2.2 公司的层级结构"></a>1.2.2 公司的层级结构</h4><ul><li>公司：股东持有股份而拥有企业<ul><li>个人投资者或机构投资者（养老基金、共同基金等）</li></ul></li><li>董事会：代表股东利益的高管</li></ul><blockquote><p>公司所有者把经营企业的责任委托给职业经理</p></blockquote><h4 id="1-2-3-所有权和经营权分离的好处"><a href="#1-2-3-所有权和经营权分离的好处" class="headerlink" title="1.2.3 所有权和经营权分离的好处"></a>1.2.3 所有权和经营权分离的好处</h4><ol><li>现代经济需要规模化生产</li><li>不确定的环境中，所有这需要分散化投资风险</li><li>所有者可以降低信息收集的成本</li><li>企业成为一个“持续经营（going concern）”的主体</li></ol><h4 id="1-2-4-董事会构成"><a href="#1-2-4-董事会构成" class="headerlink" title="1.2.4 董事会构成"></a>1.2.4 董事会构成</h4><ol><li>执行董事 董事长及其利益一致者，俗称“经理”</li><li>独立董事 或称外部董事（outside directors）</li></ol><h3 id="1-3-代理问题"><a href="#1-3-代理问题" class="headerlink" title="1.3 代理问题"></a>1.3 代理问题</h3><h4 id="1-3-1-所有者与管理层的利益冲突"><a href="#1-3-1-所有者与管理层的利益冲突" class="headerlink" title="1.3.1 所有者与管理层的利益冲突"></a>1.3.1 所有者与管理层的利益冲突</h4><p>代理关系：</p><ol><li>股东与经理</li><li>大股东与小股东</li><li>股东与债权人 代理问题：</li><li>经理不努力</li><li>建立庞大的帝国</li><li>建立自己的护城河</li><li>以权谋私</li></ol><h4 id="1-3-2-经理不努力"><a href="#1-3-2-经理不努力" class="headerlink" title="1.3.2 经理不努力"></a>1.3.2 经理不努力</h4><p>道德风险（moral hazard）的表现</p><ul><li>激励与业绩挂钩（萝卜+大棒）</li><li>监控：董事会&#x2F;资本市场</li></ul><h4 id="1-3-3-建立庞大的帝国"><a href="#1-3-3-建立庞大的帝国" class="headerlink" title="1.3.3 建立庞大的帝国"></a>1.3.3 建立庞大的帝国</h4><ul><li>由于等级年薪制度导致的做大而不做强</li><li>面子工程（pet project），从事很多不能给股东带来财富的项目</li></ul><h4 id="1-3-4-沟壕防护战略"><a href="#1-3-4-沟壕防护战略" class="headerlink" title="1.3.4 沟壕防护战略"></a>1.3.4 沟壕防护战略</h4><ul><li>选择自己最熟悉的领域，即使 NPV &#x3D; 0 甚至为负</li><li>在公司实行“毒丸计划”防止公司被并购</li><li>粉饰财报</li></ul><p>$$<br>MB &#x3D; \frac{Market Value}{Book Value}</p><p>$$</p><p>e.g.</p><ol><li>$\mathbb{X}$ ：Elon Musk 开除印度人团队</li><li>平安银行：内部的保险业务（放弃了核心竞争力）</li></ol><h4 id="1-3-5-为自己谋取私利"><a href="#1-3-5-为自己谋取私利" class="headerlink" title="1.3.5 为自己谋取私利"></a>1.3.5 为自己谋取私利</h4><ul><li>大量管理层为自己的谋私利： 在职消费（perks）：装修豪华的办公室、配豪车、奢侈度假</li><li>大股东和小股东的代理：公司的控制权在几个大股东手里，外部股东可能利益受损<ul><li>隧道挖掘（Tunneling）：资金占用和违规担保</li><li>关联交易：e.g. 上游股东控股下游企业高价收购原材料从中获利</li></ul></li></ul><blockquote><p>代理问题对融资难的问题的解释： 拒绝（terminate）融资–信贷配给</p></blockquote><h4 id="1-3-6-公司治理"><a href="#1-3-6-公司治理" class="headerlink" title="1.3.6 公司治理"></a>1.3.6 公司治理</h4><p>公司治理探讨：</p><ul><li>选出合格的高管</li><li>投资者怎样使高管回报他们</li></ul><p>公司治理的目的：</p><ul><li>建立合理的机制：激励和监控高管；内部治理，好的信息沟通和组织设计</li><li>信息披露：法律、政策、市场的良好运作</li></ul><h2 id="Lecture2-第二章：风险与资本成本"><a href="#Lecture2-第二章：风险与资本成本" class="headerlink" title="Lecture2 第二章：风险与资本成本"></a>Lecture2 第二章：风险与资本成本</h2><h3 id="2-1-NPV法则与资本的机会成本"><a href="#2-1-NPV法则与资本的机会成本" class="headerlink" title="2.1 NPV法则与资本的机会成本"></a>2.1 NPV法则与资本的机会成本</h3><p>$$<br>NPV &#x3D; \sum_{t &#x3D; 0}^{T} \frac{CF_t}{(1+r)^t} </p><p>$$</p><p>机会成本： 投资“相同风险”项目获得的预期回报率</p><blockquote><p>相同风险： 同行业的项目</p></blockquote><p>市场风险：$r_{MKT}+r_{IND}$或者 Fama-French 三因子模型反应的风险</p><h4 id="2-1-1-公司的一般性投资"><a href="#2-1-1-公司的一般性投资" class="headerlink" title="2.1.1 公司的一般性投资"></a>2.1.1 公司的一般性投资</h4><p>资本支出（Capital Expenditure）的对称为“收益支出”或者“成本支出”，指企业为了长期资产而发生的支出，或为了取得为一个以上会计期间提供效益的财产或劳务所发生的支出。 e.g. 600519 一般性投资</p><h3 id="2-2-资本成本的应用"><a href="#2-2-资本成本的应用" class="headerlink" title="2.2 资本成本的应用"></a>2.2 资本成本的应用</h3><h4 id="2-2-1-为什么要估计企业的资本成本"><a href="#2-2-1-为什么要估计企业的资本成本" class="headerlink" title="2.2.1 为什么要估计企业的资本成本"></a>2.2.1 为什么要估计企业的资本成本</h4><blockquote><p>公司的资本成本是指公司所有资产的预期收益率</p></blockquote><ul><li>大部分新投资的项目可能是现有资产的扩张或者升级</li><li>资本成本可为新投资项目风险程度的参考</li><li>可以为高管设立经营目标，考察其业绩</li></ul><h3 id="2-3-贝塔值测定与产业资本资本成本"><a href="#2-3-贝塔值测定与产业资本资本成本" class="headerlink" title="2.3 贝塔值测定与产业资本资本成本"></a>2.3 贝塔值测定与产业资本资本成本</h3><h4 id="2-3-1-CAPM-的两个假设"><a href="#2-3-1-CAPM-的两个假设" class="headerlink" title="2.3.1 CAPM 的两个假设"></a>2.3.1 CAPM 的两个假设</h4><ol><li>信息一致，即不存在信息不对称</li><li>行为一致，即所有人都是理性人选择最优决策 只存在系统风险</li></ol><h4 id="2-3-2-效用函数"><a href="#2-3-2-效用函数" class="headerlink" title="2.3.2 效用函数"></a>2.3.2 效用函数</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309121705580.jpg"></p><h4 id="2-3-3-CAPM-的理论推导"><a href="#2-3-3-CAPM-的理论推导" class="headerlink" title="2.3.3 CAPM 的理论推导"></a>2.3.3 CAPM 的理论推导</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309121706830.jpg"></p><h4 id="2-3-4-CAPM的实证分析"><a href="#2-3-4-CAPM的实证分析" class="headerlink" title="2.3.4 CAPM的实证分析"></a>2.3.4 CAPM的实证分析</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309121708811.jpg"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309121709919.jpg"></p><h4 id="2-3-5-收益率"><a href="#2-3-5-收益率" class="headerlink" title="2.3.5 收益率"></a>2.3.5 收益率</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309121711403.jpg"></p><p>$$r_{i,t} &#x3D; lnp_{i,t} - lnp_{i,t-1}$$</p><h4 id="2-3-6-风险分解"><a href="#2-3-6-风险分解" class="headerlink" title="2.3.6 风险分解"></a>2.3.6 风险分解</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309121712013.jpg"></p><h5 id="2-3-6-1-市场风险"><a href="#2-3-6-1-市场风险" class="headerlink" title="2.3.6.1 市场风险"></a>2.3.6.1 市场风险</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309121717461.jpg"></p><p>股指不能完全反应市场的 portfolio</p><p>if Size is small or B&#x2F;M is big then maybe bankrupt</p><h5 id="2-3-6-2-折现率的确定"><a href="#2-3-6-2-折现率的确定" class="headerlink" title="2.3.6.2 折现率的确定"></a>2.3.6.2 折现率的确定</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309121718955.jpg"></p><p><strong>关于折现率</strong> </p><p>不能因个别风险大而调整折现率，应该调整 CF</p><h5 id="2-3-6-3-市场风险的表征"><a href="#2-3-6-3-市场风险的表征" class="headerlink" title="2.3.6.3 市场风险的表征"></a>2.3.6.3 市场风险的表征</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309121724081.jpg"></p><h3 id="2-4-Fama-French三因子模型"><a href="#2-4-Fama-French三因子模型" class="headerlink" title="2.4 Fama-French三因子模型"></a>2.4 Fama-French三因子模型</h3><h4 id="2-4-1-Fama-MacBeth二步法"><a href="#2-4-1-Fama-MacBeth二步法" class="headerlink" title="2.4.1 Fama-MacBeth二步法"></a>2.4.1 Fama-MacBeth二步法</h4><blockquote><p>Fama-MacBeth二步法是一种经济学和金融学中常用的统计方法，用于估计资产定价模型中的参数。该方法是由经济学家Eugene Fama和James MacBeth在1973年提出的。</p></blockquote><p>Fama-MacBeth二步法的主要目标是估计资产定价模型中的截距项和各个解释变量的系数。以下是该方法的步骤：</p><p>第一步：截面回归（Cross-sectional regression） 在每一个时间点上，将解释变量（例如股票收益率）与一个或多个解释变量（例如市场收益率）进行截面回归。对于每个时间点，得到解释变量的系数估计值。</p><p>第二步：时间序列回归（Time-series regression） 在第一步的结果基础上，将第一步中得到的系数估计值作为因变量，将时间作为自变量进行时间序列回归。这样可以得到解释变量系数的平均值，并计算其标准误差。</p><p>Fama-MacBeth二步法的估计结果可以用于判断解释变量对因变量的影响以及其统计显著性。如果系数估计值显著不为零，那么可以认为解释变量对因变量有统计显著的影响。</p><p>下面是Fama-MacBeth二步法的数学公式：</p><p>第一步（截面回归）：</p><p>$$R_{it} &#x3D; \alpha_i + \beta_1 X_{1it} + \beta_2 X_{2it} + … + \beta_k X_{kit} + \epsilon_{it}$$</p><p>其中，$R_{it}$表示在时间点$t$的因变量（例如股票收益率），$X_{jit}$表示在时间点$t$的第$j$个解释变量（例如市场收益率），$\alpha_i$表示个体$i$的截距项，$\beta_j$表示解释变量$j$的系数，$\epsilon_{it}$表示误差项。</p><p>第二步（时间序列回归）：</p><p>$$\beta_j &#x3D; \gamma_0 + \gamma_1 \bar{\beta}_j + \eta_j$$</p><p>其中，$\beta_j$表示第一步中解释变量$j$的系数估计值，$\gamma_0$表示截距项，$\gamma_1$表示$\bar{\beta}_j$的系数，$\eta_j$表示误差项。</p><p>Fama-MacBeth二步法的优点是可以同时考虑横截面和时间序列的信息，并能够提供对参数估计的统计推断。</p><h4 id="2-4-2-数据匹配"><a href="#2-4-2-数据匹配" class="headerlink" title="2.4.2 数据匹配"></a>2.4.2 数据匹配</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309121720854.jpg"></p><ol><li>$\beta$ rolling 200&#x2F;196个交易日</li><li>size 市值</li><li>BM</li></ol><h2 id="Lecture3-第三章：项目分析"><a href="#Lecture3-第三章：项目分析" class="headerlink" title="Lecture3 第三章：项目分析"></a>Lecture3 第三章：项目分析</h2><p>ch 10&#x2F;11</p><h3 id="3-1-项目的敏感性分析和盈亏平衡分析"><a href="#3-1-项目的敏感性分析和盈亏平衡分析" class="headerlink" title="3.1 项目的敏感性分析和盈亏平衡分析"></a>3.1 项目的敏感性分析和盈亏平衡分析</h3><h4 id="敏感性分析"><a href="#敏感性分析" class="headerlink" title="敏感性分析"></a>敏感性分析</h4><ol><li>蒙特卡罗模拟<br>$$NPV &#x3D; （收入 - 成本 -折旧）\times （1-Tax \ Rate）+ 折旧$$</li></ol><h3 id="3-2-项目的价值来源"><a href="#3-2-项目的价值来源" class="headerlink" title="3.2 项目的价值来源"></a>3.2 项目的价值来源</h3><h2 id="Lecture4-第四章：实物期权-Real-Option"><a href="#Lecture4-第四章：实物期权-Real-Option" class="headerlink" title="Lecture4 第四章：实物期权 Real Option"></a>Lecture4 第四章：实物期权 Real Option</h2><h3 id="4-1-风险中性定价"><a href="#4-1-风险中性定价" class="headerlink" title="4.1 风险中性定价"></a>4.1 风险中性定价</h3><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309271719721.jpg"></p><h4 id="4-1-1-构造无风险投资组合（债券）"><a href="#4-1-1-构造无风险投资组合（债券）" class="headerlink" title="4.1.1 构造无风险投资组合（债券）"></a>4.1.1 构造无风险投资组合（债券）</h4><blockquote><p>买入$\Delta$份股票，卖空一份 Call，终端价值</p></blockquote><p>if $S_0u$ then: $\Delta S_0u - f_u &#x3D; 22\Delta - 1$</p><p>if $S_0d$ then: $\Delta S_0d - f_d &#x3D; 18\Delta$</p><p>无风险要求：<br>$$22\Delta - 1 &#x3D; 18\Delta \to \Delta &#x3D; 0.25$$</p><blockquote><p>因此复制的债券： 购买 0.25份股票，卖空一份 Call.</p></blockquote><h4 id="4-1-2-一般化"><a href="#4-1-2-一般化" class="headerlink" title="4.1.2 一般化"></a>4.1.2 一般化</h4><p>$$\Delta S_0u - f_u &#x3D; \Delta S_0d - f_d \to \Delta &#x3D; \frac{f_u - f_d}{S_0u - S_0d}$$</p><p>组合的现值为：<br>$$S_0\Delta -f &#x3D; (S_0u\Delta - f_u)e^{-rT}$$</p><p>代入$\Delta$，求 f<br>$$f &#x3D; e^{-rT}[pf_u + (1-p)f_d]$$<br>其中$p &#x3D; \frac{e^{rT}-d}{u-d}$</p><p>因此<br>$$E(S_T) &#x3D; pS_0u + (1-p)S_0d$$<br>$$E(S_T) &#x3D; S_0e^{rT}$$</p><p>这是期货中的成交日现货价格</p><p>实际上<br>$$E(S_T) &#x3D; S_0[1+r+\beta(E(r_M) -r)]$$</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309271730214.jpg" alt="二叉树模型"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309271734445.jpg" alt="Black-Scholes"></p><h3 id="4-2-实物期权的概念"><a href="#4-2-实物期权的概念" class="headerlink" title="4.2 实物期权的概念"></a>4.2 实物期权的概念</h3><blockquote><p>投资的灵活性</p></blockquote><h4 id="4-2-1-以Timing-Option-类比-Call"><a href="#4-2-1-以Timing-Option-类比-Call" class="headerlink" title="4.2.1 以Timing Option 类比 Call"></a>4.2.1 以Timing Option 类比 Call</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202309271736252.jpg"></p><h4 id="4-2-2-择时期权（Timing-Option）"><a href="#4-2-2-择时期权（Timing-Option）" class="headerlink" title="4.2.2 择时期权（Timing Option）"></a>4.2.2 择时期权（Timing Option）</h4><blockquote><p>企业的投资机会类似企业拥有的一个权利，在未来以一定价格获得或（出售）一项实物资产或投资计划</p></blockquote><h3 id="4-3-放弃期权、增长期权等各类型期权"><a href="#4-3-放弃期权、增长期权等各类型期权" class="headerlink" title="4.3 放弃期权、增长期权等各类型期权"></a>4.3 放弃期权、增长期权等各类型期权</h3><h4 id="4-3-1-放弃期权"><a href="#4-3-1-放弃期权" class="headerlink" title="4.3.1 放弃期权"></a>4.3.1 放弃期权</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310152312853.jpg"></p><h4 id="4-3-2-扩张期权"><a href="#4-3-2-扩张期权" class="headerlink" title="4.3.2 扩张期权"></a>4.3.2 扩张期权</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310152313582.jpg"></p><p>$$与投资相关 \to 投资新项目 \to 创新（低\beta）$$</p><p>个别风险大、系统风险小</p><p>$NPV\uparrow \to Size \uparrow \to BM \downarrow$</p><blockquote><p>投资收益率 ri 下降</p></blockquote><h2 id="第五章：代理问题、代理人薪酬与业绩评估"><a href="#第五章：代理问题、代理人薪酬与业绩评估" class="headerlink" title="第五章：代理问题、代理人薪酬与业绩评估"></a>第五章：代理问题、代理人薪酬与业绩评估</h2><h3 id="代理问题与业绩测度"><a href="#代理问题与业绩测度" class="headerlink" title="代理问题与业绩测度"></a>代理问题与业绩测度</h3><h3 id="激励和股票期权的设计"><a href="#激励和股票期权的设计" class="headerlink" title="激励和股票期权的设计"></a>激励和股票期权的设计</h3><h3 id="公司监控"><a href="#公司监控" class="headerlink" title="公司监控"></a>公司监控</h3><h2 id="Lecture-6-第六章：有效市场与非对称信息下的融资理论"><a href="#Lecture-6-第六章：有效市场与非对称信息下的融资理论" class="headerlink" title="Lecture 6 第六章：有效市场与非对称信息下的融资理论"></a>Lecture 6 第六章：有效市场与非对称信息下的融资理论</h2><h3 id="6-1-有效市场的几种形式及其检测方法"><a href="#6-1-有效市场的几种形式及其检测方法" class="headerlink" title="6.1 有效市场的几种形式及其检测方法"></a>6.1 有效市场的几种形式及其检测方法</h3><ul><li>弱式有效(Weak form efficiency)<ul><li>市场价格反应了所有历史的价格信息</li><li>价格符合随机游走模型<ul><li>测试股票的超额收益，测试定价模型和异象（anomalies）</li></ul></li></ul></li><li>半强式有效(Semi-strong form efficiency)<ul><li>市场价格反应了所有公开可获得的信息</li><li>价格会对公开信息进行立即调整<ul><li>测度异常收益率<br>$$AR_{it} &#x3D; r_{it} - E&lt;r_{it}|\Theta_t&gt;$$</li></ul></li></ul></li></ul><p>Expected return &#x3D; $\alpha + \beta \times$return on market index<br>$$AR_{it} &#x3D; R_{it} - \hat{\alpha_i} - \hat{\beta_i} R_{m\tau}$$</p><ul><li>强式有效(Strong form efficiency)<ul><li>价格反应了所有的信息，包括公开的和私人的信息</li><li>没有人可以从中套利，只有幸运的投资者和不幸运的投资者</li></ul></li></ul><h3 id="6-2-异象及其经济解释"><a href="#6-2-异象及其经济解释" class="headerlink" title="6.2 异象及其经济解释"></a>6.2 异象及其经济解释</h3><h4 id="6-2-1-随机游走假设-Random-walk-hypothesis"><a href="#6-2-1-随机游走假设-Random-walk-hypothesis" class="headerlink" title="6.2.1 随机游走假设(Random walk hypothesis)"></a>6.2.1 随机游走假设(Random walk hypothesis)</h4><blockquote><p>股票价格不符合任何模式</p></blockquote><p>对一只股票明天价格的最佳预测，等于今天的价格加上一个纯粹的随机对冲<br>$$r_t &#x3D; r_{t-1} + \epsilon_t$$</p><h4 id="6-2-2-平稳随机过程"><a href="#6-2-2-平稳随机过程" class="headerlink" title="6.2.2 平稳随机过程"></a>6.2.2 平稳随机过程</h4><blockquote><p>均值和方差在所有时间上恒为常数</p><p>自相关系数只与时间间隔有关，对所有的时间 t 以及滞后 s</p></blockquote><p>$$\gamma_{t,t-s} &#x3D; cov(r_t, r_{t-s}) &#x3D; cov(r_0, r_{|0-s|}) &#x3D;\gamma_{0,s}$$</p><p>where $r_t &#x3D; \rho r_{t-1} + \epsilon_t$ and $|\rho| &lt; 1$</p><h3 id="6-3-道德风险融资模型"><a href="#6-3-道德风险融资模型" class="headerlink" title="6.3 道德风险融资模型"></a>6.3 道德风险融资模型</h3><h3 id="6-4-逆向选择融资模型"><a href="#6-4-逆向选择融资模型" class="headerlink" title="6.4 逆向选择融资模型"></a>6.4 逆向选择融资模型</h3><h2 id="第七章：公司如何发行证券"><a href="#第七章：公司如何发行证券" class="headerlink" title="第七章：公司如何发行证券"></a>第七章：公司如何发行证券</h2><h3 id="风险投资与风险投资合约"><a href="#风险投资与风险投资合约" class="headerlink" title="风险投资与风险投资合约"></a>风险投资与风险投资合约</h3><h3 id="首次公开发行的程序"><a href="#首次公开发行的程序" class="headerlink" title="首次公开发行的程序"></a>首次公开发行的程序</h3><h3 id="上市公司的证券发售成本研究"><a href="#上市公司的证券发售成本研究" class="headerlink" title="上市公司的证券发售成本研究"></a>上市公司的证券发售成本研究</h3><h2 id="第八章：股利策略"><a href="#第八章：股利策略" class="headerlink" title="第八章：股利策略"></a>第八章：股利策略</h2><h3 id="股利策略及其现实中的信号含义：现金股利与股票回购"><a href="#股利策略及其现实中的信号含义：现金股利与股票回购" class="headerlink" title="股利策略及其现实中的信号含义：现金股利与股票回购"></a>股利策略及其现实中的信号含义：现金股利与股票回购</h3><h3 id="股利策略的MM定理解释"><a href="#股利策略的MM定理解释" class="headerlink" title="股利策略的MM定理解释"></a>股利策略的MM定理解释</h3><h3 id="股利策略研究的相关实证证据"><a href="#股利策略研究的相关实证证据" class="headerlink" title="股利策略研究的相关实证证据"></a>股利策略研究的相关实证证据</h3><h2 id="第九章：资本结构理论"><a href="#第九章：资本结构理论" class="headerlink" title="第九章：资本结构理论"></a>第九章：资本结构理论</h2><h3 id="MM定理"><a href="#MM定理" class="headerlink" title="MM定理"></a>MM定理</h3><h3 id="财务风险与期望收益"><a href="#财务风险与期望收益" class="headerlink" title="财务风险与期望收益"></a>财务风险与期望收益</h3><h3 id="无税加权资本成本"><a href="#无税加权资本成本" class="headerlink" title="无税加权资本成本"></a>无税加权资本成本</h3><h2 id="第十章：公司应该负债多少"><a href="#第十章：公司应该负债多少" class="headerlink" title="第十章：公司应该负债多少"></a>第十章：公司应该负债多少</h2><h3 id="公司税与个人税对资本结构的影响"><a href="#公司税与个人税对资本结构的影响" class="headerlink" title="公司税与个人税对资本结构的影响"></a>公司税与个人税对资本结构的影响</h3><h3 id="财务困境成本、资本结构的权衡理论"><a href="#财务困境成本、资本结构的权衡理论" class="headerlink" title="财务困境成本、资本结构的权衡理论"></a>财务困境成本、资本结构的权衡理论</h3><h3 id="资本结构的代理理论"><a href="#资本结构的代理理论" class="headerlink" title="资本结构的代理理论"></a>资本结构的代理理论</h3><h2 id="第十一章：融资与估值"><a href="#第十一章：融资与估值" class="headerlink" title="第十一章：融资与估值"></a>第十一章：融资与估值</h2><h3 id="税后加权平均资本成本"><a href="#税后加权平均资本成本" class="headerlink" title="税后加权平均资本成本"></a>税后加权平均资本成本</h3><h3 id="企业价值评估"><a href="#企业价值评估" class="headerlink" title="企业价值评估"></a>企业价值评估</h3><h3 id="WACC应用的要点"><a href="#WACC应用的要点" class="headerlink" title="WACC应用的要点"></a>WACC应用的要点</h3><h2 id="第十二章：短期负债与短期财务计划"><a href="#第十二章：短期负债与短期财务计划" class="headerlink" title="第十二章：短期负债与短期财务计划"></a>第十二章：短期负债与短期财务计划</h2><h3 id="公司现金管理与短期负债"><a href="#公司现金管理与短期负债" class="headerlink" title="公司现金管理与短期负债"></a>公司现金管理与短期负债</h3><h3 id="企业现金周转周期与融资"><a href="#企业现金周转周期与融资" class="headerlink" title="企业现金周转周期与融资"></a>企业现金周转周期与融资</h3><h3 id="短期融资计划"><a href="#短期融资计划" class="headerlink" title="短期融资计划"></a>短期融资计划</h3><h2 id="第十三章：兼并"><a href="#第十三章：兼并" class="headerlink" title="第十三章：兼并"></a>第十三章：兼并</h2><h3 id="兼并的动因"><a href="#兼并的动因" class="headerlink" title="兼并的动因"></a>兼并的动因</h3><h3 id="兼并的收益及成本估计"><a href="#兼并的收益及成本估计" class="headerlink" title="兼并的收益及成本估计"></a>兼并的收益及成本估计</h3><h3 id="兼并机制"><a href="#兼并机制" class="headerlink" title="兼并机制"></a>兼并机制</h3><h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h2><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202308291710890.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Course </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 公司金融 </tag>
            
            <tag> 大三上 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>International Finance</title>
      <link href="/article/bae2e029.html"/>
      <url>/article/bae2e029.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-第一章：课程概述"><a href="#1-第一章：课程概述" class="headerlink" title="1 第一章：课程概述"></a>1 第一章：课程概述</h2><p>Chapter1 Intro <img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202308291709721.jpg"></p><p>TextBook: 10th 国际经济学下册</p><h3 id="1-1-课程简介"><a href="#1-1-课程简介" class="headerlink" title="1.1 课程简介"></a>1.1 课程简介</h3><h3 id="1-2-封闭经济与开放经济"><a href="#1-2-封闭经济与开放经济" class="headerlink" title="1.2 封闭经济与开放经济"></a>1.2 封闭经济与开放经济</h3><p>open economics macroeconomic &#x3D; international finance</p><table><thead><tr><th></th><th>microeconomics</th><th>closed macroeconomics</th><th>open macroeconomics</th></tr></thead><tbody><tr><td>Price</td><td>individual goods</td><td>price level&#x2F;interest rate</td><td></td></tr><tr><td>Quantity</td><td>individual goods(goods &amp; services)</td><td></td><td></td></tr></tbody></table><p>$$Y &#x3D; C  + I + G + EX  - IM$$</p><p>where $EX - IM &#x3D; CA: current account$</p><p>$$Savings &#x3D; Investment + CA$$</p><h4 id="1-2-1-Four-Topics"><a href="#1-2-1-Four-Topics" class="headerlink" title="1.2.1 Four Topics"></a>1.2.1 Four Topics</h4><ol start="3"><li>Trade balance</li><li>money and price level</li></ol><h3 id="1-3-开放经济下的国民收入核算"><a href="#1-3-开放经济下的国民收入核算" class="headerlink" title="1.3 开放经济下的国民收入核算"></a>1.3 开放经济下的国民收入核算</h3><h4 id="1-3-1-NIA-amp-BOP"><a href="#1-3-1-NIA-amp-BOP" class="headerlink" title="1.3.1 NIA &amp; BOP"></a>1.3.1 NIA &amp; BOP</h4><ul><li>NIA : national income accounting</li><li>BOP: balance of payments accounting</li></ul><h4 id="1-3-2-Identity-amp-Equation"><a href="#1-3-2-Identity-amp-Equation" class="headerlink" title="1.3.2 Identity &amp; Equation"></a>1.3.2 Identity &amp; Equation</h4><p>$$Y &#x3D; C + I + G + CA(opt) $$</p><p>identity: unconditional holds equation: conditional holds</p><p>Y : GDP,GNP,NI etc when it comes to open economics:</p><p>$$Y &#x3D; GNP &#x3D; Gross\ National\ Production$$</p><ul><li>final production given a period</li><li>flow variance</li></ul><h5 id="1-3-2-1-Difference-between-GDP-GNP-NI"><a href="#1-3-2-1-Difference-between-GDP-GNP-NI" class="headerlink" title="1.3.2.1 Difference between GDP, GNP, NI"></a>1.3.2.1 Difference between GDP, GNP, NI</h5><p>GNP &#x3D; GDP + the value created by China’s factors of production in foreign countries – the value created by foreign counties’ factors of production in China</p><h4 id="1-3-3-Consumption"><a href="#1-3-3-Consumption" class="headerlink" title="1.3.3 Consumption"></a>1.3.3 Consumption</h4><ul><li>SOE: state of enterprises -&gt; private sector</li></ul><h4 id="1-3-4-Investment"><a href="#1-3-4-Investment" class="headerlink" title="1.3.4 Investment"></a>1.3.4 Investment</h4><ul><li>SOE</li></ul><blockquote><p>IMF predicts the economics growth rate based on investment.</p></blockquote><h4 id="1-3-5-Government-Purchase"><a href="#1-3-5-Government-Purchase" class="headerlink" title="1.3.5 Government Purchase"></a>1.3.5 Government Purchase</h4><ul><li>Transfer: -&gt; single direction</li><li>Exchange: &lt;-&gt; double directions Government Transfer counted into C not G. e.g. minimum living allowrance or poverty subsidies.</li></ul><h2 id="2-第二章：国际收支平衡"><a href="#2-第二章：国际收支平衡" class="headerlink" title="2 第二章：国际收支平衡"></a>2 第二章：国际收支平衡</h2><h3 id="2-1-记账原则"><a href="#2-1-记账原则" class="headerlink" title="2.1 记账原则"></a>2.1 记账原则</h3><h4 id="2-1-1-Current-Account-Balance"><a href="#2-1-1-Current-Account-Balance" class="headerlink" title="2.1.1 Current Account Balance"></a>2.1.1 Current Account Balance</h4><p>$$<br>Y &#x3D; C + I + G + CA</p><p>$$</p><ul><li>foreign indebtness</li><li>international trade (*)</li><li>savings</li></ul><h4 id="2-1-2-Current-accouting-CA-and-foreign-indebtness"><a href="#2-1-2-Current-accouting-CA-and-foreign-indebtness" class="headerlink" title="2.1.2 Current accouting(CA) and foreign indebtness"></a>2.1.2 Current accouting(CA) and foreign indebtness</h4><p>If CA &lt; 0 then</p><ul><li>net foreign debt $\uparrow$</li><li>net foreign wealth $\downarrow$</li></ul><blockquote><p>Cause CA is a <strong>Flow Variable</strong> and debt is a <strong>Stock Variable</strong>.</p></blockquote><h4 id="2-1-3-Current-account-and-Intemporal-trade"><a href="#2-1-3-Current-account-and-Intemporal-trade" class="headerlink" title="2.1.3 Current account and Intemporal trade"></a>2.1.3 Current account and Intemporal trade</h4><p>CA deficit: import present consumption and export future consumption.</p><h4 id="2-1-4-Current-account-and-Saving"><a href="#2-1-4-Current-account-and-Saving" class="headerlink" title="2.1.4 Current account and Saving"></a>2.1.4 Current account and Saving</h4><p>$$<br>Y &#x3D; C + I + G + CA </p><p>$$</p><p>$$<br>I + CA &#x3D; Y - C - G</p><p>$$</p><p>$$<br>S &#x3D; I + CA</p><p>$$</p><p>CA can be positive or negative.</p><ul><li>GBD: Government budget deficit $GBD &#x3D; G - T$</li></ul><p>If CA &lt; 0 and T - G &lt; 0</p><p>$$<br>Y &#x3D; C + I + G + CA \to S &#x3D; Y - C - G &#x3D; (Y-T-C) + (T-G) &#x3D; S_p + S_g &#x3D; S_p - GBD &#x3D; I + CA</p><p>$$</p><p>$$<br>CA &#x3D; S_p - GBD - I</p><p>$$</p><h3 id="2-2-国际收支平衡表分析"><a href="#2-2-国际收支平衡表分析" class="headerlink" title="2.2 国际收支平衡表分析"></a>2.2 国际收支平衡表分析</h3><h4 id="2-2-1-Balance-of-Payment-Account"><a href="#2-2-1-Balance-of-Payment-Account" class="headerlink" title="2.2.1 Balance of Payment Account"></a>2.2.1 Balance of Payment Account</h4><blockquote><p>BOP : </p><ol><li>Current Account</li><li>Capital Account</li><li>Fanancial Account<br>2 &amp; 3 are combined in China.</li></ol></blockquote><ol><li>Definition</li></ol><ul><li>KOM: Balance of Payment accounts is a detailed record of the composition of the current account balance and of the many transactions that finance it.</li><li>IMF: BOP is a statistical statement that summarizes economic transactions between residents and non- residents during a period.</li></ul><ol start="2"><li>Territorial enclares 领土飞地</li></ol><ul><li>Consulate &#x2F; Millitray Base</li></ul><h4 id="2-2-2-Resident"><a href="#2-2-2-Resident" class="headerlink" title="2.2.2 Resident"></a>2.2.2 Resident</h4><blockquote><p>Residents: Residents of a state refer to the institutional units that have the center of predominant economic interest within the economic territory of the state.</p></blockquote><ul><li>“gift” between consulate with resident is included transaction </li><li>the cross-border branches&#x2F; subsidiary are residents of ___(Country Located)</li><li>International Student are original resident (original coutry’s Import&gt; BOP)</li><li>International Organization excluded from any countries</li></ul><h4 id="2-2-3-Economic-Transaction"><a href="#2-2-3-Economic-Transaction" class="headerlink" title="2.2.3 Economic Transaction"></a>2.2.3 Economic Transaction</h4><ul><li>Exchange</li><li>Transfer $\to$ uniliteral transfer</li><li>Migration $\to$ impact residents</li><li>Transaction by Inferrence $\to$ all economic behaivors should be recorded</li><li>Reclassification of claims and debts</li></ul><p><strong>Double-entry accounting</strong></p><table><thead><tr><th>Debit(-)</th><th>Credit(+)</th></tr></thead><tbody><tr><td>an increase in assets $\uparrow$</td><td>assets$\downarrow$</td></tr><tr><td>decrease in liabilities$\downarrow$</td><td>liabilities $\uparrow$</td></tr><tr><td>import</td><td>export</td></tr></tbody></table><p><strong>Uniliteral Transfer</strong></p><p>debit: unilitral transfer -</p><p>credit: real stuff +<br><strong>Current Account</strong><br><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310151127052.jpg"></p><p><strong>Financial Account</strong><br><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310151128783.jpg"></p><ul><li>Assets(Assets Held Aboard)<ul><li>increase -</li></ul></li><li>Liability(Foreign Assets Held in Home Country)<ul><li>increase +</li></ul></li></ul><p><strong>Official Reserve</strong></p><blockquote><p>Official reserve is the total of a nation’s holdings of foreign currency reserves, gold reserves, special drawing rights, IMF reserve position and other reserve assets.</p></blockquote><ul><li>Gold Reserve</li><li>Special Drawing Right(SDR) 特别提款权<ul><li>Dollars</li><li>GBD</li><li>Japanese Yunn</li></ul></li><li>IMF Reserve Position<br><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310151129672.jpg"></li></ul><blockquote><p>Why a country needs hold official reserves?</p><p>Firstly, the official reserves a country holds should satisfy its need of trade.</p><p>Secondly, the official reserves a country holds should ensure that this country has certain capability to intervene in the foreign exchange market.</p><p>Thirdly, the official reserves a country holds needs to ensure that this country could import some critical goods or resources when this country is in times of crisis.</p><p> Fourthly, the country as a whole must have some debts and official reserves are something like collaterals.</p></blockquote><h3 id="2-3-国际收支不平衡原因和影响"><a href="#2-3-国际收支不平衡原因和影响" class="headerlink" title="2.3 国际收支不平衡原因和影响"></a>2.3 国际收支不平衡原因和影响</h3><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310151132472.jpg"></p><h4 id="2-3-1-Table-of-BOP"><a href="#2-3-1-Table-of-BOP" class="headerlink" title="2.3.1 Table of BOP"></a>2.3.1 Table of BOP</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202310151135001.jpg"></p><ul><li>Current Account</li><li>Capital &amp; Fanancial Account<ul><li>Non-reserve account(KA)</li><li>Official-reserve account(OR)</li></ul></li></ul><p>$$ CA + KA + OR \equiv 0$$</p><p>$”BOP” \equiv CA + KA \equiv -OR$</p><h3 id="2-4-总结-Summarization"><a href="#2-4-总结-Summarization" class="headerlink" title="2.4 总结 Summarization"></a>2.4 总结 Summarization</h3><ul><li>NIA</li><li>BOP</li><li>CA</li><li>E</li></ul><h4 id="2-4-1-CA"><a href="#2-4-1-CA" class="headerlink" title="2.4.1 CA"></a>2.4.1 CA</h4><ul><li>foreign indebtnees</li><li>intertemporal trade</li><li>unilateral transfer</li></ul><h4 id="2-4-2-BOP"><a href="#2-4-2-BOP" class="headerlink" title="2.4.2 BOP"></a>2.4.2 BOP</h4><ul><li>Residents<ul><li>economics territory</li><li>center of predominant economic interest</li></ul></li><li>Economic Transaction<ul><li>Exchange</li><li>Transfer</li><li>Migration</li><li>Inference</li><li>Reclassification</li></ul></li></ul><h4 id="2-4-3-Financial-Account"><a href="#2-4-3-Financial-Account" class="headerlink" title="2.4.3 Financial Account"></a>2.4.3 Financial Account</h4><ul><li>OR<ul><li>Forex</li><li>Gold</li><li>SDR</li><li>IMF reserve position</li></ul></li><li>Capital &amp; Financial Account<ul><li>KA </li><li>OR</li></ul></li></ul><p>$$CA + KA + OR \equiv 0$$</p><h4 id="2-4-4-Net-errors-amp-Omission-Statistic-Discrepaney-x2F-Statistic-errors"><a href="#2-4-4-Net-errors-amp-Omission-Statistic-Discrepaney-x2F-Statistic-errors" class="headerlink" title="2.4.4 Net errors &amp; Omission(Statistic Discrepaney&#x2F; Statistic errors)"></a>2.4.4 Net errors &amp; Omission(Statistic Discrepaney&#x2F; Statistic errors)</h4><ul><li>False Statement</li><li>Money Laundry</li><li>Capital Flight</li></ul><h2 id="3-第三章：汇率-Exchange-Rate"><a href="#3-第三章：汇率-Exchange-Rate" class="headerlink" title="3 第三章：汇率 Exchange Rate"></a>3 第三章：汇率 Exchange Rate</h2><h3 id="3-1-外汇市场和汇率基础-The-Foreign-Exchange-Market"><a href="#3-1-外汇市场和汇率基础-The-Foreign-Exchange-Market" class="headerlink" title="3.1 外汇市场和汇率基础 The Foreign Exchange Market"></a>3.1 外汇市场和汇率基础 The Foreign Exchange Market</h3><p>major participant:</p><ul><li>central bank </li><li>commercial bank </li><li>nonbank financial institude </li><li>corporation</li></ul><h3 id="3-2-购买力平价理论"><a href="#3-2-购买力平价理论" class="headerlink" title="3.2 购买力平价理论"></a>3.2 购买力平价理论</h3><h3 id="3-3-利率平价理论"><a href="#3-3-利率平价理论" class="headerlink" title="3.3 利率平价理论"></a>3.3 利率平价理论</h3><h3 id="3-4-汇率的黏性价格和弹性价格货币分析法"><a href="#3-4-汇率的黏性价格和弹性价格货币分析法" class="headerlink" title="3.4 汇率的黏性价格和弹性价格货币分析法"></a>3.4 汇率的黏性价格和弹性价格货币分析法</h3><h2 id="第四章：国际收支理论"><a href="#第四章：国际收支理论" class="headerlink" title="第四章：国际收支理论"></a>第四章：国际收支理论</h2><h3 id="乘数论"><a href="#乘数论" class="headerlink" title="乘数论"></a>乘数论</h3><h3 id="弹性论"><a href="#弹性论" class="headerlink" title="弹性论"></a>弹性论</h3><h3 id="吸收论"><a href="#吸收论" class="headerlink" title="吸收论"></a>吸收论</h3><h2 id="第五章：开放经济下短期宏观经济"><a href="#第五章：开放经济下短期宏观经济" class="headerlink" title="第五章：开放经济下短期宏观经济"></a>第五章：开放经济下短期宏观经济</h2><h3 id="DD-AA曲线"><a href="#DD-AA曲线" class="headerlink" title="DD-AA曲线"></a>DD-AA曲线</h3><h3 id="财政政策和货币政策变动"><a href="#财政政策和货币政策变动" class="headerlink" title="财政政策和货币政策变动"></a>财政政策和货币政策变动</h3><h3 id="货币三重困境"><a href="#货币三重困境" class="headerlink" title="货币三重困境"></a>货币三重困境</h3><h3 id="固定汇率和外汇干预"><a href="#固定汇率和外汇干预" class="headerlink" title="固定汇率和外汇干预"></a>固定汇率和外汇干预</h3>]]></content>
      
      
      <categories>
          
          <category> Course </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大三上 </tag>
            
            <tag> 国际金融 </tag>
            
            <tag> International Finance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/article/0.html"/>
      <url>/article/0.html</url>
      
        <content type="html"><![CDATA[<h2 id="lt-lt-lt-lt-lt-lt-lt-HEAD-source-x2F-posts-x2F-博客搭建避坑-md"><a href="#lt-lt-lt-lt-lt-lt-lt-HEAD-source-x2F-posts-x2F-博客搭建避坑-md" class="headerlink" title="&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:source&#x2F;_posts&#x2F;博客搭建避坑.md"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:source&#x2F;_posts&#x2F;博客搭建避坑.md</h2><h2 id="title-博客搭建避坑author-Shiymtop-truecover-truetoc-truemathjax-truesummary-‘Hexo框架下的个人博客搭建简略攻略-从安装到魔改-从入门到放弃-‘categories-技术分享tags-Hexo-博客-插件-软技能abbrlink-acd393ebdate-2022-12-22-14-21-06img-coverImg-password"><a href="#title-博客搭建避坑author-Shiymtop-truecover-truetoc-truemathjax-truesummary-‘Hexo框架下的个人博客搭建简略攻略-从安装到魔改-从入门到放弃-‘categories-技术分享tags-Hexo-博客-插件-软技能abbrlink-acd393ebdate-2022-12-22-14-21-06img-coverImg-password" class="headerlink" title="title: 博客搭建避坑author: Shiymtop: truecover: truetoc: truemathjax: truesummary: ‘Hexo框架下的个人博客搭建简略攻略,从安装到魔改,从入门到放弃(‘categories: 技术分享tags:  - Hexo  - 博客  - 插件  - 软技能abbrlink: acd393ebdate: 2022-12-22 14:21:06img:coverImg:password:"></a>title: 博客搭建避坑<br>author: Shiym<br>top: true<br>cover: true<br>toc: true<br>mathjax: true<br>summary: ‘Hexo框架下的个人博客搭建简略攻略,从安装到魔改,从入门到放弃(‘<br>categories: 技术分享<br>tags:<br>  - Hexo<br>  - 博客<br>  - 插件<br>  - 软技能<br>abbrlink: acd393eb<br>date: 2022-12-22 14:21:06<br>img:<br>coverImg:<br>password:</h2><h1 id="个人Blog的搭建避坑"><a href="#个人Blog的搭建避坑" class="headerlink" title="个人Blog的搭建避坑"></a>个人Blog的搭建避坑</h1><blockquote><p>因为晚上的攻略过于老旧, 版本的更新迭代速度如此之快,导致如今再跟着搭建颇为费力, 笔者便另起炉灶把需要注意的坑写下以警示后来人</p></blockquote><p><em><strong>这里想说一下为什么要写博客:</strong></em></p><p><a href="https://blog.csdn.net/weixin_44480968/article/details/123301138?spm=1001.2014.3001.5506">学生为什么要在CSDN写博客？</a></p><pre><code>虽然主体是学生,但是同样适用其他群体</code></pre><p><a href="https://blog.csdn.net/kelinfeng16/article/details/117886551?spm=1001.2014.3001.5506">程序员写博客的好处</a></p><pre><code>虽然主体是程序员,但是同样适用其他群体</code></pre><h2 id="必要环境"><a href="#必要环境" class="headerlink" title="必要环境"></a>必要环境</h2><ul><li><code>Git</code>的安装+<code>Node.js</code>的安装+<code>Hexo</code>的安装<ul><li>非常推荐看官网是怎么安装的,不需要看任何博客说明,官网足够了</li><li>如果硬是要看教程, 那么推荐这个大佬$\to$大佬[]</li></ul></li><li>个性化主题的推荐:<ul><li><code>metary</code>网址</li><li><code>nexT</code>网址</li></ul></li><li>个人技能:<ul><li>因为博客文章基于 <code>MarkDown</code>, 所以 <code>MarkDown</code>是一定一定要会的,语法简单,建议看官网文档学习</li><li><code>MarkDown</code>里面内嵌支持 <code>HTML</code>和 <code>LaTex</code>,所以有必要把后面两个的语法学习一下<ul><li><code>HTML</code>推荐看<a href="https://www.w3school.com.cn/w3c/w3c_intro.asp" title="很好用">W3C的官网教程</a></li><li><code>LaTex</code>应该在 <code>MarkDown</code>的官网文档里面有相应介绍</li></ul></li></ul></li></ul><p>安装完成之后, <code>hexo server</code>命令看看能不能打开<em>localhost:4000</em>看到博客内容</p><h2 id="整体框架介绍"><a href="#整体框架介绍" class="headerlink" title="整体框架介绍"></a>整体框架介绍</h2><blockquote><p>这一部分便是DIY的重点,把里面的logo,图片,文字描述改成自己需要的,还可以装上很多插件丰富博客功能</p><p>先对整体目录文件有一个了解,可以自己点开看看里面的内容</p></blockquote><h3 id="博客根目录下的-yml文件介绍"><a href="#博客根目录下的-yml文件介绍" class="headerlink" title="博客根目录下的 .yml文件介绍"></a>博客根目录下的 <code>.yml</code>文件介绍</h3><p>推荐看 <code>Hexo</code>官方的 <code>readme.md</code></p><p>如果硬是要看教程, 那么推荐这个大佬教程$\to$<a href="https://blog.17lai.site/posts/40300608/" title="真大佬">夜法之书</a></p><h3 id="主题目录下的-yml文件介绍"><a href="#主题目录下的-yml文件介绍" class="headerlink" title="主题目录下的 .yml文件介绍"></a>主题目录下的 <code>.yml</code>文件介绍</h3><p>推荐看主题下的 <code>readme.md</code>,非常详细,作者还是中国人,有中文文档</p><h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><h3 id="使用命令生成新文章"><a href="#使用命令生成新文章" class="headerlink" title="使用命令生成新文章"></a>使用命令生成新文章</h3><p>博客内容是统一放在 <code>/source/_post</code>文件目录下面,我们使用 <code>hexo new post &quot;博客标题&quot;</code>这个 <code>hexo cli</code>命令便可以在下面生成一份 <code>.md</code>文件</p><p><code>Hexo</code>里面自带一份<em>hello world</em>, 可以看看里面的构成要素:</p><p><del>此处应有一份[图片],但是笔者懒,于是作罢</del></p><h3 id="front-matter说明"><a href="#front-matter说明" class="headerlink" title="front matter说明"></a><code>front matter</code>说明</h3><p>关于 <code>front matter</code>的介绍: 无论是 <code>Hexo</code>还是 <code>matery</code>的 <code>readme</code>都有详细说明,不再赘述</p><h3 id="图片的引用"><a href="#图片的引用" class="headerlink" title="图片的引用"></a>图片的引用</h3><p>有个大坑, 建议学习别人的经验, 把图片放到图床上, 官方也从来没有修过这个问题, 本地图片的引用只能按照规定格式来, 具体原理是 <code>hexo</code>将 <code>markdown</code>生成 <code>html</code>静态网页时会按照固定 <code>url</code>引入,所以一切都要按照官网来.</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h3><p>本地部署官网应该有介绍, 非常详细, 不再赘述</p><p>一共也就那三个命令:</p><p><code>hexo cl &amp;&amp; hexo g &amp;&amp; hexo s</code></p><h3 id="部署到GitHub"><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h3><blockquote><p>为什么要部署到GitHub上?</p><p>这样别人就可以通过 <code>github.账号名称.io</code>这个网址进行访问你的博客了, 要不然文件都在本地, 别人怎么看得到你的文章呢(搞云服务器内网穿透的别杠)</p><p>我的博客就可以通过这个访问 <a href="https://github.skddj.io/" title="SShiym&#39;s blog">https://github.skddj.io</a></p></blockquote><p><code>GitHub</code>本身提供了 <code>GitHub Page</code>托管静态网站, 非常利于部署静态博客网站</p><p>此处官网也有详细介绍, 网上也有相关教程, 主要说一些需要注意的地方:</p><ul><li>仓库的命名,必须是:  <code>GitHub账号名称.io</code>  这样的格式</li><li><code>ssh</code>密钥生成,把公钥放到 <code>GitHub</code>上,网上说的很详细, 至于要提一嘴就是如果有人使用的 <code>Linux</code>系统, 碰巧又用了 <code>Clash</code>代理, 所有上网操作统一经过手动代理的端口,云端部署就会不断报错,Git日志显示拒绝, 那么就需要在 <code>.ssh</code>文件下的 <code>config</code>文件进行相应的配置了,具体操作可以看我这篇文章<a href>Ubuntu-git-ssh</a>(网上是没有相关教程的,大坑)</li><li><code>deploy</code>在 <code>yml</code>文件下的配置, 不赘述, <code>deploy</code>插件的安装, 不赘述</li></ul><p>然后就是经常用的操作:</p><p>本地 <code>hexo cl &amp;&amp; hexo g &amp;&amp; hexo s</code>调试看看有没有问题</p><p>没有问题就 <code> hexo cl &amp;&amp; hexo d -g</code> 部署到 <code>GitHub</code>上去</p><h3 id="多端部署"><a href="#多端部署" class="headerlink" title="多端部署"></a>多端部署</h3><blockquote><p>为什么要多端部署?</p><p>场景: 如果要换电脑写博客, 该怎么办?</p></blockquote><ul><li>可以把 <code>hexo</code>在的整个博客文件放到 <code>GitHub</code>上的私人仓库内,这样换电脑只需要把这个仓库 <code>clone</code>下来就可以继续写作了.当然,因为里面有各种密钥, 所以<strong>不要</strong>放到公共仓库上</li><li>有人说可以创建另外一个分支然后 <code>push</code>过去, 感觉没有放到另一个仓库方便, 其中的 <code>git</code>操作对小白也不友好,因此还是放到另外一个私人仓库方便</li></ul><h3 id="部署到Gitee上"><a href="#部署到Gitee上" class="headerlink" title="部署到Gitee上"></a>部署到Gitee上</h3><blockquote><p>为什么要部署到其他代码托管网站呢?<code>GitHub</code>不就够了吗?</p></blockquote><ul><li>因为众所周知的原因 访问 <code>GitHub</code>不但慢, 而且甚至上不去,所有要在国内的 <code>Gitee</code>上或者 <code>Coding</code>上部署一下<ul><li>(大坑,<code>coding</code>现在不支持 <code>page</code>托管,都转移到 <code>tecent serverless</code>上,腾讯收购 <code>coding</code>后把功能模块经常改动,现在已经没有 <code>page</code>托管)</li></ul></li></ul><p>需要实名认证,估计需要两天功夫, 建议提前注册准备</p><p>剩下的操作和 <code>Github</code>上的部署差不多, 唯一需要注意的就是需要实名认证, 可以提前先认证了</p><p>网上也有类似教程, 不赘述</p><h2 id="个性化使用"><a href="#个性化使用" class="headerlink" title="个性化使用"></a>个性化使用</h2><h3 id="域名的更改"><a href="#域名的更改" class="headerlink" title="域名的更改"></a>域名的更改</h3><p>教程: 直接看重点  <a href="https://juejin.cn/post/6844903937791770637">Hexo+github pages搭建个人独立网站，绑定域名全教程</a></p><p>阿里云的万网上购买,便宜的域名10年甚至只需要200块人民币不到</p><p>至于为什么不买国外的域名, 因为国内的能够也需要 <code>icp</code>备案,然后将域名解析到 <code>github.io那个域名</code>上,这样访问你的域名也起到了访问github域名的作用,网上教程很详细</p><p>而且可以联动前面的 <code>Gitee</code>部署,将国内的访问解析到 <code>Gitee page</code>,国外的访问解析到 <code>GitHub page</code>.</p><p>我的域名: <a href="shiym.top">shiym.top</a></p><h3 id="ICP备案"><a href="#ICP备案" class="headerlink" title="ICP备案"></a>ICP备案</h3><p>国内的 <code>icp</code>备案流程</p><h3 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h3><p>不赘述</p><h3 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h3><p>鲁迅说过: SEO做的好,引流跑不了</p><p>有个教程做的不错:<a href="https://juejin.cn/post/6844903477051654152">hexo高阶教程：教你怎么让你的hexo博客在搜索引擎中排第一</a></p><p>分别让 <code>Baidu</code>和 <code>Google</code>收录你的网站,让更多的人(爬虫)看到你的文章</p><p>其中的需要用到将你的永久链接中的中文变成拼音或者hash值的插件,方便搜索引擎的爬虫爬到你的文章</p><h3 id="RSS推送"><a href="#RSS推送" class="headerlink" title="RSS推送"></a>RSS推送</h3><p>用到了 <code>webpushr</code>这个插件, <a href="https://juejin.cn/post/6844904144008904717">有几个教程</a>, 当然官网也有教程</p><p>至于目的,别人的博客写的很清楚, 可以给你带来更多的流量, 这种推送目前信噪比还比较高</p><h3 id="Gulp压缩代码"><a href="#Gulp压缩代码" class="headerlink" title="Gulp压缩代码"></a>Gulp压缩代码</h3><p>你的文章中不论是 <code>css</code>还是 <code>js</code>充满了大量的空格,浪费了空间,线上资源比较宝贵,采用 <code>gulp</code>压缩代码可以节省流量</p><p>据说 <code>GitHub Page</code>每个月流量限定为100g,当然一般人也用不到这么多</p><p>文章还是这个: <a href="https://juejin.cn/post/6844903477051654152">hexo高阶教程：教你怎么让你的hexo博客在搜索引擎中排第一</a></p><h3 id="评论区插件"><a href="#评论区插件" class="headerlink" title="评论区插件"></a>评论区插件</h3><p>我用的是 <code>lean cloud</code>存储数据+<code>valine</code>无后端评论插件,<code>matery</code>主题的 <code>yml</code>文件注释里写的很清楚怎么操作</p><p>统一不推荐权限过高的 <code>Gitalk</code>和另外一个什么来着</p><p>评论可以使用 <code>coolpusher</code>推送提醒,网上教程较多,不赘述</p><h3 id="GitHub-CI-x2F-CD实现自动化部署"><a href="#GitHub-CI-x2F-CD实现自动化部署" class="headerlink" title="GitHub CI&#x2F;CD实现自动化部署"></a>GitHub CI&#x2F;CD实现自动化部署</h3><p><a href="https://juejin.cn/post/7122090400386383902">Github Action配合Hexo持续集成博客</a></p><h3 id="Docker环境部署"><a href="#Docker环境部署" class="headerlink" title="Docker环境部署"></a>Docker环境部署</h3><p>略,看<a href="https://blog.17lai.site/posts/40300608/">夜法之书</a>的教程即可</p><h3 id="加载动画修改"><a href="#加载动画修改" class="headerlink" title="加载动画修改"></a>加载动画修改</h3><p>参考博客:<a href="https://zhangxiaocai.cn/posts/7496029d.html">斯莫笔记</a></p><h3 id="在线聊天插件"><a href="#在线聊天插件" class="headerlink" title="在线聊天插件"></a>在线聊天插件</h3><p>使用的 <code>tidio</code>,教程看主题下的 <code>_config.yml</code>注释即可</p><h3 id="mindmap优化"><a href="#mindmap优化" class="headerlink" title="mindmap优化"></a>mindmap优化</h3><p>略</p><h2 id="软技能类"><a href="#软技能类" class="headerlink" title="软技能类"></a>软技能类</h2><h3 id="如何写出好博客-吸引更多的流量"><a href="#如何写出好博客-吸引更多的流量" class="headerlink" title="如何写出好博客?吸引更多的流量?"></a>如何写出好博客?吸引更多的流量?</h3><p><a href="https://juejin.cn/post/7137355267468951589">【产品推广宝典】程序员推广产品的13个要点</a></p><h3 id="博客插图推荐下载网站"><a href="#博客插图推荐下载网站" class="headerlink" title="博客插图推荐下载网站"></a>博客插图推荐下载网站</h3><h1 id="Unsplash"><a href="#Unsplash" class="headerlink" title="Unsplash"></a><a href="https://unsplash.com/" title="真乃神仙网站也 ">Unsplash</a></h1><hr><h2 id="title-博客搭建指北author-Shiymtop-falsecover-falsetoc-truemathjax-truesummary-‘Hexo框架下的个人博客搭建简略攻略-安装-gt-魔改’categories-Technologytags-Hexo-blog-plugin-softskillsabbrlink-acd393ebdate-2022-12-22-14-21-06img-coverImg-password"><a href="#title-博客搭建指北author-Shiymtop-falsecover-falsetoc-truemathjax-truesummary-‘Hexo框架下的个人博客搭建简略攻略-安装-gt-魔改’categories-Technologytags-Hexo-blog-plugin-softskillsabbrlink-acd393ebdate-2022-12-22-14-21-06img-coverImg-password" class="headerlink" title="title: 博客搭建指北author: Shiymtop:  falsecover: falsetoc: truemathjax: truesummary: ‘Hexo框架下的个人博客搭建简略攻略,安装-&gt;魔改’categories: Technologytags:  - Hexo  - blog  - plugin  - softskillsabbrlink: acd393ebdate: 2022-12-22 14:21:06img:coverImg:password:"></a>title: 博客搭建指北<br>author: Shiym<br>top:  false<br>cover: false<br>toc: true<br>mathjax: true<br>summary: ‘Hexo框架下的个人博客搭建简略攻略,安装-&gt;魔改’<br>categories: Technology<br>tags:<br>  - Hexo<br>  - blog<br>  - plugin<br>  - softskills<br>abbrlink: acd393eb<br>date: 2022-12-22 14:21:06<br>img:<br>coverImg:<br>password:</h2><h1 id="个人Blog的搭建避坑-1"><a href="#个人Blog的搭建避坑-1" class="headerlink" title="个人Blog的搭建避坑"></a>个人Blog的搭建避坑</h1><blockquote><p>因为网上的攻略过于老旧, 版本的更新迭代速度如此之快,导致如今再跟着搭建颇为费力, 笔者便另起炉灶把需要注意的坑写下以警示后来人</p></blockquote><p><em><strong>这里想说一下为什么要写博客:</strong></em></p><p><a href="https://blog.csdn.net/weixin_44480968/article/details/123301138?spm=1001.2014.3001.5506">学生为什么要在CSDN写博客？</a></p><pre><code>虽然主体是学生,但是同样适用其他群体</code></pre><p><a href="https://blog.csdn.net/kelinfeng16/article/details/117886551?spm=1001.2014.3001.5506">程序员写博客的好处</a></p><pre><code>虽然主体是程序员,但是同样适用其他群体</code></pre><h2 id="必要环境-1"><a href="#必要环境-1" class="headerlink" title="必要环境"></a>必要环境</h2><ul><li><code>Git</code>的安装+<code>Node.js</code>的安装+<code>Hexo</code>的安装<ul><li>非常推荐看官网是怎么安装的,不需要看任何博客说明,官网足够了</li><li>如果硬是要看教程, 那么推荐这个大佬$\to$大佬[]</li></ul></li><li>个性化主题的推荐:<ul><li><code>metary</code>网址</li><li><code>nexT</code>网址</li></ul></li><li>个人技能:<ul><li>因为博客文章基于 <code>MarkDown</code>, 所以 <code>MarkDown</code>是一定一定要会的,语法简单,建议看官网文档学习</li><li><code>MarkDown</code>里面内嵌支持 <code>HTML</code>和 <code>LaTex</code>,所以有必要把后面两个的语法学习一下<ul><li><code>HTML</code>推荐看<a href="https://www.w3school.com.cn/w3c/w3c_intro.asp" title="很好用">W3C的官网教程</a></li><li><code>LaTex</code>应该在 <code>MarkDown</code>的官网文档里面有相应介绍</li></ul></li></ul></li></ul><p>安装完成之后, <code>hexo server</code>命令看看能不能打开<em>localhost:4000</em>看到博客内容</p><h2 id="整体框架介绍-1"><a href="#整体框架介绍-1" class="headerlink" title="整体框架介绍"></a>整体框架介绍</h2><blockquote><p>这一部分便是DIY的重点,把里面的logo,图片,文字描述改成自己需要的,还可以装上很多插件丰富博客功能</p><p>先对整体目录文件有一个了解,可以自己点开看看里面的内容</p></blockquote><h3 id="博客根目录下的-yml文件介绍-1"><a href="#博客根目录下的-yml文件介绍-1" class="headerlink" title="博客根目录下的 .yml文件介绍"></a>博客根目录下的 <code>.yml</code>文件介绍</h3><p>推荐看 <code>Hexo</code>官方的 <code>readme.md</code></p><p>如果硬是要看教程, 那么推荐这个大佬教程$\to$<a href="https://blog.17lai.site/posts/40300608/" title="真大佬">夜法之书</a></p><h3 id="主题目录下的-yml文件介绍-1"><a href="#主题目录下的-yml文件介绍-1" class="headerlink" title="主题目录下的 .yml文件介绍"></a>主题目录下的 <code>.yml</code>文件介绍</h3><p>推荐看主题下的 <code>readme.md</code>,非常详细,作者还是中国人,有中文文档</p><h2 id="写博客-1"><a href="#写博客-1" class="headerlink" title="写博客"></a>写博客</h2><h3 id="使用命令生成新文章-1"><a href="#使用命令生成新文章-1" class="headerlink" title="使用命令生成新文章"></a>使用命令生成新文章</h3><p>博客内容是统一放在 <code>/source/_post</code>文件目录下面,我们使用 <code>hexo new post &quot;博客标题&quot;</code>这个 <code>hexo cli</code>命令便可以在下面生成一份 <code>.md</code>文件</p><p><code>Hexo</code>里面自带一份<em>hello world</em>, 可以看看里面的构成要素:</p><p><del>此处应有一份[图片],但是笔者懒,于是作罢</del></p><h3 id="front-matter说明-1"><a href="#front-matter说明-1" class="headerlink" title="front matter说明"></a><code>front matter</code>说明</h3><p>关于 <code>front matter</code>的介绍: 无论是 <code>Hexo</code>还是 <code>matery</code>的 <code>readme</code>都有详细说明,不再赘述</p><h3 id="图片的引用-1"><a href="#图片的引用-1" class="headerlink" title="图片的引用"></a>图片的引用</h3><p>有个大坑, 建议学习别人的经验, 把图片放到图床上, 官方也从来没有修过这个问题, 本地图片的引用只能按照规定格式来, 具体原理是 <code>hexo</code>将 <code>markdown</code>生成 <code>html</code>静态网页时会按照固定 <code>url</code>引入,所以一切都要按照官网来.</p><h2 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h2><h3 id="本地部署-1"><a href="#本地部署-1" class="headerlink" title="本地部署"></a>本地部署</h3><p>本地部署官网应该有介绍, 非常详细, 不再赘述</p><p>一共也就那三个命令:</p><p><code>hexo cl &amp;&amp; hexo g &amp;&amp; hexo s</code></p><h3 id="部署到GitHub-1"><a href="#部署到GitHub-1" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h3><blockquote><p>为什么要部署到GitHub上?</p><p>这样别人就可以通过 <code>github.账号名称.io</code>这个网址进行访问你的博客了, 要不然文件都在本地, 别人怎么看得到你的文章呢(搞云服务器内网穿透的别杠)</p><p>我的博客就可以通过这个访问 <a href="https://github.skddj.io/" title="SShiym&#39;s blog">https://github.skddj.io</a></p></blockquote><p><code>GitHub</code>本身提供了 <code>GitHub Page</code>托管静态网站, 非常利于部署静态博客网站</p><p>此处官网也有详细介绍, 网上也有相关教程, 主要说一些需要注意的地方:</p><ul><li>仓库的命名,必须是:  <code>GitHub账号名称.io</code>  这样的格式</li><li><code>ssh</code>密钥生成,把公钥放到 <code>GitHub</code>上,网上说的很详细, 至于要提一嘴就是如果有人使用的 <code>Linux</code>系统, 碰巧又用了 <code>Clash</code>代理, 所有上网操作统一经过手动代理的端口,云端部署就会不断报错,Git日志显示拒绝, 那么就需要在 <code>.ssh</code>文件下的 <code>config</code>文件进行相应的配置了,具体操作可以看我这篇文章<a href>Ubuntu-git-ssh</a>(网上是没有相关教程的,大坑)</li><li><code>deploy</code>在 <code>yml</code>文件下的配置, 不赘述, <code>deploy</code>插件的安装, 不赘述</li></ul><p>然后就是经常用的操作:</p><p>本地 <code>hexo cl &amp;&amp; hexo g &amp;&amp; hexo s</code>调试看看有没有问题</p><p>没有问题就 <code> hexo cl &amp;&amp; hexo d -g</code> 部署到 <code>GitHub</code>上去</p><h3 id="多端部署-1"><a href="#多端部署-1" class="headerlink" title="多端部署"></a>多端部署</h3><blockquote><p>为什么要多端部署?</p><p>场景: 如果要换电脑写博客, 该怎么办?</p></blockquote><ul><li>可以把 <code>hexo</code>在的整个博客文件放到 <code>GitHub</code>上的私人仓库内,这样换电脑只需要把这个仓库 <code>clone</code>下来就可以继续写作了.当然,因为里面有各种密钥, 所以<strong>不要</strong>放到公共仓库上</li><li>有人说可以创建另外一个分支然后 <code>push</code>过去, 感觉没有放到另一个仓库方便, 其中的 <code>git</code>操作对小白也不友好,因此还是放到另外一个私人仓库方便</li></ul><h3 id="部署到Gitee上-1"><a href="#部署到Gitee上-1" class="headerlink" title="部署到Gitee上"></a>部署到Gitee上</h3><blockquote><p>为什么要部署到其他代码托管网站呢?<code>GitHub</code>不就够了吗?</p></blockquote><ul><li>因为众所周知的原因, 有时候国内不使用科学上网的话, 访问 <code>GitHub</code>不但慢, 而且甚至上不去,所有要在国内的 <code>Gitee</code>上或者 <code>Coding</code>上部署一下<ul><li>(大坑,<code>coding</code>现在不支持 <code>page</code>托管,都转移到 <code>tecent serverless</code>上,腾讯收购 <code>coding</code>后把功能模块经常改动,现在已经没有 <code>page</code>托管)</li></ul></li></ul><p>需要实名认证,估计需要两天功夫, 建议提前注册准备</p><p>剩下的操作和 <code>Github</code>上的部署差不多, 唯一需要注意的就是需要实名认证, 可以提前先认证了</p><p>网上也有类似教程, 不赘述</p><h2 id="个性化使用-1"><a href="#个性化使用-1" class="headerlink" title="个性化使用"></a>个性化使用</h2><h3 id="域名的更改-1"><a href="#域名的更改-1" class="headerlink" title="域名的更改"></a>域名的更改</h3><p>教程: 直接看重点  <a href="https://juejin.cn/post/6844903937791770637">Hexo+github pages搭建个人独立网站，绑定域名全教程</a></p><p>阿里云的万网上购买,便宜的域名10年甚至只需要200块人民币不到</p><p>至于为什么不买国外的域名, 因为国内的能够也需要 <code>icp</code>备案,然后将域名解析到 <code>github.io那个域名</code>上,这样访问你的域名也起到了访问github域名的作用,网上教程很详细</p><p>而且可以联动前面的 <code>Gitee</code>部署,将国内的访问解析到 <code>Gitee page</code>,国外的访问解析到 <code>GitHub page</code>.</p><p>我的域名: <a href="shiym.top">shiym.top</a></p><h3 id="ICP备案-1"><a href="#ICP备案-1" class="headerlink" title="ICP备案"></a>ICP备案</h3><p>国内的 <code>icp</code>备案流程</p><h3 id="CDN加速-1"><a href="#CDN加速-1" class="headerlink" title="CDN加速"></a>CDN加速</h3><p>不赘述</p><h3 id="SEO优化-1"><a href="#SEO优化-1" class="headerlink" title="SEO优化"></a>SEO优化</h3><p>鲁迅说过: SEO做的好,引流跑不了</p><p>有个教程做的不错:<a href="https://juejin.cn/post/6844903477051654152">hexo高阶教程：教你怎么让你的hexo博客在搜索引擎中排第一</a></p><p>分别让 <code>Baidu</code>和 <code>Google</code>收录你的网站,让更多的人(爬虫)看到你的文章</p><p>其中的需要用到将你的永久链接中的中文变成拼音或者hash值的插件,方便搜索引擎的爬虫爬到你的文章</p><h3 id="RSS推送-1"><a href="#RSS推送-1" class="headerlink" title="RSS推送"></a>RSS推送</h3><p>用到了 <code>webpushr</code>这个插件, <a href="https://juejin.cn/post/6844904144008904717">有几个教程</a>, 当然官网也有教程</p><p>至于目的,别人的博客写的很清楚, 可以给你带来更多的流量, 这种推送目前信噪比还比较高</p><h3 id="Gulp压缩代码-1"><a href="#Gulp压缩代码-1" class="headerlink" title="Gulp压缩代码"></a>Gulp压缩代码</h3><p>你的文章中不论是 <code>css</code>还是 <code>js</code>充满了大量的空格,浪费了空间,线上资源比较宝贵,采用 <code>gulp</code>压缩代码可以节省流量</p><p>据说 <code>GitHub Page</code>每个月流量限定为100g,当然一般人也用不到这么多</p><p>文章还是这个: <a href="https://juejin.cn/post/6844903477051654152">hexo高阶教程：教你怎么让你的hexo博客在搜索引擎中排第一</a></p><h3 id="评论区插件-1"><a href="#评论区插件-1" class="headerlink" title="评论区插件"></a>评论区插件</h3><p>我用的是 <code>lean cloud</code>存储数据+<code>valine</code>无后端评论插件,<code>matery</code>主题的 <code>yml</code>文件注释里写的很清楚怎么操作</p><p>统一不推荐权限过高的 <code>Gitalk</code>和另外一个什么来着</p><p>评论可以使用 <code>coolpusher</code>推送提醒,网上教程较多,不赘述</p><h3 id="GitHub-CI-x2F-CD实现自动化部署-1"><a href="#GitHub-CI-x2F-CD实现自动化部署-1" class="headerlink" title="GitHub CI&#x2F;CD实现自动化部署"></a>GitHub CI&#x2F;CD实现自动化部署</h3><p><a href="https://juejin.cn/post/7122090400386383902">Github Action配合Hexo持续集成博客</a></p><h3 id="Docker环境部署-1"><a href="#Docker环境部署-1" class="headerlink" title="Docker环境部署"></a>Docker环境部署</h3><p>略,看<a href="https://blog.17lai.site/posts/40300608/">夜法之书</a>的教程即可</p><h3 id="加载动画修改-1"><a href="#加载动画修改-1" class="headerlink" title="加载动画修改"></a>加载动画修改</h3><p>参考博客:<a href="https://zhangxiaocai.cn/posts/7496029d.html">斯莫笔记</a></p><h3 id="在线聊天插件-1"><a href="#在线聊天插件-1" class="headerlink" title="在线聊天插件"></a>在线聊天插件</h3><p>使用的 <code>tidio</code>,教程看主题下的 <code>_config.yml</code>注释即可</p><h3 id="mindmap优化-1"><a href="#mindmap优化-1" class="headerlink" title="mindmap优化"></a>mindmap优化</h3><p>略</p><h2 id="软技能类-1"><a href="#软技能类-1" class="headerlink" title="软技能类"></a>软技能类</h2><h3 id="如何写出好博客-吸引更多的流量-1"><a href="#如何写出好博客-吸引更多的流量-1" class="headerlink" title="如何写出好博客?吸引更多的流量?"></a>如何写出好博客?吸引更多的流量?</h3><p><a href="https://juejin.cn/post/7137355267468951589">【产品推广宝典】程序员推广产品的13个要点</a></p><h3 id="博客插图推荐下载网站-1"><a href="#博客插图推荐下载网站-1" class="headerlink" title="博客插图推荐下载网站"></a>博客插图推荐下载网站</h3><p><a href="https://unsplash.com/" title="真乃神仙网站也 ">Unsplash</a></p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>fb72dae14cd9e0db202a1bf72852d247dcc943c9:source&#x2F;_posts&#x2F;技术&#x2F;soft skill&#x2F;博客搭建避坑.md</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络课程实验：手动访问 404 网站</title>
      <link href="/article/3af5c2d7.html"/>
      <url>/article/3af5c2d7.html</url>
      
        <content type="html"><![CDATA[<h1 id="免责声明："><a href="#免责声明：" class="headerlink" title="免责声明："></a>免责声明：</h1><p>本文旨在阐述计算机网络相关知识，不鼓励或支持任何非法行为，包括绕过政府或组织实施的互联网审查或其他限制。文章内容仅供信息和<strong>娱乐</strong>目的，不应用作任何实际或法律决策的参考。作者不承担任何使用本文所述信息而产生的责任或法律风险，也不为绕过互联网审查提供任何特定方法或软件的使用背书。本文内容与实际计算机网络课程或学术研究无关。如果因使用本文内容而产生任何问题，作者不承担任何责任。</p><blockquote><p>虚假的计算机网络课程实验：基于Wireshark的数据包捕获和分析<br>真实的计算机网络课程实验：手动访问 404 网站</p></blockquote><h2 id="一、域名注册购买"><a href="#一、域名注册购买" class="headerlink" title="一、域名注册购买"></a>一、域名注册购买</h2><p>Namesilo购买，<code>.top</code>,<code>.xyz</code>域名一般最便宜</p><h2 id="二、CDN-域名托管"><a href="#二、CDN-域名托管" class="headerlink" title="二、CDN+域名托管"></a>二、CDN+域名托管</h2><p>将域名托管到 CloudFlare</p><h2 id="三、VPS-购买"><a href="#三、VPS-购买" class="headerlink" title="三、VPS 购买"></a>三、VPS 购买</h2><p>优先选择免费更换 IP 的厂商如搬瓦工</p><p>图便宜选择 hostEons 购买0.5core 256M VPS, 16$&#x2F;year </p><h2 id="四、域名解析"><a href="#四、域名解析" class="headerlink" title="四、域名解析"></a>四、域名解析</h2><p>选择 A 指向，将 VPS 服务器 IP 指向已购买的域名，可以选择子域名</p><h2 id="五、VPS-连接"><a href="#五、VPS-连接" class="headerlink" title="五、VPS 连接"></a>五、VPS 连接</h2><p>使用一些 SSH 连接工具连接 VPS，确保 IP 在国内可以 PING 通</p><h2 id="六、X-UI-面板安装"><a href="#六、X-UI-面板安装" class="headerlink" title="六、X-UI 面板安装"></a>六、X-UI 面板安装</h2><p>调试 X-UI 管理</p><h2 id="七、申请-TLS-证书"><a href="#七、申请-TLS-证书" class="headerlink" title="七、申请 TLS 证书"></a>七、申请 TLS 证书</h2><p>使用 acme 一键申请 Let’s Encrypt的免费 TLS 证书</p><h2 id="八、节点部署"><a href="#八、节点部署" class="headerlink" title="八、节点部署"></a>八、节点部署</h2><p>在 X-UI 面板放置<code>.cer</code>,<code>.key</code>文件</p><h2 id="九、套用-CDN-加速"><a href="#九、套用-CDN-加速" class="headerlink" title="九、套用 CDN 加速"></a>九、套用 CDN 加速</h2><p>IP优选，确保带宽能跑满，理论上可以防止 IP 被封禁（opt)</p><h2 id="十、SpeedTest测试带宽能不能跑满"><a href="#十、SpeedTest测试带宽能不能跑满" class="headerlink" title="十、SpeedTest测试带宽能不能跑满"></a>十、SpeedTest测试带宽能不能跑满</h2><p>何同学唯一指定测速软件，5G 时代的里程碑</p><h2 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h2><p>图方便还是选择机场，图折腾请右拐软路由。</p>]]></content>
      
      
      <categories>
          
          <category> Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 科学上网 </tag>
            
            <tag> VPN </tag>
            
            <tag> Computer Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZCA白化 (Whitening)</title>
      <link href="/article/803a0aab.html"/>
      <url>/article/803a0aab.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是ZCA白化？"><a href="#什么是ZCA白化？" class="headerlink" title="什么是ZCA白化？"></a>什么是ZCA白化？</h2><p><strong>ZCA白化</strong> 是一种数据预处理技术，主要用于减少数据中的冗余信息和去除特征之间的相关性。这种方法通过线性变换将数据的协方差矩阵变为单位矩阵，同时尽可能保留原始数据的结构和可视信息。</p><h3 id="白化（Whitening）概述"><a href="#白化（Whitening）概述" class="headerlink" title="白化（Whitening）概述"></a>白化（Whitening）概述</h3><p>在机器学习和数据处理领域，“白化”指的是对数据进行变换，使其各个维度之间的协方差为零（即不相关），并且每个维度的方差为1。这样处理后的数据被称为“白化数据”。白化的主要目的是消除不同特征之间的相关性，简化后续模型的学习过程，加速收敛，提高模型性能。</p><h3 id="ZCA白化的定义"><a href="#ZCA白化的定义" class="headerlink" title="ZCA白化的定义"></a>ZCA白化的定义</h3><p><strong>ZCA白化</strong> 是白化方法的一种变体，全称为“零相位组件分析白化”（Zero-phase Component Analysis Whitening）。与其他白化方法（如PCA白化）不同，ZCA白化在白化的同时尽量保持数据的空间结构不变，使得白化后的数据在视觉上与原始数据尽可能相似。</p><h2 id="ZCA白化的工作原理"><a href="#ZCA白化的工作原理" class="headerlink" title="ZCA白化的工作原理"></a>ZCA白化的工作原理</h2><p>ZCA白化的过程通常包括以下几个步骤：</p><h3 id="1-数据中心化"><a href="#1-数据中心化" class="headerlink" title="1. 数据中心化"></a>1. 数据中心化</h3><p>首先，将数据进行中心化处理，即从每个样本中减去数据的均值，使得数据的均值为零。</p><p>$$X_{\text{centered}} &#x3D; X - \mu$$</p><p>其中，$X$ 是原始数据矩阵，(\mu) 是数据的均值向量。</p><h3 id="2-计算协方差矩阵"><a href="#2-计算协方差矩阵" class="headerlink" title="2. 计算协方差矩阵"></a>2. 计算协方差矩阵</h3><p>中心化后的数据用于计算协方差矩阵。协方差矩阵度量了不同特征之间的线性相关性。</p><p>$$\Sigma &#x3D; \frac{1}{n} X_{\text{centered}}^T X_{\text{centered}}$$</p><p>其中，$n$ 是样本数量。</p><h3 id="3-特征分解"><a href="#3-特征分解" class="headerlink" title="3. 特征分解"></a>3. 特征分解</h3><p>对协方差矩阵进行特征值分解或奇异值分解（SVD），得到特征值和特征向量。</p><p>$$\Sigma &#x3D; U \Lambda U^T$$</p><p>其中，$U$ 是特征向量矩阵，$\Lambda$ 是对角特征值矩阵。</p><h3 id="4-计算白化矩阵"><a href="#4-计算白化矩阵" class="headerlink" title="4. 计算白化矩阵"></a>4. 计算白化矩阵</h3><p>利用特征值和特征向量构建白化矩阵。</p><p>$$W &#x3D; U \Lambda^{-\frac{1}{2}} U^T$$</p><h3 id="5-应用白化变换"><a href="#5-应用白化变换" class="headerlink" title="5. 应用白化变换"></a>5. 应用白化变换</h3><p>将白化矩阵应用到中心化后的数据上，得到白化后的数据。</p><p>$$X_{\text{whitened}} &#x3D; X_{\text{centered}} W$$</p><p>此时，$X_{\text{whitened}}$ 的协方差矩阵为单位矩阵：</p><p>$$\text{Cov}(X_{\text{whitened}}) &#x3D; W^T \Sigma W &#x3D; I$$</p><h3 id="6-ZCA逆变换保留结构"><a href="#6-ZCA逆变换保留结构" class="headerlink" title="6. ZCA逆变换保留结构"></a>6. ZCA逆变换保留结构</h3><p>与PCA白化不同，ZCA白化进一步调整白化矩阵，以确保白化后的图像尽可能保留原始图像的空间结构。这是通过将白化矩阵与原始数据的特征向量重新组合实现的。</p><h2 id="为什么使用ZCA白化？"><a href="#为什么使用ZCA白化？" class="headerlink" title="为什么使用ZCA白化？"></a>为什么使用ZCA白化？</h2><h3 id="1-减少冗余信息"><a href="#1-减少冗余信息" class="headerlink" title="1. 减少冗余信息"></a>1. <strong>减少冗余信息</strong></h3><p>通过去除特征之间的相关性，ZCA白化能够减少数据中的冗余信息。这有助于模型更高效地学习，有效降低计算复杂度。</p><h3 id="2-加速模型收敛"><a href="#2-加速模型收敛" class="headerlink" title="2. 加速模型收敛"></a>2. <strong>加速模型收敛</strong></h3><p>消除特征相关性使得梯度下降等优化算法能够更快地找到全局最优解，从而加快模型的训练速度。</p><h3 id="3-提高模型性能"><a href="#3-提高模型性能" class="headerlink" title="3. 提高模型性能"></a>3. <strong>提高模型性能</strong></h3><p>标准化的数据分布有助于提升模型的泛化能力，减少过拟合，提高在未见数据上的表现。</p><h3 id="4-保留图像结构"><a href="#4-保留图像结构" class="headerlink" title="4. 保留图像结构"></a>4. <strong>保留图像结构</strong></h3><p>相比于其他白化方法，ZCA白化在去除冗余信息的同时，尽可能保留了图像的空间结构和视觉特征，使得白化后的图像在视觉上与原始图像相似。这对于图像相关任务来说尤为重要，因为保持空间信息有助于模型更好地理解和分类图像内容。</p><h2 id="ZCA白化具体应用"><a href="#ZCA白化具体应用" class="headerlink" title="ZCA白化具体应用"></a>ZCA白化具体应用</h2><p>图像数据经过ZCA白化处理。具体来说：</p><ol><li><p><strong>数据预处理流程</strong>：</p><ul><li>数据加载后，首先进行中心化处理。</li><li>计算协方差矩阵并进行ZCA白化。</li><li>得到的白化数据将用于后续的模型训练。</li></ul></li><li><p><strong>实际效果</strong>：</p><ul><li><strong>加快训练速度</strong>：由于特征不再相关，优化算法如梯度下降能够更高效地迭代。</li><li><strong>提升模型性能</strong>：标准化的数据有助于模型更好地泛化，减少过拟合风险。</li><li><strong>视觉一致性</strong>：白化后的图像仍然保留了原始图像的大部分视觉特征，有助于模型在图像分类任务中更准确地学习到有意义的特征。</li></ul></li></ol><h2 id="如何在代码中实现ZCA白化"><a href="#如何在代码中实现ZCA白化" class="headerlink" title="如何在代码中实现ZCA白化"></a>如何在代码中实现ZCA白化</h2><p>以下是一个简单的Python示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>decomposition <span class="token keyword">import</span> PCA<span class="token keyword">def</span> <span class="token function">zca_whitening</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> eps<span class="token operator">=</span><span class="token number">1e-5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># X: 输入数据，形状为 (num_samples, num_features)</span>    <span class="token comment"># 步骤1: 计算均值并中心化</span>    X_mean <span class="token operator">=</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>X<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    X_centered <span class="token operator">=</span> X <span class="token operator">-</span> X_mean    <span class="token comment"># 步骤2: 计算协方差矩阵</span>    sigma <span class="token operator">=</span> np<span class="token punctuation">.</span>cov<span class="token punctuation">(</span>X_centered<span class="token punctuation">,</span> rowvar<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    <span class="token comment"># 步骤3: 特征分解</span>    U<span class="token punctuation">,</span> S<span class="token punctuation">,</span> _ <span class="token operator">=</span> np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>svd<span class="token punctuation">(</span>sigma<span class="token punctuation">)</span>    <span class="token comment"># 步骤4: 计算ZCA白化矩阵</span>    ZCA_matrix <span class="token operator">=</span> U @ np<span class="token punctuation">.</span>diag<span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">/</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>S <span class="token operator">+</span> eps<span class="token punctuation">)</span><span class="token punctuation">)</span> @ U<span class="token punctuation">.</span>T    <span class="token comment"># 步骤5: 应用白化矩阵</span>    X_whitened <span class="token operator">=</span> X_centered @ ZCA_matrix    <span class="token keyword">return</span> X_whitened<span class="token punctuation">,</span> ZCA_matrix<span class="token punctuation">,</span> X_mean<span class="token comment"># 示例用法</span><span class="token comment"># 假设您有一个形状为 (num_samples, height, width, channels) 的图像数据集</span><span class="token comment"># 需要先将图像数据展平为 (num_samples, height * width * channels)</span>num_samples<span class="token punctuation">,</span> height<span class="token punctuation">,</span> width<span class="token punctuation">,</span> channels <span class="token operator">=</span> X<span class="token punctuation">.</span>shapeX_flat <span class="token operator">=</span> X<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>num_samples<span class="token punctuation">,</span> height <span class="token operator">*</span> width <span class="token operator">*</span> channels<span class="token punctuation">)</span>X_whitened<span class="token punctuation">,</span> ZCA_matrix<span class="token punctuation">,</span> X_mean <span class="token operator">=</span> zca_whitening<span class="token punctuation">(</span>X_flat<span class="token punctuation">)</span><span class="token comment"># 将白化后的数据重新调整为原始形状</span>X_whitened <span class="token operator">=</span> X_whitened<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>num_samples<span class="token punctuation">,</span> height<span class="token punctuation">,</span> width<span class="token punctuation">,</span> channels<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><ol><li><p><strong>数据展平</strong>：为了进行白化处理，首先需要将多维的图像数据展平成二维数组，其中每一行代表一个样本，每一列代表一个特征（像素值）。</p></li><li><p><strong>中心化</strong>：减去每个特征的均值，使数据均值为零。</p></li><li><p><strong>协方差矩阵计算</strong>：计算特征之间的协方差，衡量特征间的线性相关性。</p></li><li><p><strong>特征分解</strong>：使用奇异值分解（SVD）对协方差矩阵进行分解，得到特征值和特征向量。</p></li><li><p><strong>构建ZCA矩阵</strong>：利用特征值和特征向量构建ZCA白化矩阵。加入一个很小的常数<code>eps</code>防止数值不稳定（如特征值为零）。</p></li><li><p><strong>应用白化变换</strong>：将ZCA矩阵应用到中心化后的数据上，得到白化后的数据。</p></li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><p><strong>计算开销</strong>：ZCA白化涉及矩阵分解，对于高维数据（如高分辨率图像）来说，计算开销较大。在处理大规模数据集时，可能需要考虑计算效率或使用增量算法。</p></li><li><p><strong>数值稳定性</strong>：在计算过程中添加一个小的常数<code>eps</code>（如1e-5）有助于避免除以零或数值不稳定的问题。</p></li><li><p><strong>数据还原</strong>：如果需要将白化后的数据还原到原始空间，可以保存均值向量和ZCA矩阵，以便在需要时进行逆变换。</p></li><li><p><strong>与其他预处理方法的结合</strong>：ZCA白化通常与其他预处理方法（如标准化或归一化）结合使用，以进一步提升数据质量和模型性能。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
            <tag> Data Augmentation </tag>
            
            <tag> Pre-Processing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Recap PyTorch Tensor &amp; Einops API</title>
      <link href="/article/10f3127e.html"/>
      <url>/article/10f3127e.html</url>
      
        <content type="html"><![CDATA[<p>在深度学习中，对 Tensor 的维度和形状变换是日常操作。本文简单介绍 PyTorch 的 Tensor 自带的 API（<code>view</code>, <code>reshape</code>, <code>unsqueeze</code>, <code>squeeze</code>）以及配合 <a href="https://github.com/arogozhnikov/einops">Einops</a> 库进行维度重排、维度聚合和重复操作（<code>rearrange</code>, <code>reduce</code>, <code>repeat</code>）。</p><h2 id="1-PyTorch-Tensor-操作"><a href="#1-PyTorch-Tensor-操作" class="headerlink" title="1. PyTorch Tensor 操作"></a>1. PyTorch Tensor 操作</h2><h3 id="1-1-view-改变形状"><a href="#1-1-view-改变形状" class="headerlink" title="1.1. view - 改变形状"></a>1.1. <code>view</code> - 改变形状</h3><p><code>view</code> 主要用于改变张量的形状，但要求新形状必须与原始形状元素数量一致。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token comment"># 创建一个 2x4 的张量</span>x <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token comment"># 改变形状为 4x2</span>x_viewed <span class="token operator">=</span> x<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x_viewed<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>  <span class="token comment"># torch.Size([4, 2])</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-reshape-灵活的形状变化"><a href="#1-2-reshape-灵活的形状变化" class="headerlink" title="1.2. reshape - 灵活的形状变化"></a>1.2. <code>reshape</code> - 灵活的形状变化</h3><p><code>reshape</code> 与 <code>view</code> 类似，但它更灵活，如果有必要会生成新的内存。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x_reshaped <span class="token operator">=</span> x<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x_reshaped<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>  <span class="token comment"># torch.Size([4, 2])</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-3-unsqueeze-添加一个维度"><a href="#1-3-unsqueeze-添加一个维度" class="headerlink" title="1.3. unsqueeze - 添加一个维度"></a>1.3. <code>unsqueeze</code> - 添加一个维度</h3><p><code>unsqueeze</code> 用于在指定位置上添加一个维度。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x_unsq <span class="token operator">=</span> x<span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 在维度1处加一个维度</span><span class="token keyword">print</span><span class="token punctuation">(</span>x_unsq<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>  <span class="token comment"># torch.Size([2, 1, 4])</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-4-squeeze-去除多余的维度"><a href="#1-4-squeeze-去除多余的维度" class="headerlink" title="1.4. squeeze - 去除多余的维度"></a>1.4. <code>squeeze</code> - 去除多余的维度</h3><p><code>squeeze</code> 用于移除尺寸为1的多余维度。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x_squeezed <span class="token operator">=</span> x_unsq<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 去掉维度1的单一维度</span><span class="token keyword">print</span><span class="token punctuation">(</span>x_squeezed<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>  <span class="token comment"># torch.Size([2, 4])</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-Einops-的操作"><a href="#2-Einops-的操作" class="headerlink" title="2. Einops 的操作"></a>2. Einops 的操作</h2><h3 id="2-1-rearrange-重排维度"><a href="#2-1-rearrange-重排维度" class="headerlink" title="2.1. rearrange - 重排维度"></a>2.1. <code>rearrange</code> - 重排维度</h3><p><code>rearrange</code> 允许根据给定的维度顺序重排张量。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> einops <span class="token keyword">import</span> rearrange<span class="token comment"># 假设我们有一个形状为 (batch, height, width, channels) 的张量</span>x <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment"># 将其转换为PyTorch的标准格式 (batch, channels, height, width)</span>x_rearranged <span class="token operator">=</span> rearrange<span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token string">'b h w c -> b c h w'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x_rearranged<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>  <span class="token comment"># torch.Size([10, 3, 64, 64])</span><span class="token comment"># 将batch和channel合并</span>x_combined <span class="token operator">=</span> rearrange<span class="token punctuation">(</span>x_rearranged<span class="token punctuation">,</span> <span class="token string">'b c h w -> (b c) h w'</span><span class="token punctuation">)</span><span class="token comment"># 重新分开</span>x_cut <span class="token operator">=</span> rearrange<span class="token punctuation">(</span>x_combined<span class="token punctuation">,</span> <span class="token string">'(b c) h w -> b c h w'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-reduce-跨维度聚合"><a href="#2-2-reduce-跨维度聚合" class="headerlink" title="2.2. reduce - 跨维度聚合"></a>2.2. <code>reduce</code> - 跨维度聚合</h3><p><code>reduce</code> 可用于在指定维度上进行聚合操作，比如平均、求和等。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> einops <span class="token keyword">import</span> <span class="token builtin">reduce</span><span class="token comment"># 假设我们有一个 5D 张量，形状为 (batch, time, height, width, channels)</span>x <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment"># 对 time 维度进行平均</span>x_reduced <span class="token operator">=</span> <span class="token builtin">reduce</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token string">'b t h w c -> b h w c'</span><span class="token punctuation">,</span> <span class="token string">'mean'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x_reduced<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>  <span class="token comment"># torch.Size([4, 32, 32, 3])</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-repeat-沿某维度重复"><a href="#2-3-repeat-沿某维度重复" class="headerlink" title="2.3. repeat - 沿某维度重复"></a>2.3. <code>repeat</code> - 沿某维度重复</h3><p><code>repeat</code> 用于沿某个维度按照指定倍数复制元素。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> einops <span class="token keyword">import</span> repeat<span class="token comment"># 假设我们有一个形状为 (batch, height, width) 的张量</span>x <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token comment"># 沿着 height 维度重复 2 次</span>x_repeated <span class="token operator">=</span> repeat<span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token string">'b h w -> b (h 2) w'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x_repeated<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>  <span class="token comment"># torch.Size([4, 64, 32])</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
            <tag> Tensor </tag>
            
            <tag> Einops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梯度范数与梯度裁剪的详细解释 Gradient Norm and Clipping</title>
      <link href="/article/3ff1f570.html"/>
      <url>/article/3ff1f570.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-梯度范数-Gradient-Norm"><a href="#1-梯度范数-Gradient-Norm" class="headerlink" title="1. 梯度范数 (Gradient Norm)"></a>1. 梯度范数 (Gradient Norm)</h2><p>在深度学习中,梯度是一个向量,表示损失函数相对于模型参数的偏导数。对于具有 n 个参数的模型,梯度可以表示为:</p><p>$$\nabla L &#x3D; (\frac{\partial L}{\partial w_1}, \frac{\partial L}{\partial w_2}, …, \frac{\partial L}{\partial w_n})$$</p><p>其中 L 是损失函数,w_i 是第 i 个模型参数。</p><p>梯度范数是梯度向量的长度,通常使用 L2 范数(欧几里得范数)计算:</p><p>$$|\nabla L|<em>2 &#x3D; \sqrt{\sum</em>{i&#x3D;1}^n (\frac{\partial L}{\partial w_i})^2}$$</p><h2 id="2-最大梯度范数-Maximum-Gradient-Norm"><a href="#2-最大梯度范数-Maximum-Gradient-Norm" class="headerlink" title="2. 最大梯度范数 (Maximum Gradient Norm)"></a>2. 最大梯度范数 (Maximum Gradient Norm)</h2><p>最大梯度范数是一个预设的阈值,用于限制梯度的大小。我们将其表示为 c。在训练过程中,如果梯度范数超过这个阈值,就会触发梯度裁剪。</p><h2 id="3-梯度裁剪-Gradient-Clipping"><a href="#3-梯度裁剪-Gradient-Clipping" class="headerlink" title="3. 梯度裁剪 (Gradient Clipping)"></a>3. 梯度裁剪 (Gradient Clipping)</h2><p>梯度裁剪的目的是防止梯度爆炸问题。当梯度范数超过最大梯度范数 c 时,我们按比例缩小梯度,使其范数等于 c。</p><p>裁剪后的梯度计算如下:</p><p>$$\nabla L_{clipped} &#x3D; \min(1, \frac{c}{|\nabla L|_2}) \cdot \nabla L$$</p><p>推导过程:</p><ol><li>如果 $|\nabla L|_2 \leq c$,则 $\frac{c}{|\nabla L|_2} \geq 1$,因此 $\min(1, \frac{c}{|\nabla L|_2}) &#x3D; 1$,梯度保持不变。</li><li>如果 $|\nabla L|_2 &gt; c$,则 $\frac{c}{|\nabla L|_2} &lt; 1$,梯度将被缩放。</li></ol><p>缩放后的梯度范数证明:</p><p>$$|\nabla L_{clipped}|_2 &#x3D; |\frac{c}{|\nabla L|_2} \cdot \nabla L|_2 &#x3D; \frac{c}{|\nabla L|_2} \cdot |\nabla L|_2 &#x3D; c$$</p><p>这证明了裁剪后的梯度范数确实等于预设的最大梯度范数 c。</p><h2 id="4-梯度裁剪的优势"><a href="#4-梯度裁剪的优势" class="headerlink" title="4. 梯度裁剪的优势"></a>4. 梯度裁剪的优势</h2><ol><li><p><strong>防止梯度爆炸</strong>: 在深层网络或循环神经网络中,梯度可能会变得非常大,导致参数更新过度。梯度裁剪可以防止这种情况发生。</p></li><li><p><strong>稳定训练</strong>: 通过限制梯度的大小,可以使训练过程更加稳定,减少参数更新的波动。</p></li><li><p><strong>改善收敛</strong>: 在某些情况下,梯度裁剪可以帮助模型更快地收敛到一个好的解。</p></li></ol><h2 id="5-实现注意事项"><a href="#5-实现注意事项" class="headerlink" title="5. 实现注意事项"></a>5. 实现注意事项</h2><p>在实践中,梯度裁剪通常在优化器更新参数之前应用。例如,在使用随机梯度下降(SGD)时,更新规则可以表示为:</p><p>$$w_{t+1} &#x3D; w_t - \eta \cdot \nabla L_{clipped}$$</p><p>其中 $\eta$ 是学习率,w_t 是 t 时刻的参数值。</p><p>需要注意的是,梯度裁剪的阈值 c 是一个超参数,需要根据具体任务和模型结构进行调整。选择一个合适的 c 值对于模型的性能至关重要。</p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Neural Network </tag>
            
            <tag> Training Process </tag>
            
            <tag> Trick </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彼得林奇投资经典著作读书笔记 - 长期投资的智慧</title>
      <link href="/article/a0866f96.html"/>
      <url>/article/a0866f96.html</url>
      
        <content type="html"><![CDATA[<h1 id="彼得林奇著作读书笔记"><a href="#彼得林奇著作读书笔记" class="headerlink" title="彼得林奇著作读书笔记"></a>彼得林奇著作读书笔记</h1><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202307291935001.jpeg" alt="Peter Lynch"></p><h2 id="一、长期投资"><a href="#一、长期投资" class="headerlink" title="一、长期投资"></a>一、长期投资</h2><ul><li>技术</li><li>金融 </li><li>基础设施<ul><li>能源</li><li>交通</li></ul></li></ul><p>个人资产</p><table><thead><tr><th>投资类型</th><th>投资比例</th></tr></thead><tbody><tr><td>长期投资</td><td>50-70%</td></tr><tr><td>短期投资</td><td>不到 20%</td></tr><tr><td>现金储备</td><td>10%-15%</td></tr></tbody></table><ul><li>投资不起眼,枯燥平凡、无人关注的公司</li><li>投资稳定行业中收益增长率20-25%的公司  </li><li>投资有利基的公司</li><li>困境反转可能好于快速增长</li><li>注意市盈率、回购、负债,多年派息与收息</li><li>观察机构投资人持股</li></ul><h2 id="二、下单前沉思二分钟"><a href="#二、下单前沉思二分钟" class="headerlink" title="二、下单前沉思二分钟"></a>二、下单前沉思二分钟</h2><blockquote><p>耐心</p></blockquote><ul><li>为什么买?感兴趣的点,【找到股价上涨的理由】</li><li>需要什么公司才能成功</li><li>公司面临什么障碍?  </li><li>如何有疑惑再观望一阵</li></ul><h3 id="Warning⚠️"><a href="#Warning⚠️" class="headerlink" title="Warning⚠️"></a>Warning⚠️</h3><ul><li>远离热门行业的热门股  </li><li>远离高收益陷阱</li><li>远离多元化经营</li><li>第一轮扩张不要着急冲</li><li>远离负债累累公司</li></ul><h2 id="三、公司股票类型"><a href="#三、公司股票类型" class="headerlink" title="三、公司股票类型"></a>三、公司股票类型</h2><table><thead><tr><th>特点</th><th>类型</th><th>目的&#x2F;需掌握信息</th></tr></thead><tbody><tr><td>股息占收益比低</td><td>缓慢增长型</td><td>获得稳定股息</td></tr><tr><td>横盘稳</td><td>稳定增长型</td><td>市盈率多少?产品销量?股价?</td></tr><tr><td>收益增长率 20-25%</td><td>快速增长型(无人问津)</td><td>业务突破方向?负债多少?主要产品占比</td></tr><tr><td>成本削减,剥离子公司</td><td>困境反转型(债务结构)</td><td>重整计划如何?市场占有率?(可能振荡2-3 年)</td></tr><tr><td>了解并购者</td><td>隐蔽资产型</td><td>隐藏资产?价值几何?</td></tr><tr><td>市盈率复苏</td><td>周期型公司股票</td><td>底谷期,经营状况好转复苏(例如汽车 3-5 年上,3-5 年下)</td></tr></tbody></table><h2 id="四、牛股特点"><a href="#四、牛股特点" class="headerlink" title="四、牛股特点"></a>四、牛股特点</h2><blockquote><p>(针对传统行业)制造业、服务业</p></blockquote><ul><li>业务好、特点突出</li><li>市盈率低、少量证券公司关注(3-5个)  </li><li>大型机构投资者持股不过20%、内部人员持股信息;股票太多不是利好、水分大</li><li>亲自去门店考察</li><li>花几个小时了解公司历程、背景,财务数据,业务方向</li></ul><h2 id="五、信息"><a href="#五、信息" class="headerlink" title="五、信息"></a>五、信息</h2><ul><li><p>招股说明书、季报、年报(几分钟搜集有用信息)  </p></li><li><p>计算现金资产,看趋势↑<br>债务↓</p></li><li><p>现金头寸-长期债务<br>净现金头寸&gt;债务总额</p></li><li><p>存货可抵消短期债务</p></li><li><p>☆ 流通股↓公司回购  </p></li><li><p>☆ 现金头寸&#x2F;流通股 每股净现金价值</p></li><li><p>书上找不到的信息可以</p><ul><li>向专业人士询问</li><li>给公司打电话</li><li>登门拜访</li><li>实地考察</li></ul></li><li><p>不要只看账面信息</p></li></ul><h2 id="六、年报重要指标"><a href="#六、年报重要指标" class="headerlink" title="六、年报重要指标"></a>六、年报重要指标</h2><h3 id="某产品在总销售额中占的比例-越大越好"><a href="#某产品在总销售额中占的比例-越大越好" class="headerlink" title="某产品在总销售额中占的比例(越大越好)"></a>某产品在总销售额中占的比例(越大越好)</h3><p>如果占比不大那么对股东意义也不大</p><h3 id="市盈率-快速增大型30倍、稳定增长型12倍"><a href="#市盈率-快速增大型30倍、稳定增长型12倍" class="headerlink" title="市盈率(快速增大型30倍、稳定增长型12倍)"></a>市盈率(快速增大型30倍、稳定增长型12倍)</h3><p>  要和收益增长率同步,收益增长率为12%以上、市盈率低于6就是非常值得研究的潜力股、反之拉胯</p><h3 id="市盈率最好只有收益增长率的一半"><a href="#市盈率最好只有收益增长率的一半" class="headerlink" title="市盈率最好只有收益增长率的一半"></a>市盈率最好只有收益增长率的一半</h3><p>  公司市盈率与行业平均市盈率比较</p><h3 id="有股息情况下套用公式"><a href="#有股息情况下套用公式" class="headerlink" title="有股息情况下套用公式"></a>有股息情况下套用公式</h3><p>  $\frac{长期收益增长率+股息收益率}{市盈率}$</p><ul><li>1.5就还不错</li><li>2值得考虑入手</li></ul><h3 id="负债"><a href="#负债" class="headerlink" title="负债"></a>负债</h3><ul><li><p>负债权益比率(debt-to-equity ratio)&lt;25%<br>说明经营正常、负债占比越小越好</p></li><li><p>如果公司有足够现金可忽略短期负债</p></li><li><p>短期负债对股东来说很危险,决定公司命运</p></li><li><p>因此负债结构很重要、如果公司有足够现金以及政府贷款就有可能走出困境</p></li></ul><h3 id="股息"><a href="#股息" class="headerlink" title="股息"></a>股息</h3><ul><li><p>并购成风的年代抗风险</p></li><li><p>股息持续增加的蓝筹股有抗跌性</p></li><li><p>投资组合中保留稳定&#x2F;缓慢增长型股票抗风险</p></li><li><p>但有机会要把这些股票放到不发股息但业务扩张迅速的小公司身上</p></li><li><p>电力公司和电信公司是发股息的主要公司</p></li></ul><h3 id="账面价值"><a href="#账面价值" class="headerlink" title="账面价值"></a>账面价值</h3><ul><li><p>往往会被高估,成品有可能售价远高于实际价格</p></li><li><p>但是偶尔也会被低估</p></li></ul><h3 id="隐蔽资产"><a href="#隐蔽资产" class="headerlink" title="隐蔽资产"></a>隐蔽资产</h3><ul><li><p>入账价格也有可能按采购价计算,故意低调少交税</p></li><li><p>商誉的摊销,抵消每年收益</p></li><li><p>专利权的持有,账面价值为0</p></li><li><p>子公司的资产</p></li><li><p>公司名下的土地,石油财产,贵金属</p></li><li><p>投资公司的股东公司(国外)</p></li></ul><h3 id="现金流量-不适用于迭代快行业"><a href="#现金流量-不适用于迭代快行业" class="headerlink" title="现金流量(不适用于迭代快行业)"></a>现金流量(不适用于迭代快行业)</h3><ul><li><p>现金流入超过现金流出的净流入</p></li><li><p>若每股20¥,每股现金流量为2¥,则市价现金流量比率为10:1、属于正常水平</p></li><li><p>若现金流量为10¥,可以ALL-In、注意每股净现金</p></li></ul><h3 id="存货"><a href="#存货" class="headerlink" title="存货"></a>存货</h3><ul><li><p>当存货增长速度超过销售增长速度要警惕</p></li><li><p>可以比较往年存货期末价值避免误导</p></li><li><p>存货逐渐减少是公司好转的有利信号</p></li></ul><h3 id="养老金计划"><a href="#养老金计划" class="headerlink" title="养老金计划"></a>养老金计划</h3><ul><li>年报中查询公司给员工的股票期权以及养老金福利降低估值</li></ul><h3 id="增长率"><a href="#增长率" class="headerlink" title="增长率"></a>增长率</h3><ul><li><p>影响股价增长率的收益增长率</p></li><li><p>降低生产成本提高销售价格</p></li><li><p>寻找花狸胡哨提高利润但是又不损失客户的公司</p></li><li><p>其他条件相同,优先购买收益增长率高的股票、如:市盈率20倍,收益增长率20%&gt;市盈率10倍,收益增长率10%</p></li></ul><h3 id="税后利润"><a href="#税后利润" class="headerlink" title="税后利润"></a>税后利润</h3><ul><li><p>税前利润率高的公司成本更低、更能存活</p></li><li><p>比较同一行业不同公司的税前利润</p></li><li><p>困境反转发生在</p><ul><li><p>汽车、化工、造纸、航空、钢铁、电子,非铁材料</p></li><li><p>传统疗养院,天然气,零售业</p></li></ul></li><li><p>长期持股选税前利润率高的公司</p></li><li><p>复苏阶段持股选税前利润率相对低的公司</p></li></ul><h2 id="七、定期复查公司季报"><a href="#七、定期复查公司季报" class="headerlink" title="七、定期复查公司季报"></a>七、定期复查公司季报</h2><ul><li>确定公司业务是否仍在扩张、未来发展空间、计划</li></ul><h2 id="八、投资组合"><a href="#八、投资组合" class="headerlink" title="八、投资组合"></a>八、投资组合</h2><ul><li><p>不要频繁交易,4%佣金亏损</p></li><li><p>分散投资确保、12-15%收益率</p></li><li><p>2只稳定增长型、4只快速增长型,4只困境反转型</p></li><li><p>若稳定增长型股票上涨40%、而未来继续盈利希望不大,那么可以出售转购其他潜力股、6次30%收益复利达4倍</p><ul><li>周期型和困境反转型也是如此</li></ul></li><li><p>止损指令十分愚蠢、10—25%都是十分可控的 </p></li><li><p>不要轻易卖出</p></li></ul><h2 id="九、何时卖出"><a href="#九、何时卖出" class="headerlink" title="九、何时卖出"></a>九、何时卖出</h2><h3 id="缓慢增长型-少买"><a href="#缓慢增长型-少买" class="headerlink" title="缓慢增长型(少买)"></a>缓慢增长型(少买)</h3><ul><li><p>连续两年市场份额下跌</p></li><li><p>没有新产品,开始吃老本,现金少,负债多</p></li><li><p>准备搞多元化</p></li><li><p>股价低,股息收益率低</p></li></ul><h3 id="稳定增长型-保险用"><a href="#稳定增长型-保险用" class="headerlink" title="稳定增长型(保险用)"></a>稳定增长型(保险用)</h3><ul><li><p>股价线&gt;收益线,市盈率远高于正常水平</p></li><li><p>没有创新产品、吃老本</p></li><li><p>市盈率为15倍,平均市盈率为11-12倍</p></li><li><p>无内部人员回购</p></li><li><p>主要业务部门被政策打击</p></li><li><p>公司增长率放缓</p></li></ul><h3 id="周期型股票"><a href="#周期型股票" class="headerlink" title="周期型股票"></a>周期型股票</h3><ul><li><p>扩张周期结束时</p></li><li><p>一成本开始上升,存货开始增加,市盈率↓</p></li><li><p>大宗商品价格下跌(汽油、钢铁)</p></li><li><p>期货价格低于现货价格</p></li><li><p>公司决定高成本建新厂</p></li><li><p>竞争对手不断加入</p></li></ul><h3 id="快速增长型"><a href="#快速增长型" class="headerlink" title="快速增长型"></a>快速增长型</h3><ul><li><p>重点观察快速增长第二阶段末期的发展情况</p></li><li><p>停止建新专卖店、店面老旧,产品落伍</p></li><li><p>大家高度认可(专业分析师)、机构投资人持股60%</p></li><li><p>股价高的离谱,市盈率近50倍(酒店达40倍时)</p></li><li><p>最近一个季度同一商店销售额降低3%,新分店拉胯</p></li><li><p>两位高管离职、核心员工离职</p></li><li><p>公司股票30倍,而盈利增长率仅15-20%</p></li></ul><h3 id="困境反转型"><a href="#困境反转型" class="headerlink" title="困境反转型"></a>困境反转型</h3><ul><li><p>过去连续五个季度公司债务下降,但最近季报显示公司债务增长上亿</p></li><li><p>存货增长速度是销售速度的两倍</p></li><li><p>市盈率相较于预期收益增长率高得离谱(50倍以内)</p></li><li><p>公司下属最强分公司50%以上产品都和日落西山客户绑定</p></li></ul><h3 id="隐蔽资产型"><a href="#隐蔽资产型" class="headerlink" title="隐蔽资产型"></a>隐蔽资产型</h3><ul><li><p>最好投资策略:等待公司袭击并购者的出现</p></li><li><p>等,只要公司没有大量借债导致资产下降</p></li><li><p>管理层发消息称发售超总股本10%的股票多元化</p></li><li><p>公司出售分公司预价$ 2000w ,实价$ 1200w</p></li><li><p>税率降低</p></li><li><p>机构持股者比例从5年前 25%上升到如今的60%、几家共同基金集团是主要持股者</p></li></ul><h2 id="十、A股价值投资"><a href="#十、A股价值投资" class="headerlink" title="十、A股价值投资"></a>十、A股价值投资</h2><ul><li><p>非影视、游戏类、非完全竞争类</p></li><li><p>白酒、食品饮料类、啤酒</p></li><li><p>金融房地产、白色家电、工程机械</p></li><li><p>高收益:</p><ul><li><p>毛利率高 (20%以上)</p></li><li><p>市值排前5</p></li><li><p>净资产收益率高</p></li></ul></li><li><p>好的生意:</p><ul><li><p>拥有“核心竞争力”、“垄断”</p></li><li><p>拥有“一招鲜”(茅台)</p></li><li><p>拥有定价权</p></li></ul></li><li><p>垄断的原因</p><ul><li><p>政府特许经营</p></li><li><p>拥有特定资源</p></li><li><p>技术和专利</p></li><li><p>规模经济</p></li><li><p>品牌效应</p></li></ul></li></ul><p>管理层有决策力</p>]]></content>
      
      
      <categories>
          
          <category> Skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Investment </tag>
            
            <tag> Finance </tag>
            
            <tag> Stocks </tag>
            
            <tag> Strategy </tag>
            
            <tag> Analysis </tag>
            
            <tag> A 股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My Questions and Learnings from Exploring  Process Management</title>
      <link href="/article/e2f5e0f7.html"/>
      <url>/article/e2f5e0f7.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Analyzing-Process-States"><a href="#1-Analyzing-Process-States" class="headerlink" title="1. Analyzing Process States"></a>1. Analyzing Process States</h2><p>Early on, I collected some process status information containing process state abbreviations like S, D, etc. By researching their meanings, I summarized that S represents a running process and D means blocked waiting for I&#x2F;O. Comparing the process info, I analyzed what tasks each process was performing, such as file copying or VSCode monitoring.</p><h2 id="2-Inspecting-Detailed-Process-Resource-Usage"><a href="#2-Inspecting-Detailed-Process-Resource-Usage" class="headerlink" title="2. Inspecting Detailed Process Resource Usage"></a>2. Inspecting Detailed Process Resource Usage</h2><p>To deeply understand a copying process, I further parsed its username, PID, run time, memory usage, executing command and parameter meanings to gain a comprehensive view.  </p><h2 id="3-Using-Process-Monitoring-Commands"><a href="#3-Using-Process-Monitoring-Commands" class="headerlink" title="3. Using Process Monitoring Commands"></a>3. Using Process Monitoring Commands</h2><p>I learned commands like ps, pstree, top, and lsof that provide process resource usage, memory mappings, open file descriptors and more. For example, lsof shows which files a process has open.</p><h2 id="4-Understanding-the-SSH-Connection-Process-Model"><a href="#4-Understanding-the-SSH-Connection-Process-Model" class="headerlink" title="4. Understanding the SSH Connection Process Model"></a>4. Understanding the SSH Connection Process Model</h2><p>Research showed that each SSH connection spawns three processes - a primary sshd receives connections, a child handles sessions, and ssh allocates the Shell environment. This helped me grasp SSH connection workflow.</p><h2 id="5-Checking-Concurrent-Logins"><a href="#5-Checking-Concurrent-Logins" class="headerlink" title="5. Checking Concurrent Logins"></a>5. Checking Concurrent Logins</h2><p>Lastly, using w, who, last with a username checks the number of concurrent login sessions for that account, useful for access management.</p><p>Through exploring process management concepts in Linux, I aimed to address questions and summarize findings on analyzing processes and monitoring resources in practice. Ongoing learning will strengthen my skills.</p>]]></content>
      
      
      <categories>
          
          <category> Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> processmanagement </tag>
            
            <tag> Commands </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/article/0.html"/>
      <url>/article/0.html</url>
      
        <content type="html"><![CDATA[<h2 id="lt-lt-lt-lt-lt-lt-lt-HEAD-source-x2F-posts-x2F-Ubuntu-git-ssh-md"><a href="#lt-lt-lt-lt-lt-lt-lt-HEAD-source-x2F-posts-x2F-Ubuntu-git-ssh-md" class="headerlink" title="&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:source&#x2F;_posts&#x2F;Ubuntu-git-ssh.md"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:source&#x2F;_posts&#x2F;Ubuntu-git-ssh.md</h2><h2 id="title-Ubuntu-git-sshtags-Ubuntu-Clash-ssh-gitcategories-技术分享abbrlink-847ddabetop-truesummary-解决了代理模式下Ubuntu使用git推送hexo的心头之患excerpt-是否有意外呢-date-2022-12-19-23-53-28"><a href="#title-Ubuntu-git-sshtags-Ubuntu-Clash-ssh-gitcategories-技术分享abbrlink-847ddabetop-truesummary-解决了代理模式下Ubuntu使用git推送hexo的心头之患excerpt-是否有意外呢-date-2022-12-19-23-53-28" class="headerlink" title="title: Ubuntu_git_sshtags:  - Ubuntu  - Clash  - ssh  - gitcategories: 技术分享abbrlink: 847ddabetop: truesummary: 解决了代理模式下Ubuntu使用git推送hexo的心头之患excerpt: 是否有意外呢?date: 2022-12-19 23:53:28"></a>title: Ubuntu_git_ssh<br>tags:<br>  - Ubuntu<br>  - Clash<br>  - ssh<br>  - git<br>categories: 技术分享<br>abbrlink: 847ddabe<br>top: true<br>summary: 解决了代理模式下Ubuntu使用git推送hexo的心头之患<br>excerpt: 是否有意外呢?<br>date: 2022-12-19 23:53:28</h2><h1 id="解决了我的心头大患"><a href="#解决了我的心头大患" class="headerlink" title="解决了我的心头大患"></a>解决了我的心头大患</h1><p><a href="https://stackoverflow.com/questions/59692874/ssh-vt-gitgithub-com-kex-exchange-identification-connection-closed-by-remote" title="stackoverflow帖子,需要翻墙">帖子链接</a></p><p>原因分析:</p><ul><li><p>Ubuntu使用的$clash$并且所有网络访问走的都是指定端口9494</p></li><li><p>导致一直github远程仓库无法认证,生成了ssh公钥都两遍</p></li><li><p>还得是<a href="www.stackoverflow.com">stackoverflow</a>老哥靠谱,指出代理(那三个字母沈河过不了)的可能性</p></li><li><p>最后通过先在 <code>.ssh</code>中建立 <code>config</code>文件,随后配置端口Port443以及认证密钥</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Host github.com    User <span class="token function">git</span>    Port <span class="token number">443</span>    HostName ssh.github.com    IdentityFile ~/.ssh/id_rsa <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>最后通过命令 <code>ssh -T git@github.com</code> yes后认证成功</p></li><li><p>解决,继续部署静态博客</p></li></ul><p>12.20号,在coding上部署的时候发现ssh连接验证又出现了问题!</p><blockquote><p>具体表现为使用下面的命令直接卡住,还不如github当初的直接拒绝呢</p></blockquote><p>使用命令:</p><p><code>ssh -T git@git.coding.net</code></p><p><code>ssh -T git@ssh.coding.net</code></p><p>均不奏效,遂更改 <code>.ssh</code>文件里面的 <code>config</code>文件</p><p>内容如下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Host coding.net    User <span class="token function">git</span>    Port <span class="token number">443</span>    HostName ssh.coding.net    IdentityFile ~/.ssh/id_rsa  Host *.coding.net    User <span class="token function">git</span>    Port <span class="token number">443</span>    HostName git.coding.net    HostkeyAlgorithms +ssh-rsa    PubkeyAcceptedAlgorithms +ssh-rsa    IdentityFile ~/.ssh/id_rsa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个文件配置都试过,可惜就下面那个加 <code>*.</code>的还稍微靠谱一点,起码连接的时候把端口改为443了,但是都还是卡住了,随后发现这个命令可以完成认证:</p><h1 id="ssh-T-git-e-coding-net"><a href="#ssh-T-git-e-coding-net" class="headerlink" title="ssh -T git@e.coding.net"></a><code>ssh -T git@e.coding.net</code></h1><hr><h2 id="title-Ubuntu-Git-SSH-推送tags-Ubuntucategories-Engineeringabbrlink-847ddabetop-falsesummary-解决了代理模式下Ubuntu使用Git推送Hexo的心头之患excerpt-是否有意外呢-date-2022-12-19-23-53-28"><a href="#title-Ubuntu-Git-SSH-推送tags-Ubuntucategories-Engineeringabbrlink-847ddabetop-falsesummary-解决了代理模式下Ubuntu使用Git推送Hexo的心头之患excerpt-是否有意外呢-date-2022-12-19-23-53-28" class="headerlink" title="title: Ubuntu-Git-SSH 推送tags: Ubuntucategories: Engineeringabbrlink: 847ddabetop: falsesummary: 解决了代理模式下Ubuntu使用Git推送Hexo的心头之患excerpt: 是否有意外呢?date: 2022-12-19 23:53:28"></a>title: Ubuntu-Git-SSH 推送<br>tags: Ubuntu<br>categories: Engineering<br>abbrlink: 847ddabe<br>top: false<br>summary: 解决了代理模式下Ubuntu使用Git推送Hexo的心头之患<br>excerpt: 是否有意外呢?<br>date: 2022-12-19 23:53:28</h2><h1 id="解决了我的心头大患-1"><a href="#解决了我的心头大患-1" class="headerlink" title="解决了我的心头大患"></a>解决了我的心头大患</h1><p><a href="https://stackoverflow.com/questions/59692874/ssh-vt-gitgithub-com-kex-exchange-identification-connection-closed-by-remote" title="stackoverflow帖子,需要翻墙">帖子链接</a></p><p>原因分析:</p><ul><li><p>Ubuntu翻墙使用的Clash并且所有网络访问走的都是指定端口9494</p></li><li><p>导致一直github远程仓库无法认证,疑似没有添加公钥，尝试重新生成ssh公钥</p></li><li><p>还得是<a href="www.stackoverflow.com">stackoverflow</a>老哥靠谱,指出代理的可能性</p></li><li><p>最后通过先在 <code>.ssh</code>中建立 <code>config</code>文件,随后配置端口Port443以及认证密钥</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Host github.com    User <span class="token function">git</span>    Port <span class="token number">443</span>    HostName ssh.github.com    IdentityFile ~/.ssh/id_rsa <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>最后通过命令 <code>ssh -T git@github.com</code> yes后认证成功</p></li><li><p>解决,继续部署静态博客</p></li></ul><p>12.20号,在coding上部署的时候发现ssh连接验证又出现了问题!</p><blockquote><p>具体表现为使用下面的命令直接卡住,还不如github当初的直接拒绝呢</p></blockquote><p>使用命令:</p><p><code>ssh -T git@git.coding.net</code></p><p><code>ssh -T git@ssh.coding.net</code></p><p>均不奏效,遂更改 <code>.ssh</code>文件里面的 <code>config</code>文件</p><p>内容如下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Host coding.net    User <span class="token function">git</span>    Port <span class="token number">443</span>    HostName ssh.coding.net    IdentityFile ~/.ssh/id_rsa  Host *.coding.net    User <span class="token function">git</span>    Port <span class="token number">443</span>    HostName git.coding.net    HostkeyAlgorithms +ssh-rsa    PubkeyAcceptedAlgorithms +ssh-rsa    IdentityFile ~/.ssh/id_rsa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个文件配置都试过,可惜就下面那个加 <code>*.</code>的还稍微靠谱一点,起码连接的时候把端口改为443了,但是都还是卡住了,随后发现这个命令可以完成认证:</p><p><code>ssh -T git@e.coding.net</code></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202307291904029.png"></p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>fb72dae14cd9e0db202a1bf72852d247dcc943c9:source&#x2F;_posts&#x2F;技术&#x2F;hard skill&#x2F;Ubuntu-git-ssh.md</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Fix entering Emergency Mode during startup</title>
      <link href="/article/2185f868.html"/>
      <url>/article/2185f868.html</url>
      
        <content type="html"><![CDATA[<p>关于解决Ubuntu22启动时进入Emergency Mode的问题</p><h1 id="修复启动时进入Emergency-Mode"><a href="#修复启动时进入Emergency-Mode" class="headerlink" title="修复启动时进入Emergency Mode"></a>修复启动时进入Emergency Mode</h1><p>最近机房服务器在启动时进入了紧急模式,显示有file system error，具体为 file system 的所有文件变为了read-only。这种情况可能是因为文件系统损坏导致的。要修复这个问题,主要有两种方法:</p><h2 id="方法1-在GRUB中添加参数强制文件系统检查"><a href="#方法1-在GRUB中添加参数强制文件系统检查" class="headerlink" title="方法1:在GRUB中添加参数强制文件系统检查"></a>方法1:在GRUB中添加参数强制文件系统检查</h2><p>可以在GRUB的启动参数中添加<code>fsck.repair=yes</code>。这会强制系统在启动时进行文件系统检查,并自动修复发现的错误。</p><p>具体操作方法是:</p><ol><li>重启电脑,进入GRUB菜单</li><li>选择要启动的内核,按“e”键编辑</li><li>在内核那一行的末尾添加<code>fsck.repair=yes</code> </li><li>按F10保存并退出</li></ol><p>这种方法可以自动解决文件系统错误,不过有时也无法完全修复,需要手动操作。</p><h2 id="方法2-在紧急模式下运行fsck命令检查文件系统"><a href="#方法2-在紧急模式下运行fsck命令检查文件系统" class="headerlink" title="方法2:在紧急模式下运行fsck命令检查文件系统"></a>方法2:在紧急模式下运行fsck命令检查文件系统</h2><p>如果方法1无法解决,可以进入紧急模式,手动运行文件系统检查工具fsck,定位并修复错误。</p><p>具体操作方法是:</p><ol><li>重启进入GRUB菜单</li><li>选择“高级选项”&gt;“紧急模式”</li><li>运行命令<code>sudo fsck -f /dev/sdXX</code> (用实际的磁盘代号替换sdXX)</li><li>根据提示修复错误,修复完成后重启系统</li></ol><p>这种方法可以更深入检测文件系统,手动定位错误。但需要对系统较熟悉,才能解析fsck的输出。</p><p>通过上述两种方法,我成功修复了启动时进入紧急模式的问题。文件系统维护非常重要,要定期备份数据,避免系统崩溃或损坏导致数据丢失。如果遇到类似问题,可以参考这两种解决方法。</p>]]></content>
      
      
      <categories>
          
          <category> Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> DevOps </tag>
            
            <tag> Linux </tag>
            
            <tag> Disk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learning Diffusers Library</title>
      <link href="/article/d3a6f586.html"/>
      <url>/article/d3a6f586.html</url>
      
        <content type="html"><![CDATA[<h1 id="Diffusers"><a href="#Diffusers" class="headerlink" title="Diffusers"></a>Diffusers</h1><h2 id="Unit1-An-Introduction-to-Diffusion-Models"><a href="#Unit1-An-Introduction-to-Diffusion-Models" class="headerlink" title="Unit1: An Introduction to Diffusion Models"></a>Unit1: An Introduction to Diffusion Models</h2><p>Train diffusion model through:</p><ol><li>Load in some images from the training data</li><li>Add noise, in different amounts. Remember, we want the model to do a good job estimating how to ‘fix’ (denoise) both extremely noisy images and images that are close to perfect.</li><li>Feed the noisy versions of the inputs into the model</li><li>Evaluate how well the model does at denoising these inputs</li><li>Use this information to update the model weights</li></ol><h3 id="1-1-DataSets-and-Dataloder"><a href="#1-1-DataSets-and-Dataloder" class="headerlink" title="1.1 DataSets and Dataloder"></a>1.1 DataSets and Dataloder</h3><p>download online datasets and do some data augmentation</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torchvision<span class="token keyword">from</span> datasets <span class="token keyword">import</span> load_dataset<span class="token keyword">from</span> torchvision <span class="token keyword">import</span> transformsdataset <span class="token operator">=</span> load_dataset<span class="token punctuation">(</span><span class="token string">"huggan/smithsonian_butterflies_subset"</span><span class="token punctuation">,</span> split<span class="token operator">=</span><span class="token string">"train"</span><span class="token punctuation">)</span><span class="token comment"># Or load images from a local folder</span><span class="token comment"># dataset = load_dataset("imagefolder", data_dir="path/to/folder")</span><span class="token comment"># We'll train on 32-pixel square images, but you can try larger sizes too</span>image_size <span class="token operator">=</span> <span class="token number">32</span><span class="token comment"># You can lower your batch size if you're running out of GPU memory</span>batch_size <span class="token operator">=</span> <span class="token number">64</span><span class="token comment"># Define data augmentations</span>preprocess <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span>    <span class="token punctuation">[</span>        transforms<span class="token punctuation">.</span>Resize<span class="token punctuation">(</span><span class="token punctuation">(</span>image_size<span class="token punctuation">,</span> image_size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment"># Resize</span>        transforms<span class="token punctuation">.</span>RandomHorizontalFlip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment"># Randomly flip (data augmentation)</span>        transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment"># Convert to tensor (0, 1)</span>        transforms<span class="token punctuation">.</span>Normalize<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment"># Map to (-1, 1)</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">transform</span><span class="token punctuation">(</span>examples<span class="token punctuation">)</span><span class="token punctuation">:</span>    images <span class="token operator">=</span> <span class="token punctuation">[</span>preprocess<span class="token punctuation">(</span>image<span class="token punctuation">.</span>convert<span class="token punctuation">(</span><span class="token string">"RGB"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> image <span class="token keyword">in</span> examples<span class="token punctuation">[</span><span class="token string">"image"</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token string">"images"</span><span class="token punctuation">:</span> images<span class="token punctuation">&#125;</span>dataset<span class="token punctuation">.</span>set_transform<span class="token punctuation">(</span>transform<span class="token punctuation">)</span><span class="token comment"># Create a dataloader from the dataset to serve up the transformed images in batches</span>train_dataloader <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>    dataset<span class="token punctuation">,</span> batch_size<span class="token operator">=</span>batch_size<span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>iterate images and print shape</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">xb <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">(</span><span class="token builtin">iter</span><span class="token punctuation">(</span>train_dataloader<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">"images"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"X shape:"</span><span class="token punctuation">,</span> xb<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>show_images<span class="token punctuation">(</span>xb<span class="token punctuation">)</span><span class="token punctuation">.</span>resize<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">8</span> <span class="token operator">*</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">,</span> resample<span class="token operator">=</span>Image<span class="token punctuation">.</span>NEAREST<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-2-Scheduler"><a href="#1-2-Scheduler" class="headerlink" title="1.2 Scheduler"></a>1.2 Scheduler</h3><p>Paper: <a href="https://arxiv.org/abs/2006.11239">DDPM</a><br>$$q(x_t|x_{t-1}) &#x3D; N(x_t;\sqrt{1-\beta_t}x_{t-1},\beta_tI)$$<br>$$q(x_{1:T}|x_0) &#x3D; \prod_{t&#x3D;1}^{T}q(x_t|x_{t-1})$$<br>where:$x_{t-1}$ scaled by $\sqrt{1-\beta_t}$ add noise scaled by $\beta_t$</p><p>get $x_t$ for any $t$ given $x_0$:<br>$$q(x_t|x_0) &#x3D; N(x_t;\sqrt{\overline{\alpha_t}}x_0,(1-\overline{\alpha_t})I)$$<br>where: $\overline{\alpha_t} &#x3D; \prod_{i&#x3D;1}^{T}\alpha_i$  and $\alpha_i &#x3D; 1 - \beta_i$</p><p>and in code:<br>$\sqrt{\overline{\alpha_t}}$ : <code>sqrt_alpha_prod</code>;<br>$\sqrt{1-\overline{\alpha_t}}$:<code>sqrt_one_minus_alpha_prod</code></p><blockquote><p>NB: if images sizes are small, “cosine scheduler” is better.</p></blockquote><h3 id="1-3-Train-Loop"><a href="#1-3-Train-Loop" class="headerlink" title="1.3 Train Loop"></a>1.3 Train Loop</h3><ol><li><p>set noise scheduler<br><code>noise scheduler = DDPMScheduler(num_train_timesteps = 1000, beta_schedule=&quot;squaredcos_cap_v2&quot;)</code></p></li><li><p>set optimizer<br><code>optimizer = torch.optim.AdamW(model.parameters(), lr = 4e-4)</code></p></li></ol><p><code>losses = []</code></p><ol start="3"><li>loop</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">for</span> step<span class="token punctuation">,</span> batch <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>train_dataloder<span class="token punctuation">)</span><span class="token punctuation">:</span>clean_images <span class="token operator">=</span> batch<span class="token punctuation">[</span><span class="token string">"images"</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment"># sample noise to add to the images</span>noise <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>clean_images<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>clean_images<span class="token punctuation">.</span>device<span class="token punctuation">)</span>bs <span class="token operator">=</span> clean_images<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment"># sample a random timestep for each image</span>timesteps <span class="token operator">=</span> torch<span class="token punctuation">.</span>randint<span class="token punctuation">(</span>            <span class="token number">0</span><span class="token punctuation">,</span> noise_scheduler<span class="token punctuation">.</span>num_train_timesteps<span class="token punctuation">,</span> <span class="token punctuation">(</span>bs<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span> device<span class="token operator">=</span>clean_images<span class="token punctuation">.</span>device        <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">long</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># Add noise to the clean images according to the noise magnitude at each timestep</span>        noisy_images <span class="token operator">=</span> noise_scheduler<span class="token punctuation">.</span>add_noise<span class="token punctuation">(</span>clean_images<span class="token punctuation">,</span> noise<span class="token punctuation">,</span> timesteps<span class="token punctuation">)</span>        <span class="token comment"># Get the model prediction</span>        noise_pred <span class="token operator">=</span> model<span class="token punctuation">(</span>noisy_images<span class="token punctuation">,</span> timesteps<span class="token punctuation">,</span> return_dict<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token comment"># Calculate the loss</span>        loss <span class="token operator">=</span> F<span class="token punctuation">.</span>mse_loss<span class="token punctuation">(</span>noise_pred<span class="token punctuation">,</span> noise<span class="token punctuation">)</span>        loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span>loss<span class="token punctuation">)</span>        losses<span class="token punctuation">.</span>append<span class="token punctuation">(</span>loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># Update the model parameters with the optimizer</span>        optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>        optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        loss_last_epoch <span class="token operator">=</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>losses<span class="token punctuation">[</span><span class="token operator">-</span><span class="token builtin">len</span><span class="token punctuation">(</span>train_dataloader<span class="token punctuation">)</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token builtin">len</span><span class="token punctuation">(</span>train_dataloader<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Epoch:</span><span class="token interpolation"><span class="token punctuation">&#123;</span>epoch<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">&#125;</span></span><span class="token string">, loss: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>loss_last_epoch<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-4-Sampling-Loop"><a href="#1-4-Sampling-Loop" class="headerlink" title="1.4 Sampling Loop"></a>1.4 Sampling Loop</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Random starting point ( 8 random images)</span>sample <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token keyword">for</span> i<span class="token punctuation">,</span>t <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>noise_scheduler<span class="token punctuation">.</span>timesteps<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># get model pred</span><span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>residual <span class="token operator">=</span> model<span class="token punctuation">(</span>sample<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">.</span>sample<span class="token comment"># update sample with step</span>sample <span class="token operator">=</span> noise_scheduler<span class="token punctuation">.</span>step<span class="token punctuation">(</span>residual<span class="token punctuation">,</span> t<span class="token punctuation">,</span> sample<span class="token punctuation">)</span><span class="token punctuation">.</span>prev_sampleshow_image<span class="token punctuation">(</span>sample<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="plotting-the-loss"><a href="#plotting-the-loss" class="headerlink" title="plotting the loss"></a>plotting the loss</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">fig<span class="token punctuation">,</span> axs <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>axs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>plot<span class="token punctuation">(</span>losses<span class="token punctuation">)</span>axs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>plot<span class="token punctuation">(</span>np<span class="token punctuation">.</span>log<span class="token punctuation">(</span>losses<span class="token punctuation">)</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-5-Generate-Images-with-pipeline"><a href="#1-5-Generate-Images-with-pipeline" class="headerlink" title="1.5 Generate Images with pipeline"></a>1.5 Generate Images with pipeline</h3><h4 id="1-5-1-use-pipeline"><a href="#1-5-1-use-pipeline" class="headerlink" title="1.5.1 use pipeline"></a>1.5.1 use pipeline</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> diffusers <span class="token keyword">import</span> DDPMPipelineimage_pipe <span class="token operator">=</span> DDPMPipeline<span class="token punctuation">(</span>unet<span class="token operator">=</span>model<span class="token punctuation">,</span> scheduler<span class="token operator">=</span>noise_scheduler<span class="token punctuation">)</span>pipeline_output <span class="token operator">=</span> image_pipe<span class="token punctuation">(</span><span class="token punctuation">)</span>pipeline_output<span class="token punctuation">.</span>images<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-5-2-use-sampling-loop"><a href="#1-5-2-use-sampling-loop" class="headerlink" title="1.5.2 use sampling loop"></a>1.5.2 use sampling loop</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Random starting point (8 random images):</span>sample <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token keyword">for</span> i<span class="token punctuation">,</span> t <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>noise_scheduler<span class="token punctuation">.</span>timesteps<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># Get model pred</span>    <span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        residual <span class="token operator">=</span> model<span class="token punctuation">(</span>sample<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">.</span>sample    <span class="token comment"># Update sample with step</span>    sample <span class="token operator">=</span> noise_scheduler<span class="token punctuation">.</span>step<span class="token punctuation">(</span>residual<span class="token punctuation">,</span> t<span class="token punctuation">,</span> sample<span class="token punctuation">)</span><span class="token punctuation">.</span>prev_sampleshow_images<span class="token punctuation">(</span>sample<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>The noise_scheduler.step() function does the maths required to update sample appropriately.</p><h3 id="1-6-Scaling-up-with-Accelerate"><a href="#1-6-Scaling-up-with-Accelerate" class="headerlink" title="1.6 Scaling up with Accelerate"></a>1.6 Scaling up with Accelerate</h3><p>example:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">accelerate launch train_unconditional.py <span class="token punctuation">\</span>  <span class="token parameter variable">--dataset_name</span><span class="token operator">=</span><span class="token string">"huggan/smithsonian_butterflies_subset"</span> <span class="token punctuation">\</span>  <span class="token parameter variable">--resolution</span><span class="token operator">=</span><span class="token number">64</span> <span class="token punctuation">\</span>  <span class="token parameter variable">--output_dir</span><span class="token operator">=</span><span class="token punctuation">&#123;</span>model_name<span class="token punctuation">&#125;</span> <span class="token punctuation">\</span>  <span class="token parameter variable">--train_batch_size</span><span class="token operator">=</span><span class="token number">32</span> <span class="token punctuation">\</span>  <span class="token parameter variable">--num_epochs</span><span class="token operator">=</span><span class="token number">50</span> <span class="token punctuation">\</span>  <span class="token parameter variable">--gradient_accumulation_steps</span><span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">\</span>  <span class="token parameter variable">--learning_rate</span><span class="token operator">=</span>1e-4 <span class="token punctuation">\</span>  <span class="token parameter variable">--lr_warmup_steps</span><span class="token operator">=</span><span class="token number">500</span> <span class="token punctuation">\</span>  <span class="token parameter variable">--mixed_precision</span><span class="token operator">=</span><span class="token string">"no"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Some-Additional-Resources"><a href="#Some-Additional-Resources" class="headerlink" title="Some Additional Resources"></a>Some Additional Resources</h3><p>The Annotated Diffusion Model is a very in-depth walk-through of the code and theory behind DDPMs with maths and code showing all the different components. It also links to a number of papers for further reading.</p><p>Hugging Face documentation on Unconditional Image-Generation for some examples of how to train diffusion models using the official training example script, including code showing how to create your own dataset.</p><p>AI Coffee Break video on Diffusion Models: <a href="https://www.youtube.com/watch?v=344w5h24-h8">https://www.youtube.com/watch?v=344w5h24-h8</a></p><p>Yannic Kilcher Video on DDPMs: <a href="https://www.youtube.com/watch?v=W-O7AZNzbzQ">https://www.youtube.com/watch?v=W-O7AZNzbzQ</a></p><h2 id="Unit2-Fine-Tuning-Guidance-and-Conditioning"><a href="#Unit2-Fine-Tuning-Guidance-and-Conditioning" class="headerlink" title="Unit2: Fine-Tuning, Guidance and Conditioning"></a>Unit2: Fine-Tuning, Guidance and Conditioning</h2><p>In this Unit we will look at how this process can be modified to add additional control over the model outputs through extra conditioning (such as a class label) or with techniques such as guidance</p><ul><li>Create a sampling loop and generate samples faster using a new scheduler</li><li>Fine-tune an existing diffusion model on new data, including:<ul><li>Using gradient accumulation to get around some of the issues with small batches</li><li>Logging samples to Weights and Biases during training to monitor progress (via the accompanying example script)</li><li>Saving the resulting pipeline and uploading it to the hub</li></ul></li><li>Guide the sampling process with additional loss functions to add control over existing models, including:<ul><li>Exploring different guidance approaches with a simple color-based loss</li><li>Using CLIP to guide generation using a text prompt</li><li>Sharing a custom sampling loop using Gradio and 🤗 Spaces</li></ul></li></ul><h3 id="2-1-Ways-to-pass-in-conditioning-information"><a href="#2-1-Ways-to-pass-in-conditioning-information" class="headerlink" title="2.1 Ways to pass in conditioning information"></a>2.1 Ways to pass in conditioning information</h3><ol><li>Feeding it in as additional channels in the input to the UNet. This is often used when the conditioning information is the same shape as the image, such as a segmentation mask, a depth map or a blurry version of the image (in the case of a restoration&#x2F;superresolution model). It does work for other types of conditioning too. For example, in the notebook, the class label is mapped to an embedding and then expanded to be the same width and height as the input image so that it can be fed in as additional channels.</li><li>Creating an embedding and then projecting it down to a size that matches the number of channels at the output of one or more internal layers of the UNet, and then adding it to those outputs. This is how the timestep conditioning is handled, for example. The output of each Resnet block has a projected timestep embedding added to it. This is useful when you have a vector such as a CLIP image embedding as your conditioning information. A notable example is the ‘Image Variations’ version of Stable Diffusion which does exactly this.</li><li>Adding cross-attention layers that can ‘attend’ to a sequence passed in as conditioning. This is most useful when the conditioning is in the form of some text - the text is mapped to a sequence of embeddings using a transformer model, and then cross-attention layers in the UNet are used to incorporate this information into the denoising path. We’ll see this in action in Unit 3 as we examine how Stable Diffusion handles text conditioning.</li></ol><h3 id="2-2-Fine-Tuning-and-Guidance"><a href="#2-2-Fine-Tuning-and-Guidance" class="headerlink" title="2.2 Fine-Tuning and Guidance"></a>2.2 Fine-Tuning and Guidance</h3><h3 id="2-3-Class-Conditioned-Diffusion-Model"><a href="#2-3-Class-Conditioned-Diffusion-Model" class="headerlink" title="2.3 Class-Conditioned Diffusion Model"></a>2.3 Class-Conditioned Diffusion Model</h3><h3 id="Some-Additional-Resources-1"><a href="#Some-Additional-Resources-1" class="headerlink" title="Some Additional Resources"></a>Some Additional Resources</h3><p>Denoising Diffusion Implicit Models - Introduced the DDIM sampling method (used by DDIMScheduler)</p><p>GLIDE: Towards Photorealistic Image Generation and Editing with Text-Guided Diffusion Models - Introduced methods for conditioning diffusion models on text</p><p>eDiffi: Text-to-Image Diffusion Models with an Ensemble of Expert Denoisers - Shows how many different kinds of conditioning can be used together to give even more control over the kinds of samples generated</p><h2 id="Unit3"><a href="#Unit3" class="headerlink" title="Unit3"></a>Unit3</h2><h2 id="Unit4"><a href="#Unit4" class="headerlink" title="Unit4"></a>Unit4</h2><h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h2><h3 id="pred-img-directly-or-noise"><a href="#pred-img-directly-or-noise" class="headerlink" title="pred img directly or noise"></a>pred img directly or noise</h3><p>You may think that predicting the noise (from which we can derive what the denoised image looks like) is equivalent to just predicting the denoised image directly. So why favour one over the other - is it just for mathematical convenience?</p><p>It turns out there’s another subtlety here. We compute the loss across different (randomly chosen) timesteps during training. These different objectives will lead to different ‘implicit weighting’ of these losses, where predicting the noise puts more weight on lower noise levels. You can pick more complex objectives to change this ‘implicit loss weighting’. Or perhaps you choose a noise schedule that will result in more examples at a higher noise level. Perhaps you have the model predict a ‘velocity’ v which we define as being a combination of both the image and the noise dependent on the noise level (see ‘PROGRESSIVE DISTILLATION FOR FAST SAMPLING OF DIFFUSION MODELS’). Perhaps you have the model predict the noise but then scale the loss by some factor dependent on the amount of noise based on a bit of theory (see ‘Perception Prioritized Training of Diffusion Models’) or based on experiments trying to see what noise levels are most informative to the model (see ‘Elucidating the Design Space of Diffusion-Based Generative Models’). TL;DR: choosing the objective has an effect on model performance, and research in ongoing into what the ‘best’ option is.</p><p>At the moment, predicting the noise (epsilon or eps you’ll see in some places) is the favoured approach but over time we will likely see other objectives supported in the library and used in different situations.</p><h3 id="key-points"><a href="#key-points" class="headerlink" title="key points"></a>key points</h3><p>Exactly how we take these steps depends on the sampling method used. We won’t go into the theory too deeply, but some key design questions are:</p><p>How large of a step should you take? In other words, what ‘noise schedule’ should you follow?<br>Do you use only the model’s current prediction to inform the update step (like DDPM, DDIM and many others)? Do you evaluate the model several times to estimate higher-order gradients for a larger, more accurate step (higher order methods and some discrete ODE solvers)? Or do you keep a history of past predictions to try and better inform the current update step (linear multi-step and ancestral samplers).<br>Do you add in additional noise (sometimes called churn) to add more stochasticity (randomness) to the sampling process, or do you keep it completely deterministic? Many samplers control this with a parameter (such as ‘eta’ for DDIM samplers) so that the user can choose.</p><p>The brave and curious might find it interesting to browse through the code of the different implementations available in the diffusers library here or check out the docs which often link to the relevant papers.</p><h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><p><a href="https://github.com/huggingface/diffusion-models-class/blob/main/">https://github.com/huggingface/diffusion-models-class/blob/main/</a></p><p><a href="https://github.com/huggingface/diffusion-models-class/blob/main/">https://github.com/huggingface/diffusion-models-class/blob/main/</a></p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Diffusers </tag>
            
            <tag> PyTorch </tag>
            
            <tag> Large Model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vision Transformer (ViT) -&gt; Towards a Modality-Agnostic Transformer?</title>
      <link href="/article/8ad3e72a.html"/>
      <url>/article/8ad3e72a.html</url>
      
        <content type="html"><![CDATA[<h3 id="Forward-Process-of-Vision-Transformer-ViT"><a href="#Forward-Process-of-Vision-Transformer-ViT" class="headerlink" title="Forward Process of Vision Transformer (ViT)"></a>Forward Process of Vision Transformer (ViT)</h3><p><strong>Input Image</strong>: $X \in \mathbf{R}^{H \times W \times C}$</p><p>$\downarrow$</p><p><strong>Patch Embedding</strong>: $X_{patches} \in \mathbf{R}^{N \times (P^2 \times C)}$, where $N&#x3D;\frac{H \times W}{P^2}$</p><blockquote><p>Transform the input image (2D) into a sequence of flattened tokens.</p></blockquote><p>Transformation Matrix: $W \in \mathbf{R}^{(P^2 \times C) \times D}$</p><p>Resulting Tensor: $Y \in \mathbf{R}^{N \times D}$</p><p><strong>Concatenation</strong> of a learnable class token: $\vec{x_{cls}} \in \mathbf{R}^{D \times 1}$</p><p><strong>Addition</strong> of positional embeddings: $x_{pos} \in \mathbf{R}^{(N+1) \times D}$</p><p>Final Embedding:<br>$x_{emb} &#x3D; [\vec{x_{cls}}^T; X \cdot W] + x_{pos}$</p><p>$\downarrow$</p><h3 id="Encoder-Layer-with-Residual-Skip-Connections"><a href="#Encoder-Layer-with-Residual-Skip-Connections" class="headerlink" title="Encoder Layer with Residual Skip Connections"></a>Encoder Layer with Residual Skip Connections</h3><p>For each layer $l$, the encoding process follows a sequence of residual operations:</p><ol><li><p><strong>Multi-Head Attention (MHA)</strong>:<br>$$x^{(l)’} &#x3D; MHA(\text{LN}(x^{(l-1)})) + x^{(l-1)}$$</p></li><li><p><strong>Feed-Forward Network (FFN)</strong>:<br>$$x^{(l)} &#x3D; FFN(\text{LN}(x^{(l)’}) + x^{(l)’})$$</p></li></ol><p>In the MHA block, the query, key, and value matrices are defined as:</p><p>$$W_q^{(l)}, W_k^{(l)}, W_v^{(l)} \in \mathbf{R}^{D^{(l-1)} \times D_h^{(l)}}$$</p><p>The attention head computations are given by:<br>$$x_h^{(l)’} &#x3D; AH_h(x_{norm}^{(l-1)}) &#x3D; \mathrm{softmax}\left(\frac{x_{norm}^{(l-1)}W_q^{(l)} \cdot (x_{norm}^{(l-1)}W_k^{(l)})^T}{\sqrt{D_h^{(l)}}}\right)x_{norm}^{(l-1)}W_v^{(l)}$$</p><p>$\downarrow$</p><h3 id="Output-Layer"><a href="#Output-Layer" class="headerlink" title="Output Layer"></a>Output Layer</h3><p>The output of the multi-head attention is computed as:</p><p>$$x^{(l)’} &#x3D; MHA(x_{norm}^{(l-1)}) &#x3D; [AH_1(x_{norm}^{(l-1)}), …, AH_m(x_{norm}^{(l-1)})]W_o^{(l)}$$</p><p>$\downarrow$</p><h3 id="Feed-Forward-Network-Layer"><a href="#Feed-Forward-Network-Layer" class="headerlink" title="Feed-Forward Network Layer"></a>Feed-Forward Network Layer</h3><p>Finally, the FFN is applied:</p><p>$$x^{(l)} &#x3D; FFN(x_{norm}^{(l)’}) &#x3D; \mathrm{GELU}(x_{norm}^{(l)’} W_1^{(l)}) W_2^{(l)}$$<br>where $W_1, W_2 \in \mathbf{R}^{D^{(l)} \times 4D^{(l)}}$, and $x_{norm}^{(l)} &#x3D; \mathrm{LN}(x^{(l)’})$.</p><hr><p>In conclusion, while ViT has shown remarkable results in visual tasks by transforming input images into sequences of tokens, extending the Transformer’s architecture to other modalities remains an open area for exploration. For example, tasks such as “Weight2Weight” may benefit from modality-specific adaptations, especially in the representation of flattened high-dimensional data, where embedding strategies like positional encodings can be integrated in a more structured manner.</p>]]></content>
      
      
      <categories>
          
          <category> Idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diffusion </tag>
            
            <tag> Transformer </tag>
            
            <tag> Weight2Weight </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fine-Tuning Face Based on UniDiffuser</title>
      <link href="/article/3fe63e99.html"/>
      <url>/article/3fe63e99.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-UniDiffuser"><a href="#1-UniDiffuser" class="headerlink" title="1. UniDiffuser"></a>1. UniDiffuser</h2><h3 id="1-1-Architect"><a href="#1-1-Architect" class="headerlink" title="1.1 Architect"></a>1.1 Architect</h3><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202308251937594.png" alt="DiffusionEncoder"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202308251937656.png" alt="DiffusionDecoder"></p><h3 id="1-2-Optimization"><a href="#1-2-Optimization" class="headerlink" title="1.2 Optimization"></a>1.2 Optimization</h3><ul><li>Block:</li></ul><ol><li>in-block: local</li><li>mid-block: Transition to prevent the network from experiencing rapid gradient decay.</li><li>out-block: global, skip connection</li></ol><ul><li>Regularization</li></ul><ol><li>pos-dropout</li><li>residual dropout</li><li>attn dropout</li><li>proj dropout</li><li>label smoothing: smooth one-hot encoding</li><li>stochastic depth: skip block</li><li>weight decay</li></ol><ul><li>Generalization</li></ul><ol><li>residual connection</li><li>layer norm</li><li>global token</li><li>data augmentation(crop flip)</li><li>model ensemble(multi-model combined to predict)</li><li>transfer learning</li><li>sufficient capacity(scale up the capacity and train steps)</li></ol><h3 id="1-3-Unidiffuser-的多模态对齐工作有："><a href="#1-3-Unidiffuser-的多模态对齐工作有：" class="headerlink" title="1.3 Unidiffuser 的多模态对齐工作有："></a>1.3 Unidiffuser 的多模态对齐工作有：</h3><p>虽然没有使用 cross attention，但是在 encoder 阶段相当于进行了一些图文的交互：</p><ol><li>GPT 2 的img embedding 作为 prefix 重构 text</li><li>clip img 生成图像的 语义表征</li></ol><p>decoder 阶段：</p><ol><li>multi head  self attention，内部图文交互<ol><li>考虑加入 cross attention 进行对齐，并进行微调</li><li>考虑加入 prior preservation 正则</li><li>考虑优化 clip text encoder 添加 modifier token</li><li>考虑加入 lora<br><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202308251947394.png"></li></ol></li></ol><h2 id="2-Stable-Diffusion"><a href="#2-Stable-Diffusion" class="headerlink" title="2. Stable Diffusion"></a>2. Stable Diffusion</h2><h3 id="2-1-Architect"><a href="#2-1-Architect" class="headerlink" title="2.1 Architect"></a>2.1 Architect</h3><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202308251944420.png" alt="StableDiffusion"></p>]]></content>
      
      
      <categories>
          
          <category> Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Diffusers </tag>
            
            <tag> PyTorch </tag>
            
            <tag> Large Model </tag>
            
            <tag> Diffusion Model </tag>
            
            <tag> Competition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hard Disk Mounting Under Linux System</title>
      <link href="/article/8350d4a.html"/>
      <url>/article/8350d4a.html</url>
      
        <content type="html"><![CDATA[<p>最近在管理一台Linux服务器时,遇到了一些硬盘挂载和权限管理的问题,在此做一个简单的总结记录。</p><h2 id="一、硬盘检测和分区"><a href="#一、硬盘检测和分区" class="headerlink" title="一、硬盘检测和分区"></a>一、硬盘检测和分区</h2><p>在扩充服务器存储空间时,购买了一块新硬盘,但是系统无法正常识别。排查发现新硬盘接口线松动,导致系统无法检测到硬盘。这让我意识到硬盘问题排查需要从接口连接开始。确保连接可靠后,可以用partprobe命令重新扫描硬盘,如果接口正常应该就可以创建分区。</p><p>在使用fdisk分区时,需要注意当前硬盘是否被占用,避免将运行系统的硬盘进行重分区。创建好分区后,下一步就是格式化。</p><h2 id="二、文件系统格式化"><a href="#二、文件系统格式化" class="headerlink" title="二、文件系统格式化"></a>二、文件系统格式化</h2><p>格式化使用mkfs命令,选择ext4文件系统。格式化时需要确认硬盘没有被占用,否则容易失败。格式化完成就可以挂载使用了。</p><h2 id="三、硬盘挂载"><a href="#三、硬盘挂载" class="headerlink" title="三、硬盘挂载"></a>三、硬盘挂载</h2><p>在挂载新分区时,出现了无法读取超级块的问题。使用fsck检查发现文件系统错误,只能重新格式化,然后挂载成功。由此可见,文件系统损坏是导致无法挂载的常见原因之一。</p><p>另一次挂载失败是因为挂载点目录不存在,意识到挂载之前需要提前创建好目录。目录创建后仍失败,最后发现是同一分区已经挂载到另一个位置,需要先卸载之前的挂载点。</p><p>在卸载时遇到设备忙的错误,使用lsof发现有进程在访问,需要用fuser结束占用进程后才能卸载。</p><h2 id="四、权限管理"><a href="#四、权限管理" class="headerlink" title="四、权限管理"></a>四、权限管理</h2><p>挂载成功后,发现以普通用户无法访问新挂载的文件系统,这是因为默认权限仅允许root用户。解决方法是在挂载时通过mount的参数设置访问权限。</p><p>另一次遇到的权限问题是递归删除目录时报权限不足。这时可以先修改目录权限,或者直接以root身份删除。</p>]]></content>
      
      
      <categories>
          
          <category> Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Linux </tag>
            
            <tag> Disk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Diffusion Sampling Techniques</title>
      <link href="/article/714df5a.html"/>
      <url>/article/714df5a.html</url>
      
        <content type="html"><![CDATA[<h1 id="Understanding-Diffusion-Model-Sampling-Techniques"><a href="#Understanding-Diffusion-Model-Sampling-Techniques" class="headerlink" title="Understanding Diffusion Model Sampling Techniques"></a>Understanding Diffusion Model Sampling Techniques</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>As I explored diffusion models, I found that sampling techniques play a crucial role in the quality and efficiency of image generation. Here’s my comprehensive analysis of different sampling methods and their mathematical foundations.</p><h2 id="1-Basic-Sampling-Methods"><a href="#1-Basic-Sampling-Methods" class="headerlink" title="1. Basic Sampling Methods"></a>1. Basic Sampling Methods</h2><h3 id="1-1-Euler-Method"><a href="#1-1-Euler-Method" class="headerlink" title="1.1 Euler Method"></a>1.1 Euler Method</h3><p>This is the simplest numerical method I encountered. The basic formula is:</p><pre class="line-numbers language-math" data-language="math"><code class="language-math">y_&#123;n+1&#125; &#x3D; y_n + h f(t_n, y_n)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>where:</p><ul><li>h is the step size</li><li>f(t, y) is the derivative function</li><li>y_n is the current state</li><li>y_n+1 is the next state</li></ul><p>In diffusion models context, this becomes:</p><pre class="line-numbers language-math" data-language="math"><code class="language-math">x_&#123;t-1&#125; &#x3D; x_t + \Delta t \cdot \epsilon_\theta(x_t, t)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-2-Heun-Method"><a href="#1-2-Heun-Method" class="headerlink" title="1.2 Heun Method"></a>1.2 Heun Method</h3><p>I found this to be more accurate than Euler as it uses a predictor-corrector approach:</p><p>Predictor step:</p><pre class="line-numbers language-math" data-language="math"><code class="language-math">\tilde&#123;y&#125;_&#123;n+1&#125; &#x3D; y_n + h f(t_n, y_n)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Corrector step:</p><pre class="line-numbers language-math" data-language="math"><code class="language-math">y_&#123;n+1&#125; &#x3D; y_n + \frac&#123;h&#125;&#123;2&#125;[f(t_n, y_n) + f(t_&#123;n+1&#125;, \tilde&#123;y&#125;_&#123;n+1&#125;)]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-Advanced-Sampling-Methods"><a href="#2-Advanced-Sampling-Methods" class="headerlink" title="2. Advanced Sampling Methods"></a>2. Advanced Sampling Methods</h2><h3 id="2-1-Dormand-Prince-DOPRI5"><a href="#2-1-Dormand-Prince-DOPRI5" class="headerlink" title="2.1 Dormand-Prince (DOPRI5)"></a>2.1 Dormand-Prince (DOPRI5)</h3><p>This was interesting as it uses adaptive step sizes. The method uses six function evaluations to calculate both fourth and fifth-order accurate solutions:</p><pre class="line-numbers language-math" data-language="math"><code class="language-math">y_&#123;n+1&#125; &#x3D; y_n + h\sum_&#123;i&#x3D;1&#125;^6 b_i k_i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>where k_i are intermediate slopes and b_i are coefficients.</p><p>The error estimate helps in adapting the step size:</p><pre class="line-numbers language-math" data-language="math"><code class="language-math">error &#x3D; \|y_&#123;n+1&#125;^&#123;(5)&#125; - y_&#123;n+1&#125;^&#123;(4)&#125;\|<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-2-RK4-Fourth-order-Runge-Kutta"><a href="#2-2-RK4-Fourth-order-Runge-Kutta" class="headerlink" title="2.2 RK4 (Fourth-order Runge-Kutta)"></a>2.2 RK4 (Fourth-order Runge-Kutta)</h3><p>This provides a good balance between accuracy and computational cost:</p><pre class="line-numbers language-math" data-language="math"><code class="language-math">\begin&#123;aligned&#125;k_1 &amp;&#x3D; f(t_n, y_n) \\k_2 &amp;&#x3D; f(t_n + \frac&#123;h&#125;&#123;2&#125;, y_n + \frac&#123;h&#125;&#123;2&#125;k_1) \\k_3 &amp;&#x3D; f(t_n + \frac&#123;h&#125;&#123;2&#125;, y_n + \frac&#123;h&#125;&#123;2&#125;k_2) \\k_4 &amp;&#x3D; f(t_n + h, y_n + hk_3) \\y_&#123;n+1&#125; &amp;&#x3D; y_n + \frac&#123;h&#125;&#123;6&#125;(k_1 + 2k_2 + 2k_3 + k_4)\end&#123;aligned&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-Diffusion-Forms"><a href="#3-Diffusion-Forms" class="headerlink" title="3. Diffusion Forms"></a>3. Diffusion Forms</h2><h3 id="3-1-Linear-Diffusion"><a href="#3-1-Linear-Diffusion" class="headerlink" title="3.1 Linear Diffusion"></a>3.1 Linear Diffusion</h3><p>The simplest form I worked with:</p><pre class="line-numbers language-math" data-language="math"><code class="language-math">dx_t &#x3D; -\frac&#123;1&#125;&#123;2&#125;\beta(t)x_t dt + \sqrt&#123;\beta(t)&#125;dW_t<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-SBDM-Score-Based-Diffusion-Models"><a href="#3-2-SBDM-Score-Based-Diffusion-Models" class="headerlink" title="3.2 SBDM (Score-Based Diffusion Models)"></a>3.2 SBDM (Score-Based Diffusion Models)</h3><p>Uses score function:</p><pre class="line-numbers language-math" data-language="math"><code class="language-math">dx_t &#x3D; [\mu(x_t, t) + \frac&#123;1&#125;&#123;2&#125;\sigma^2(t)\nabla_x \log p_t(x_t)]dt + \sigma(t)dW_t<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-Error-Control-Parameters"><a href="#4-Error-Control-Parameters" class="headerlink" title="4. Error Control Parameters"></a>4. Error Control Parameters</h2><h3 id="4-1-Absolute-Tolerance-atol"><a href="#4-1-Absolute-Tolerance-atol" class="headerlink" title="4.1 Absolute Tolerance (atol)"></a>4.1 Absolute Tolerance (atol)</h3><p>Controls absolute error:</p><pre class="line-numbers language-math" data-language="math"><code class="language-math">|error| \leq atol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-2-Relative-Tolerance-rtol"><a href="#4-2-Relative-Tolerance-rtol" class="headerlink" title="4.2 Relative Tolerance (rtol)"></a>4.2 Relative Tolerance (rtol)</h3><p>Controls relative error:</p><pre class="line-numbers language-math" data-language="math"><code class="language-math">\frac&#123;|error|&#125;&#123;|y|&#125; \leq rtol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-Practical-Implementation-Tips"><a href="#5-Practical-Implementation-Tips" class="headerlink" title="5. Practical Implementation Tips"></a>5. Practical Implementation Tips</h2><p>From my experience:</p><ol><li><p>Speed vs Quality Trade-offs:</p><ul><li>Fast generation: Euler method with larger step sizes</li><li>High quality: DOPRI5 with small tolerances</li><li>Balanced: RK4 with moderate parameters</li></ul></li><li><p>Parameter Selection:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># For high quality</span>sampling_kwargs <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'method'</span><span class="token punctuation">:</span> <span class="token string">'dopri5'</span><span class="token punctuation">,</span>    <span class="token string">'atol'</span><span class="token punctuation">:</span> <span class="token number">1e-6</span><span class="token punctuation">,</span>    <span class="token string">'rtol'</span><span class="token punctuation">:</span> <span class="token number">1e-3</span><span class="token punctuation">&#125;</span><span class="token comment"># For fast generation</span>sampling_kwargs <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'method'</span><span class="token punctuation">:</span> <span class="token string">'euler'</span><span class="token punctuation">,</span>    <span class="token string">'atol'</span><span class="token punctuation">:</span> <span class="token number">1e-4</span><span class="token punctuation">,</span>    <span class="token string">'rtol'</span><span class="token punctuation">:</span> <span class="token number">1e-2</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Memory Considerations:</p><ul><li>DOPRI5 requires more memory for adaptive steps</li><li>Euler is memory-efficient but less accurate</li></ul></li></ol><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Understanding these sampling techniques helped me:</p><ol><li>Better control the generation process</li><li>Make informed decisions about speed-quality trade-offs</li><li>Debug and optimize the sampling process effectively</li></ol><p>This knowledge is crucial for anyone working with diffusion models, as sampling directly impacts the final output quality and generation speed.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li>Diffusion Models Paper</li><li>Numerical Methods in Scientific Computing</li><li>Score-Based Generative Modeling Papers</li></ol><p>This blog serves as my personal reference for understanding and implementing different sampling techniques in diffusion models.</p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diffusion Models </tag>
            
            <tag> Sampling Techniques </tag>
            
            <tag> Numerical Methods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Search Engine Tricks and Tips</title>
      <link href="/article/d1648c6e.html"/>
      <url>/article/d1648c6e.html</url>
      
        <content type="html"><![CDATA[<h1 id="Tricks-for-Search-Engines"><a href="#Tricks-for-Search-Engines" class="headerlink" title="Tricks for Search Engines"></a>Tricks for Search Engines</h1><ol><li><p><code>Quotation marks</code>: For example, “work from home”. This function is used to keep the words together. If you want to search for a complete word, you can put it in quotation marks, and the search engine will not separate it into several words.</p></li><li><p><code>Colon</code>: For example, Visa form: doc, specifies the document type. If you want to search for a specific type of document, you can add a colon and the document type after the keyword, and the search engine will only return documents that meet the criteria.</p></li><li><p><code>Site</code>: Keyword site: URL address. If you want to search within a specific website, you can add site: and the website’s URL address before the keyword, and the search engine will only search within that website.</p></li><li><p><code>+/- sign</code>. If you want to search for a word but don’t want to see certain related content, you can add a “+” before the word. If you want to block certain content, you can add a “-“ before the word.</p></li><li><p><code>/</code>: Directly return to the search bar. If you want to start a new search, you can directly input “&#x2F;“ in the search bar, and the search engine will clear the previous search content.</p></li><li><p><code>..</code>: Quickly narrow down the search scope. If you want to search for content within a certain time period, you can add “..” before and after the time period, and the search engine will only search for content within that time period.</p></li><li><p><code>Intitle</code>: Keyword. If you want to search for content that includes a certain keyword in the title, you can add intitle: before the keyword, and the search engine will only search for content that includes that keyword in the title.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Search Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/article/0.html"/>
      <url>/article/0.html</url>
      
        <content type="html"><![CDATA[<h2 id="lt-lt-lt-lt-lt-lt-lt-HEAD-source-x2F-posts-x2F-matery食用指南-md"><a href="#lt-lt-lt-lt-lt-lt-lt-HEAD-source-x2F-posts-x2F-matery食用指南-md" class="headerlink" title="&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:source&#x2F;_posts&#x2F;matery食用指南.md"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:source&#x2F;_posts&#x2F;matery食用指南.md</h2><h2 id="title-matery食用指南author-Shiymimg-top-falsehide-falsecover-truecoverImg-toc-turemathjax-falsesummary-这是matery主题的readmecategories-技术分享tags-Markdownabbrlink-4c867599date-2022-12-21-09-26-00password"><a href="#title-matery食用指南author-Shiymimg-top-falsehide-falsecover-truecoverImg-toc-turemathjax-falsesummary-这是matery主题的readmecategories-技术分享tags-Markdownabbrlink-4c867599date-2022-12-21-09-26-00password" class="headerlink" title="title: matery食用指南author: Shiymimg:top: falsehide: falsecover: truecoverImg:toc: turemathjax: falsesummary: 这是matery主题的readmecategories: 技术分享tags:  - Markdownabbrlink: 4c867599date: 2022-12-21 09:26:00password:"></a>title: matery食用指南<br>author: Shiym<br>img:<br>top: false<br>hide: false<br>cover: true<br>coverImg:<br>toc: ture<br>mathjax: false<br>summary: 这是matery主题的readme<br>categories: 技术分享<br>tags:<br>  - Markdown<br>abbrlink: 4c867599<br>date: 2022-12-21 09:26:00<br>password:</h2><h1 id="hexo-theme-matery"><a href="#hexo-theme-matery" class="headerlink" title="hexo-theme-matery"></a>hexo-theme-matery</h1><p> <a href="https://github.com/blinkfox/hexo-theme-matery/issues"><img src="https://img.shields.io/github/issues/blinkfox/hexo-theme-matery.svg" alt="GitHub issues"></a> <a href="https://github.com/blinkfox/hexo-theme-matery/blob/master/LICENSE"><img src="https://img.shields.io/github/license/blinkfox/hexo-theme-matery.svg" alt="GitHub license"></a> <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master"><img src="https://img.shields.io/badge/downloads-master-green.svg" alt="Download"></a> <a href="http://hexo.io/"><img src="https://img.shields.io/badge/hexo-%3E%3D%205.0.0-blue.svg" alt="Hexo Version"></a> <a href="https://github.com/blinkfox/hexo-theme-matery/network"><img src="https://img.shields.io/github/forks/blinkfox/hexo-theme-matery.svg" alt="GitHub forks"></a> <a href="https://github.com/blinkfox/hexo-theme-matery/stargazers"><img src="https://img.shields.io/github/stars/blinkfox/hexo-theme-matery.svg" alt="GitHub stars"></a></p><p><a href="README.md">🇺🇸English Document</a> | <a href="http://blinkfox.com/">国内访问示例 (http://blinkfox.com)</a> | <a href="https://blinkfox.github.io/">Github 部署演示示例 (https://blinkfox.github.io)</a></p><p>QQ 交流群1（已满）: <a href="https://jq.qq.com/?_wv=1027&k=5zMDYHT"><code>926552981</code></a> | QQ 交流群2（已满）: <a href="https://jq.qq.com/?_wv=1027&k=53q2Ayp"><code>971887688</code></a> | QQ 交流群3（推荐）: <a href="https://qm.qq.com/cgi-bin/qm/qr?k=fC1-kU-_aTn4q-JQq4GsYKr4WcKdgfGa&jump_from=webapi"><code>670694035</code></a></p><blockquote><p>这是一个采用 <code>Material Design</code> 和响应式设计的 Hexo 博客主题。</p></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>简单漂亮，文章内容美观易读</li><li><a href="https://material.io/">Material Design</a> 设计</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li><li>首页轮播文章及每天动态切换 <code>Banner</code> 图片</li><li>瀑布流式的博客文章列表（文章无特色图片时会有 <code>24</code> 张漂亮的图片代替）</li><li>时间轴式的归档页</li><li><strong>词云</strong>的标签页和<strong>雷达图</strong>的分类页</li><li>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</li><li>可自定义的数据的友情链接页面</li><li>支持文章置顶和文章打赏</li><li>支持 <code>MathJax</code></li><li><code>TOC</code> 目录</li><li>可设置复制文章内容时追加版权信息</li><li>可设置阅读文章时做密码验证</li><li><a href="https://gitalk.github.io/">Gitalk</a>、<a href="https://imsun.github.io/gitment/">Gitment</a>、<a href="https://valine.js.org/">Valine</a> 和 <a href="https://disqus.com/">Disqus</a> 评论模块（推荐使用 <code>Gitalk</code>）</li><li>集成了<a href="http://busuanzi.ibruce.info/">不蒜子统计</a>、谷歌分析（<code>Google Analytics</code>）和文章字数统计等功能</li><li>支持在首页的音乐播放和视频播放功能</li><li>支持 <code>emoji</code>表情，用 <code>markdown emoji</code>语法书写直接生成对应的能<strong>跳跃</strong>的表情。</li><li>支持 <a href="http://www.daovoice.io/">DaoVoice</a>、<a href="https://www.tidio.com/">Tidio</a> 在线聊天功能。</li></ul><h2 id="贡献者"><a href="#贡献者" class="headerlink" title="贡献者"></a>贡献者</h2><p>感谢下面列出的贡献者，没有他们，hexo-theme-matery 不会这么完美。</p><ul><li><a href="https://github.com/HarborZeng">@HarborZeng</a></li><li><a href="https://github.com/shw2018">@shw2018</a></li><li><a href="https://github.com/L1cardo">@L1cardo</a></li><li><a href="https://github.com/Five-great">@Five-great</a></li></ul><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>本主题<strong>推荐你使用 Hexo 5.0.0 及以上的版本</strong>。如果，你已经有一个自己的 <a href="https://hexo.io/zh-cn/">Hexo</a> 博客了，建议你将 Hexo 升级到最新稳定的版本。</p><p>点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master">这里</a> 下载 <code>master</code> 分支的最新稳定版的代码，解压缩后，将 <code>hexo-theme-matery</code> 的文件夹复制到你 Hexo 的 <code>themes</code> 文件夹中即可。</p><p>当然你也可以在你的 <code>themes</code> 文件夹下使用 <code>git clone</code> 命令来下载:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/blinkfox/hexo-theme-matery.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的  <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p><h4 id="config-yml-文件的其它修改建议"><a href="#config-yml-文件的其它修改建议" class="headerlink" title="_config.yml 文件的其它修改建议:"></a><code>_config.yml</code> 文件的其它修改建议:</h4><ul><li>请修改 <code>_config.yml</code> 的 <code>url</code> 的值为你的网站主 <code>URL</code>（如：<code>http://xxx.github.io</code>）。</li><li>建议修改两个 <code>per_page</code> 的分页条数值为 <code>6</code> 的倍数，如：<code>12</code>、<code>18</code> 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改 <code>language</code> 的值为 <code>zh-CN</code>。</li></ul><h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"categories"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> categories<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"tags"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> tags<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 18:23:38</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h3><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"about"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> about<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建留言板-contact-页（可选的）"><a href="#新建留言板-contact-页（可选的）" class="headerlink" title="新建留言板 contact 页（可选的）"></a>新建留言板 contact 页（可选的）</h3><p><code>contact</code> 页是用来展示<strong>留言板</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>contact/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"contact"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/contact/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> contact<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"contact"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"contact"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：本留言板功能依赖于第三方评论系统，请<strong>激活</strong>你的评论系统才有效果。并且在主题的 <code>_config.yml</code> 文件中，第 <code>19</code> 至 <code>21</code> 行的“<strong>菜单</strong>”配置，取消关于留言板的注释即可。</p></blockquote><h3 id="新建友情链接-friends-页（可选的）"><a href="#新建友情链接-friends-页（可选的）" class="headerlink" title="新建友情链接 friends 页（可选的）"></a>新建友情链接 friends 页（可选的）</h3><p><code>friends</code> 页是用来展示<strong>友情链接</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"friends"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> friends<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-12-12 21:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，在你的博客 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">&#123;</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/1_qq_27922023.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"码酱"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"我不是大佬，只是在追寻大佬的脚步"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://luokangyuan.com/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/4027734.jpeg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"闪烁之狐"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://blinkfox.github.io/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/avatar.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"ja_rome"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"平凡的脚步也可以走出伟大的行程"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://me.csdn.net/jlh912008548"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建-404-页"><a href="#新建-404-页" class="headerlink" title="新建 404 页"></a>新建 404 页</h3><p>如果在你的博客 <code>source</code> 目录下还没有 <code>404.md</code> 文件，那么你就需要新建一个</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token number">404</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/404/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> <span class="token number">404</span><span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"404"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"404"</span><span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"Oops～，我崩溃了！找不到你想要的页面 :("</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="菜单导航配置"><a href="#菜单导航配置" class="headerlink" title="菜单导航配置"></a>菜单导航配置</h3><h4 id="配置基本菜单导航的名称、路径url和图标icon"><a href="#配置基本菜单导航的名称、路径url和图标icon" class="headerlink" title="配置基本菜单导航的名称、路径url和图标icon."></a>配置基本菜单导航的名称、路径url和图标icon.</h4><p>1.菜单导航名称可以是中文也可以是英文(如：<code>Index</code>或 <code>主页</code>)<br>2.图标icon 可以在<a href="https://fontawesome.com/icons">Font Awesome</a> 中查找</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">menu</span><span class="token punctuation">:</span>  <span class="token key atrule">Index</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>home  <span class="token key atrule">Tags</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /tags    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>tags  <span class="token key atrule">Categories</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /categories    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>bookmark  <span class="token key atrule">Archives</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /archives    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>archive  <span class="token key atrule">About</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /about    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>user<span class="token punctuation">-</span>circle  <span class="token key atrule">Friends</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /friends    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>address<span class="token punctuation">-</span>book<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二级菜单配置方法"><a href="#二级菜单配置方法" class="headerlink" title="二级菜单配置方法"></a>二级菜单配置方法</h4><p>如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作</p><ol><li>在需要添加二级菜单的一级菜单下添加 <code>children</code>关键字(如:<code>About</code>菜单下添加 <code>children</code>)</li><li>在 <code>children</code>下创建二级菜单的 名称name,路径url和图标icon.</li><li>注意每个二级菜单模块前要加 <code>-</code>.</li><li>注意缩进格式</li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">menu</span><span class="token punctuation">:</span>  <span class="token key atrule">Index</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>home  <span class="token key atrule">Tags</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /tags    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>tags  <span class="token key atrule">Categories</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /categories    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>bookmark  <span class="token key atrule">Archives</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /archives    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>archive  <span class="token key atrule">About</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /about    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>user<span class="token punctuation">-</span>circle<span class="token punctuation">-</span>o  <span class="token key atrule">Friends</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /friends    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>address<span class="token punctuation">-</span>book  <span class="token key atrule">Medias</span><span class="token punctuation">:</span>    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>list    <span class="token key atrule">children</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Music        <span class="token key atrule">url</span><span class="token punctuation">:</span> /music        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>music      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Movies        <span class="token key atrule">url</span><span class="token punctuation">:</span> /movies        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>film      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Books        <span class="token key atrule">url</span><span class="token punctuation">:</span> /books        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>book      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Galleries        <span class="token key atrule">url</span><span class="token punctuation">:</span> /galleries        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>image<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>从 Hexo5.0 版本开始自带了 <code>prismjs</code> 代码语法高亮的支持，本主题对此进行了改造支持。</p><p>如果你的博客中曾经安装过 <code>hexo-prism-plugin</code> 的插件，那么你须要执行 <code>npm uninstall hexo-prism-plugin</code> 来卸载掉它，否则生成的代码中会有 <code>&amp;#123;</code> 和 <code>&amp;#125;</code> 的转义字符。</p><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并将 <code>prismjs.enable</code> 的值设置为 <code>true</code>，主要配置如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">auto_detect</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span>  <span class="token key atrule">wrap</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">hljs</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">prismjs</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">preprocess</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主题中默认的 <code>prismjs</code> 主题是 <code>Tomorrow Night</code>，如果你想定制自己的主题，可以前往 <a href="https://prismjs.com/download.html">prismjs 下载页面</a> 定制下载自己喜欢的主题 <code>css</code> 文件，然后将此 css 主题文件取名为 <code>prism.css</code>，替换掉 <code>hexo-theme-matery</code> 主题文件夹中的 <code>source/libs/prism/prism.css</code> 文件即可。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-search <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">search</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml  <span class="token key atrule">field</span><span class="token punctuation">:</span> post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="中文链接转拼音（建议安装）"><a href="#中文链接转拼音（建议安装）" class="headerlink" title="中文链接转拼音（建议安装）"></a>中文链接转拼音（建议安装）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i hexo-permalink-pinyin <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">permalink_pinyin</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">separator</span><span class="token punctuation">:</span> <span class="token string">'-'</span> <span class="token comment"># default: '-'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a> 插件也可以生成非中文的链接。</p></blockquote><h3 id="文章字数统计插件（建议安装）"><a href="#文章字数统计插件（建议安装）" class="headerlink" title="文章字数统计插件（建议安装）"></a>文章字数统计插件（建议安装）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i <span class="token parameter variable">--save</span> hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，将各个文章字数相关的配置激活即可：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">postInfo</span><span class="token punctuation">:</span>  <span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">update</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">wordCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 设置文章字数统计为 true.</span>  <span class="token key atrule">totalCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 设置站点文章总字数统计为 true.</span>  <span class="token key atrule">min2read</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 阅读时长.</span>  <span class="token key atrule">readCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 阅读次数.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加emoji表情支持（可选的）"><a href="#添加emoji表情支持（可选的）" class="headerlink" title="添加emoji表情支持（可选的）"></a>添加emoji表情支持（可选的）</h3><p>本主题新增了对 <code>emoji</code>表情的支持，使用到了 <a href="https://npm.taobao.org/package/hexo-filter-github-emojis">hexo-filter-github-emojis</a> 的 Hexo 插件来支持 <code>emoji</code>表情的生成，把对应的 <code>markdown emoji</code>语法（<code>::</code>,例如：<code>:smile:</code>）转变成会跳跃的 <code>emoji</code>表情，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-filter-github-emojis <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">githubEmojis</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">className</span><span class="token punctuation">:</span> github<span class="token punctuation">-</span>emoji  <span class="token key atrule">inject</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">styles</span><span class="token punctuation">:</span>  customEmojis<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后就可以在文章中对应位置看到你用 <code>emoji</code>语法写的表情了。</p><h3 id="添加-RSS-订阅支持（可选的）"><a href="#添加-RSS-订阅支持（可选的）" class="headerlink" title="添加 RSS 订阅支持（可选的）"></a>添加 RSS 订阅支持（可选的）</h3><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-feed <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">feed</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> atom  <span class="token key atrule">path</span><span class="token punctuation">:</span> atom.xml  <span class="token key atrule">limit</span><span class="token punctuation">:</span> <span class="token number">20</span>  <span class="token key atrule">hub</span><span class="token punctuation">:</span>  <span class="token key atrule">content</span><span class="token punctuation">:</span>  <span class="token key atrule">content_limit</span><span class="token punctuation">:</span> <span class="token number">140</span>  <span class="token key atrule">content_limit_delim</span><span class="token punctuation">:</span> <span class="token string">' '</span>  <span class="token key atrule">order_by</span><span class="token punctuation">:</span> <span class="token punctuation">-</span>date<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明你已经安装成功了。</p><h3 id="添加-DaoVoice-在线聊天功能（可选的）"><a href="#添加-DaoVoice-在线聊天功能（可选的）" class="headerlink" title="添加 DaoVoice 在线聊天功能（可选的）"></a>添加 <a href="http://www.daovoice.io/">DaoVoice</a> 在线聊天功能（可选的）</h3><p>前往 <a href="http://www.daovoice.io/">DaoVoice</a> 官网注册并且获取 <code>app_id</code>，并将 <code>app_id</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h3 id="添加-Tidio-在线聊天功能（可选的）"><a href="#添加-Tidio-在线聊天功能（可选的）" class="headerlink" title="添加 Tidio 在线聊天功能（可选的）"></a>添加 <a href="https://www.tidio.com/">Tidio</a> 在线聊天功能（可选的）</h3><p>前往 <a href="https://www.tidio.com/">Tidio</a> 官网注册并且获取 <code>Public Key</code>，并将 <code>Public Key</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h3 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h3><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱等的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;% if (theme.socialLink.github) &#123; %>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&lt;%= theme.socialLink.github %><span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tooltipped<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span> <span class="token attr-name">data-tooltip</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>访问我的GitHub<span class="token punctuation">"</span></span> <span class="token attr-name">data-position</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span> <span class="token attr-name">data-delay</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fab fa-github<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>&lt;% &#125; %><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在 <a href="https://fontawesome.com/icons">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fab fa-facebook</code></li><li>Twitter: <code>fab fa-twitter</code></li><li>Google-plus: <code>fab fa-google-plus</code></li><li>Linkedin: <code>fab fa-linkedin</code></li><li>Tumblr: <code>fab fa-tumblr</code></li><li>Medium: <code>fab fa-medium</code></li><li>Slack: <code>fab fa-slack</code></li><li>Sina Weibo: <code>fab fa-weibo</code></li><li>Wechat: <code>fab fa-weixin</code></li><li>QQ: <code>fab fa-qq</code></li><li>Zhihu: <code>fab fa-zhihu</code></li></ul><blockquote><p><strong>注意</strong>: 本主题中使用的 <code>Font Awesome</code> 版本为 <code>5.11.0</code>。</p></blockquote><h3 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="配置音乐播放器（可选的）"><a href="#配置音乐播放器（可选的）" class="headerlink" title="配置音乐播放器（可选的）"></a>配置音乐播放器（可选的）</h3><p>要支持音乐播放，在主题的 <code>_config.yml</code> 配置文件中激活music配置即可：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 是否在首页显示音乐</span><span class="token key atrule">music</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">title</span><span class="token punctuation">:</span>         <span class="token comment"># 非吸底模式有效</span>    <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">show</span><span class="token punctuation">:</span> 听听音乐  <span class="token key atrule">server</span><span class="token punctuation">:</span> netease   <span class="token comment"># require music platform: netease, tencent, kugou, xiami, baidu</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> playlist    <span class="token comment"># require song, playlist, album, search, artist</span>  <span class="token key atrule">id</span><span class="token punctuation">:</span> <span class="token number">503838841</span>     <span class="token comment"># require song id / playlist id / album id / search keyword</span>  <span class="token key atrule">fixed</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>      <span class="token comment"># 开启吸底模式</span>  <span class="token key atrule">autoplay</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>   <span class="token comment"># 是否自动播放</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">'#42b983'</span>  <span class="token key atrule">loop</span><span class="token punctuation">:</span> <span class="token string">'all'</span>       <span class="token comment"># 音频循环播放, 可选值: 'all', 'one', 'none'</span>  <span class="token key atrule">order</span><span class="token punctuation">:</span> <span class="token string">'random'</span>   <span class="token comment"># 音频循环顺序, 可选值: 'list', 'random'</span>  <span class="token key atrule">preload</span><span class="token punctuation">:</span> <span class="token string">'auto'</span>   <span class="token comment"># 预加载，可选值: 'none', 'metadata', 'auto'</span>  <span class="token key atrule">volume</span><span class="token punctuation">:</span> <span class="token number">0.7</span>       <span class="token comment"># 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效</span>  <span class="token key atrule">listFolded</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token comment"># 列表默认折叠</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>server</code>可选 <code>netease</code>（网易云音乐），<code>tencent</code>（QQ音乐），<code>kugou</code>（酷狗音乐），<code>xiami</code>（虾米音乐），</p><p><code>baidu</code>（百度音乐）。</p><p><code>type</code>可选 <code>song</code>（歌曲），<code>playlist</code>（歌单），<code>album</code>（专辑），<code>search</code>（搜索关键字），<code>artist</code>（歌手）</p><p><code>id</code>获取方法示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，浏览器地址栏后面会有一串数字，<code>playlist</code>的 <code>id</code></p><p>即为这串数字。</p></blockquote><h3 id="添加note"><a href="#添加note" class="headerlink" title="添加note"></a>添加note</h3><blockquote><p><a href="https://blog.17lai.site/posts/cf0f47fd/#tag-note">演示</a></p></blockquote><h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><pre class="line-numbers language-none"><code class="language-none">&#123;% note [class] [no-icon] [summary] %&#125;Any content (support inline tags too).&#123;% endnote %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>[class]</code> : <em>Optional parameter.</em> Supported values: default | primary | success | info | warning | danger.</li><li><code>[no-icon]</code> : <em>Optional parameter.</em> Disable icon in note.</li><li><code>[summary]</code> : <em>Optional parameter.</em> Optional summary of the note.</li></ul><p>All parameters are optional.</p><h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><pre class="line-numbers language-none"><code class="language-none">&#123;% note %&#125;#### Header(without define class style)&#123;% endnote %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加button"><a href="#添加button" class="headerlink" title="添加button"></a>添加button</h3><blockquote><p><a href="https://blog.17lai.site/posts/cf0f47fd/#tag-button">演示</a></p></blockquote><h4 id="Usage-1"><a href="#Usage-1" class="headerlink" title="Usage"></a>Usage</h4><pre class="line-numbers language-none"><code class="language-none">&#123;% button url, text, icon [class], [title] %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>or</p><pre class="line-numbers language-none"><code class="language-none">&#123;% btn url, text, icon [class], [title] %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>url</code> : Absolute or relative path to URL.</li><li><code>text</code> : Button text. Required if no icon specified.</li><li><code>icon</code> : Font Awesome icon name. Required if no text specified.</li><li><code>[class]</code> : <em>Optional parameter.</em> Font Awesome class(es): <code>fa-fw</code> | <code>fa-lg</code> | <code>fa-2x</code> | <code>fa-3x</code> | <code>fa-4x</code> | <code>fa-5x</code></li><li><code>[title]</code> : <em>Optional parameter.</em> Tooltip at mouseover.</li></ul><h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><pre class="line-numbers language-none"><code class="language-none">&#123;% button #, Text %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如:<code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>hide</td><td><code>false</code></td><td>隐藏文章，如果 <code>hide</code>值为 <code>true</code>，则文章不会在首页显示</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2">开源中国在线工具</a>、<a href="http://encode.chahuo.com/">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a>。</li><li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 赵奇<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg<span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">hide</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> /images/1.jpg<span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">summary</span><span class="token punctuation">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<span class="token key atrule">categories</span><span class="token punctuation">:</span> Markdown<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> Typora  <span class="token punctuation">-</span> Markdown<span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h2><p><img src="http://static.blinkfox.com/matery-20181202-1.png" alt="首页"></p><p><img src="http://static.blinkfox.com/matery-20181202-2.png" alt="首页推荐文章"></p><p><img src="http://static.blinkfox.com/matery-20181202-3.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-7.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-8.png" alt="首页文章列表"></p><h2 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h2><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li><li><a href="http://busuanzi.ibruce.info/">不蒜子统计</a>和谷歌分析（<code>Google Analytics</code>）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图</li></ul><p><strong>我认为个人博客应该都有自己的风格和特色</strong>。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：</p><h3 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h3><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */</span><span class="token selector">.bg-color</span> <span class="token punctuation">&#123;</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>to right<span class="token punctuation">,</span> #4cbf30 0%<span class="token punctuation">,</span> #0f9d58 100%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token atrule"><span class="token rule">@-webkit-keyframes</span> rainbow</span> <span class="token punctuation">&#123;</span>   <span class="token comment">/* 动态切换背景颜色. */</span><span class="token punctuation">&#125;</span><span class="token atrule"><span class="token rule">@keyframes</span> rainbow</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* 动态切换背景颜色. */</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改-banner-图和文章特色图"><a href="#修改-banner-图和文章特色图" class="headerlink" title="修改 banner 图和文章特色图"></a>修改 banner 图和文章特色图</h3><p>你可以直接在 <code>/source/medias/banner</code> 文件夹中更换你喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果你会 <code>JavaScript</code> 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.bg-cover'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'background-image'</span><span class="token punctuation">,</span> <span class="token string">'url(/medias/banner/'</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.jpg)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p><h2 id="版本变更记录"><a href="#版本变更记录" class="headerlink" title="版本变更记录"></a>版本变更记录</h2><p>参见 <a href="https://github.com/blinkfox/hexo-theme-matery/blob/master/CHANGELOG.md">CHANGELOG.md</a></p><h2 id="更多部署方式"><a href="#更多部署方式" class="headerlink" title="更多部署方式"></a>更多部署方式</h2><blockquote><p>Jsdelivr 已经被封了，这两个可以加速访问快一点</p></blockquote><h3 id="vercel-部署"><a href="#vercel-部署" class="headerlink" title="vercel 部署"></a><a href="https://blog.17lai.site/posts/5311b619/#vercel-%E9%83%A8%E7%BD%B2">vercel 部署</a></h3><h3 id="cloudflare-Pages-部署"><a href="#cloudflare-Pages-部署" class="headerlink" title="cloudflare Pages 部署"></a><a href="https://blog.17lai.site/posts/5311b619/#cloudflare-Pages-%E9%83%A8%E7%BD%B2">cloudflare Pages 部署</a></h3><h2 id="x3D-x3D-x3D-x3D-x3D-x3D-x3D"><a href="#x3D-x3D-x3D-x3D-x3D-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;"></a>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</h2><h2 id="title-matery-Theme指北author-Shiymtop-falsehide-falsecover-falsetoc-turemathjax-falsesummary-matery主题的readme搬运categories-Technologytags-Hexo-blogabbrlink-4c867599date-2022-12-21-09-26-00img-coverImg-password"><a href="#title-matery-Theme指北author-Shiymtop-falsehide-falsecover-falsetoc-turemathjax-falsesummary-matery主题的readme搬运categories-Technologytags-Hexo-blogabbrlink-4c867599date-2022-12-21-09-26-00img-coverImg-password" class="headerlink" title="title: matery Theme指北author: Shiymtop: falsehide: falsecover: falsetoc: turemathjax: falsesummary: matery主题的readme搬运categories: Technologytags:  - Hexo  - blogabbrlink: 4c867599date: 2022-12-21 09:26:00img:coverImg:password:"></a>title: matery Theme指北<br>author: Shiym<br>top: false<br>hide: false<br>cover: false<br>toc: ture<br>mathjax: false<br>summary: matery主题的readme搬运<br>categories: Technology<br>tags:<br>  - Hexo<br>  - blog<br>abbrlink: 4c867599<br>date: 2022-12-21 09:26:00<br>img:<br>coverImg:<br>password:</h2><h1 id="hexo-theme-matery-1"><a href="#hexo-theme-matery-1" class="headerlink" title="hexo-theme-matery"></a>hexo-theme-matery</h1><p> <a href="https://github.com/blinkfox/hexo-theme-matery/issues"><img src="https://img.shields.io/github/issues/blinkfox/hexo-theme-matery.svg" alt="GitHub issues"></a> <a href="https://github.com/blinkfox/hexo-theme-matery/blob/master/LICENSE"><img src="https://img.shields.io/github/license/blinkfox/hexo-theme-matery.svg" alt="GitHub license"></a> <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master"><img src="https://img.shields.io/badge/downloads-master-green.svg" alt="Download"></a> <a href="http://hexo.io/"><img src="https://img.shields.io/badge/hexo-%3E%3D%205.0.0-blue.svg" alt="Hexo Version"></a> <a href="https://github.com/blinkfox/hexo-theme-matery/network"><img src="https://img.shields.io/github/forks/blinkfox/hexo-theme-matery.svg" alt="GitHub forks"></a> <a href="https://github.com/blinkfox/hexo-theme-matery/stargazers"><img src="https://img.shields.io/github/stars/blinkfox/hexo-theme-matery.svg" alt="GitHub stars"></a></p><p><a href="README.md">🇺🇸English Document</a> | <a href="http://blinkfox.com/">国内访问示例 (http://blinkfox.com)</a> | <a href="https://blinkfox.github.io/">Github 部署演示示例 (https://blinkfox.github.io)</a></p><p>QQ 交流群1（已满）: <a href="https://jq.qq.com/?_wv=1027&k=5zMDYHT"><code>926552981</code></a> | QQ 交流群2（已满）: <a href="https://jq.qq.com/?_wv=1027&k=53q2Ayp"><code>971887688</code></a> | QQ 交流群3（推荐）: <a href="https://qm.qq.com/cgi-bin/qm/qr?k=fC1-kU-_aTn4q-JQq4GsYKr4WcKdgfGa&jump_from=webapi"><code>670694035</code></a></p><blockquote><p>这是一个采用 <code>Material Design</code> 和响应式设计的 Hexo 博客主题。</p></blockquote><h2 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h2><ul><li>简单漂亮，文章内容美观易读</li><li><a href="https://material.io/">Material Design</a> 设计</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li><li>首页轮播文章及每天动态切换 <code>Banner</code> 图片</li><li>瀑布流式的博客文章列表（文章无特色图片时会有 <code>24</code> 张漂亮的图片代替）</li><li>时间轴式的归档页</li><li><strong>词云</strong>的标签页和<strong>雷达图</strong>的分类页</li><li>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</li><li>可自定义的数据的友情链接页面</li><li>支持文章置顶和文章打赏</li><li>支持 <code>MathJax</code></li><li><code>TOC</code> 目录</li><li>可设置复制文章内容时追加版权信息</li><li>可设置阅读文章时做密码验证</li><li><a href="https://gitalk.github.io/">Gitalk</a>、<a href="https://imsun.github.io/gitment/">Gitment</a>、<a href="https://valine.js.org/">Valine</a> 和 <a href="https://disqus.com/">Disqus</a> 评论模块（推荐使用 <code>Gitalk</code>）</li><li>集成了<a href="http://busuanzi.ibruce.info/">不蒜子统计</a>、谷歌分析（<code>Google Analytics</code>）和文章字数统计等功能</li><li>支持在首页的音乐播放和视频播放功能</li><li>支持 <code>emoji</code>表情，用 <code>markdown emoji</code>语法书写直接生成对应的能<strong>跳跃</strong>的表情。</li><li>支持 <a href="http://www.daovoice.io/">DaoVoice</a>、<a href="https://www.tidio.com/">Tidio</a> 在线聊天功能。</li></ul><h2 id="贡献者-1"><a href="#贡献者-1" class="headerlink" title="贡献者"></a>贡献者</h2><p>感谢下面列出的贡献者，没有他们，hexo-theme-matery 不会这么完美。</p><ul><li><a href="https://github.com/HarborZeng">@HarborZeng</a></li><li><a href="https://github.com/shw2018">@shw2018</a></li><li><a href="https://github.com/L1cardo">@L1cardo</a></li><li><a href="https://github.com/Five-great">@Five-great</a></li></ul><h2 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h2><p>本主题<strong>推荐你使用 Hexo 5.0.0 及以上的版本</strong>。如果，你已经有一个自己的 <a href="https://hexo.io/zh-cn/">Hexo</a> 博客了，建议你将 Hexo 升级到最新稳定的版本。</p><p>点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master">这里</a> 下载 <code>master</code> 分支的最新稳定版的代码，解压缩后，将 <code>hexo-theme-matery</code> 的文件夹复制到你 Hexo 的 <code>themes</code> 文件夹中即可。</p><p>当然你也可以在你的 <code>themes</code> 文件夹下使用 <code>git clone</code> 命令来下载:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/blinkfox/hexo-theme-matery.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><h3 id="切换主题-1"><a href="#切换主题-1" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的  <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p><h4 id="config-yml-文件的其它修改建议-1"><a href="#config-yml-文件的其它修改建议-1" class="headerlink" title="_config.yml 文件的其它修改建议:"></a><code>_config.yml</code> 文件的其它修改建议:</h4><ul><li>请修改 <code>_config.yml</code> 的 <code>url</code> 的值为你的网站主 <code>URL</code>（如：<code>http://xxx.github.io</code>）。</li><li>建议修改两个 <code>per_page</code> 的分页条数值为 <code>6</code> 的倍数，如：<code>12</code>、<code>18</code> 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改 <code>language</code> 的值为 <code>zh-CN</code>。</li></ul><h3 id="新建分类-categories-页-1"><a href="#新建分类-categories-页-1" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"categories"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> categories<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建标签-tags-页-1"><a href="#新建标签-tags-页-1" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"tags"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> tags<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 18:23:38</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建关于我-about-页-1"><a href="#新建关于我-about-页-1" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h3><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"about"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> about<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建留言板-contact-页（可选的）-1"><a href="#新建留言板-contact-页（可选的）-1" class="headerlink" title="新建留言板 contact 页（可选的）"></a>新建留言板 contact 页（可选的）</h3><p><code>contact</code> 页是用来展示<strong>留言板</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>contact/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"contact"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/contact/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> contact<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"contact"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"contact"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：本留言板功能依赖于第三方评论系统，请<strong>激活</strong>你的评论系统才有效果。并且在主题的 <code>_config.yml</code> 文件中，第 <code>19</code> 至 <code>21</code> 行的“<strong>菜单</strong>”配置，取消关于留言板的注释即可。</p></blockquote><h3 id="新建友情链接-friends-页（可选的）-1"><a href="#新建友情链接-friends-页（可选的）-1" class="headerlink" title="新建友情链接 friends 页（可选的）"></a>新建友情链接 friends 页（可选的）</h3><p><code>friends</code> 页是用来展示<strong>友情链接</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"friends"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> friends<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-12-12 21:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，在你的博客 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">&#123;</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/1_qq_27922023.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"码酱"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"我不是大佬，只是在追寻大佬的脚步"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://luokangyuan.com/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/4027734.jpeg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"闪烁之狐"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://blinkfox.github.io/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/avatar.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"ja_rome"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"平凡的脚步也可以走出伟大的行程"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://me.csdn.net/jlh912008548"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建-404-页-1"><a href="#新建-404-页-1" class="headerlink" title="新建 404 页"></a>新建 404 页</h3><p>如果在你的博客 <code>source</code> 目录下还没有 <code>404.md</code> 文件，那么你就需要新建一个</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token number">404</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/404/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> <span class="token number">404</span><span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"404"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"404"</span><span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"Oops～，我崩溃了！找不到你想要的页面 :("</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="菜单导航配置-1"><a href="#菜单导航配置-1" class="headerlink" title="菜单导航配置"></a>菜单导航配置</h3><h4 id="配置基本菜单导航的名称、路径url和图标icon-1"><a href="#配置基本菜单导航的名称、路径url和图标icon-1" class="headerlink" title="配置基本菜单导航的名称、路径url和图标icon."></a>配置基本菜单导航的名称、路径url和图标icon.</h4><p>1.菜单导航名称可以是中文也可以是英文(如：<code>Index</code>或 <code>主页</code>)<br>2.图标icon 可以在<a href="https://fontawesome.com/icons">Font Awesome</a> 中查找</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">menu</span><span class="token punctuation">:</span>  <span class="token key atrule">Index</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>home  <span class="token key atrule">Tags</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /tags    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>tags  <span class="token key atrule">Categories</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /categories    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>bookmark  <span class="token key atrule">Archives</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /archives    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>archive  <span class="token key atrule">About</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /about    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>user<span class="token punctuation">-</span>circle  <span class="token key atrule">Friends</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /friends    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>address<span class="token punctuation">-</span>book<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二级菜单配置方法-1"><a href="#二级菜单配置方法-1" class="headerlink" title="二级菜单配置方法"></a>二级菜单配置方法</h4><p>如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作</p><ol><li>在需要添加二级菜单的一级菜单下添加 <code>children</code>关键字(如:<code>About</code>菜单下添加 <code>children</code>)</li><li>在 <code>children</code>下创建二级菜单的 名称name,路径url和图标icon.</li><li>注意每个二级菜单模块前要加 <code>-</code>.</li><li>注意缩进格式</li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">menu</span><span class="token punctuation">:</span>  <span class="token key atrule">Index</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>home  <span class="token key atrule">Tags</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /tags    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>tags  <span class="token key atrule">Categories</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /categories    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>bookmark  <span class="token key atrule">Archives</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /archives    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>archive  <span class="token key atrule">About</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /about    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>user<span class="token punctuation">-</span>circle<span class="token punctuation">-</span>o  <span class="token key atrule">Friends</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /friends    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>address<span class="token punctuation">-</span>book  <span class="token key atrule">Medias</span><span class="token punctuation">:</span>    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>list    <span class="token key atrule">children</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Music        <span class="token key atrule">url</span><span class="token punctuation">:</span> /music        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>music      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Movies        <span class="token key atrule">url</span><span class="token punctuation">:</span> /movies        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>film      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Books        <span class="token key atrule">url</span><span class="token punctuation">:</span> /books        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>book      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Galleries        <span class="token key atrule">url</span><span class="token punctuation">:</span> /galleries        <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>image<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码高亮-1"><a href="#代码高亮-1" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>从 Hexo5.0 版本开始自带了 <code>prismjs</code> 代码语法高亮的支持，本主题对此进行了改造支持。</p><p>如果你的博客中曾经安装过 <code>hexo-prism-plugin</code> 的插件，那么你须要执行 <code>npm uninstall hexo-prism-plugin</code> 来卸载掉它，否则生成的代码中会有 <code>&amp;#123;</code> 和 <code>&amp;#125;</code> 的转义字符。</p><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并将 <code>prismjs.enable</code> 的值设置为 <code>true</code>，主要配置如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">auto_detect</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span>  <span class="token key atrule">wrap</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">hljs</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">prismjs</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">preprocess</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主题中默认的 <code>prismjs</code> 主题是 <code>Tomorrow Night</code>，如果你想定制自己的主题，可以前往 <a href="https://prismjs.com/download.html">prismjs 下载页面</a> 定制下载自己喜欢的主题 <code>css</code> 文件，然后将此 css 主题文件取名为 <code>prism.css</code>，替换掉 <code>hexo-theme-matery</code> 主题文件夹中的 <code>source/libs/prism/prism.css</code> 文件即可。</p><h3 id="搜索-1"><a href="#搜索-1" class="headerlink" title="搜索"></a>搜索</h3><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-search <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">search</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml  <span class="token key atrule">field</span><span class="token punctuation">:</span> post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="中文链接转拼音（建议安装）-1"><a href="#中文链接转拼音（建议安装）-1" class="headerlink" title="中文链接转拼音（建议安装）"></a>中文链接转拼音（建议安装）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i hexo-permalink-pinyin <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">permalink_pinyin</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">separator</span><span class="token punctuation">:</span> <span class="token string">'-'</span> <span class="token comment"># default: '-'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a> 插件也可以生成非中文的链接。</p></blockquote><h3 id="文章字数统计插件（建议安装）-1"><a href="#文章字数统计插件（建议安装）-1" class="headerlink" title="文章字数统计插件（建议安装）"></a>文章字数统计插件（建议安装）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i <span class="token parameter variable">--save</span> hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，将各个文章字数相关的配置激活即可：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">postInfo</span><span class="token punctuation">:</span>  <span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">update</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">wordCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 设置文章字数统计为 true.</span>  <span class="token key atrule">totalCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 设置站点文章总字数统计为 true.</span>  <span class="token key atrule">min2read</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 阅读时长.</span>  <span class="token key atrule">readCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 阅读次数.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加emoji表情支持（可选的）-1"><a href="#添加emoji表情支持（可选的）-1" class="headerlink" title="添加emoji表情支持（可选的）"></a>添加emoji表情支持（可选的）</h3><p>本主题新增了对 <code>emoji</code>表情的支持，使用到了 <a href="https://npm.taobao.org/package/hexo-filter-github-emojis">hexo-filter-github-emojis</a> 的 Hexo 插件来支持 <code>emoji</code>表情的生成，把对应的 <code>markdown emoji</code>语法（<code>::</code>,例如：<code>:smile:</code>）转变成会跳跃的 <code>emoji</code>表情，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-filter-github-emojis <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">githubEmojis</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">className</span><span class="token punctuation">:</span> github<span class="token punctuation">-</span>emoji  <span class="token key atrule">inject</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">styles</span><span class="token punctuation">:</span>  customEmojis<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后就可以在文章中对应位置看到你用 <code>emoji</code>语法写的表情了。</p><h3 id="添加-RSS-订阅支持（可选的）-1"><a href="#添加-RSS-订阅支持（可选的）-1" class="headerlink" title="添加 RSS 订阅支持（可选的）"></a>添加 RSS 订阅支持（可选的）</h3><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-feed <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">feed</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> atom  <span class="token key atrule">path</span><span class="token punctuation">:</span> atom.xml  <span class="token key atrule">limit</span><span class="token punctuation">:</span> <span class="token number">20</span>  <span class="token key atrule">hub</span><span class="token punctuation">:</span>  <span class="token key atrule">content</span><span class="token punctuation">:</span>  <span class="token key atrule">content_limit</span><span class="token punctuation">:</span> <span class="token number">140</span>  <span class="token key atrule">content_limit_delim</span><span class="token punctuation">:</span> <span class="token string">' '</span>  <span class="token key atrule">order_by</span><span class="token punctuation">:</span> <span class="token punctuation">-</span>date<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明你已经安装成功了。</p><h3 id="添加-DaoVoice-在线聊天功能（可选的）-1"><a href="#添加-DaoVoice-在线聊天功能（可选的）-1" class="headerlink" title="添加 DaoVoice 在线聊天功能（可选的）"></a>添加 <a href="http://www.daovoice.io/">DaoVoice</a> 在线聊天功能（可选的）</h3><p>前往 <a href="http://www.daovoice.io/">DaoVoice</a> 官网注册并且获取 <code>app_id</code>，并将 <code>app_id</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h3 id="添加-Tidio-在线聊天功能（可选的）-1"><a href="#添加-Tidio-在线聊天功能（可选的）-1" class="headerlink" title="添加 Tidio 在线聊天功能（可选的）"></a>添加 <a href="https://www.tidio.com/">Tidio</a> 在线聊天功能（可选的）</h3><p>前往 <a href="https://www.tidio.com/">Tidio</a> 官网注册并且获取 <code>Public Key</code>，并将 <code>Public Key</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h3 id="修改页脚-1"><a href="#修改页脚-1" class="headerlink" title="修改页脚"></a>修改页脚</h3><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h3 id="修改社交链接-1"><a href="#修改社交链接-1" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱等的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;% if (theme.socialLink.github) &#123; %>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&lt;%= theme.socialLink.github %><span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tooltipped<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span> <span class="token attr-name">data-tooltip</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>访问我的GitHub<span class="token punctuation">"</span></span> <span class="token attr-name">data-position</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span> <span class="token attr-name">data-delay</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fab fa-github<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>&lt;% &#125; %><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在 <a href="https://fontawesome.com/icons">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fab fa-facebook</code></li><li>Twitter: <code>fab fa-twitter</code></li><li>Google-plus: <code>fab fa-google-plus</code></li><li>Linkedin: <code>fab fa-linkedin</code></li><li>Tumblr: <code>fab fa-tumblr</code></li><li>Medium: <code>fab fa-medium</code></li><li>Slack: <code>fab fa-slack</code></li><li>Sina Weibo: <code>fab fa-weibo</code></li><li>Wechat: <code>fab fa-weixin</code></li><li>QQ: <code>fab fa-qq</code></li><li>Zhihu: <code>fab fa-zhihu</code></li></ul><blockquote><p><strong>注意</strong>: 本主题中使用的 <code>Font Awesome</code> 版本为 <code>5.11.0</code>。</p></blockquote><h3 id="修改打赏的二维码图片-1"><a href="#修改打赏的二维码图片-1" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="配置音乐播放器（可选的）-1"><a href="#配置音乐播放器（可选的）-1" class="headerlink" title="配置音乐播放器（可选的）"></a>配置音乐播放器（可选的）</h3><p>要支持音乐播放，在主题的 <code>_config.yml</code> 配置文件中激活music配置即可：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 是否在首页显示音乐</span><span class="token key atrule">music</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">title</span><span class="token punctuation">:</span>         <span class="token comment"># 非吸底模式有效</span>    <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">show</span><span class="token punctuation">:</span> 听听音乐  <span class="token key atrule">server</span><span class="token punctuation">:</span> netease   <span class="token comment"># require music platform: netease, tencent, kugou, xiami, baidu</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> playlist    <span class="token comment"># require song, playlist, album, search, artist</span>  <span class="token key atrule">id</span><span class="token punctuation">:</span> <span class="token number">503838841</span>     <span class="token comment"># require song id / playlist id / album id / search keyword</span>  <span class="token key atrule">fixed</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>      <span class="token comment"># 开启吸底模式</span>  <span class="token key atrule">autoplay</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>   <span class="token comment"># 是否自动播放</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">'#42b983'</span>  <span class="token key atrule">loop</span><span class="token punctuation">:</span> <span class="token string">'all'</span>       <span class="token comment"># 音频循环播放, 可选值: 'all', 'one', 'none'</span>  <span class="token key atrule">order</span><span class="token punctuation">:</span> <span class="token string">'random'</span>   <span class="token comment"># 音频循环顺序, 可选值: 'list', 'random'</span>  <span class="token key atrule">preload</span><span class="token punctuation">:</span> <span class="token string">'auto'</span>   <span class="token comment"># 预加载，可选值: 'none', 'metadata', 'auto'</span>  <span class="token key atrule">volume</span><span class="token punctuation">:</span> <span class="token number">0.7</span>       <span class="token comment"># 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效</span>  <span class="token key atrule">listFolded</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token comment"># 列表默认折叠</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>server</code>可选 <code>netease</code>（网易云音乐），<code>tencent</code>（QQ音乐），<code>kugou</code>（酷狗音乐），<code>xiami</code>（虾米音乐），</p><p><code>baidu</code>（百度音乐）。</p><p><code>type</code>可选 <code>song</code>（歌曲），<code>playlist</code>（歌单），<code>album</code>（专辑），<code>search</code>（搜索关键字），<code>artist</code>（歌手）</p><p><code>id</code>获取方法示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，浏览器地址栏后面会有一串数字，<code>playlist</code>的 <code>id</code></p><p>即为这串数字。</p></blockquote><h3 id="添加note-1"><a href="#添加note-1" class="headerlink" title="添加note"></a>添加note</h3><blockquote><p><a href="https://blog.17lai.site/posts/cf0f47fd/#tag-note">演示</a></p></blockquote><h4 id="Usage-2"><a href="#Usage-2" class="headerlink" title="Usage"></a>Usage</h4><pre class="line-numbers language-none"><code class="language-none">&#123;% note [class] [no-icon] [summary] %&#125;Any content (support inline tags too).&#123;% endnote %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>[class]</code> : <em>Optional parameter.</em> Supported values: default | primary | success | info | warning | danger.</li><li><code>[no-icon]</code> : <em>Optional parameter.</em> Disable icon in note.</li><li><code>[summary]</code> : <em>Optional parameter.</em> Optional summary of the note.</li></ul><p>All parameters are optional.</p><h4 id="example-1"><a href="#example-1" class="headerlink" title="example"></a>example</h4><pre class="line-numbers language-none"><code class="language-none">&#123;% note %&#125;#### Header(without define class style)&#123;% endnote %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加button-1"><a href="#添加button-1" class="headerlink" title="添加button"></a>添加button</h3><blockquote><p><a href="https://blog.17lai.site/posts/cf0f47fd/#tag-button">演示</a></p></blockquote><h4 id="Usage-3"><a href="#Usage-3" class="headerlink" title="Usage"></a>Usage</h4><pre class="line-numbers language-none"><code class="language-none">&#123;% button url, text, icon [class], [title] %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>or</p><pre class="line-numbers language-none"><code class="language-none">&#123;% btn url, text, icon [class], [title] %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>url</code> : Absolute or relative path to URL.</li><li><code>text</code> : Button text. Required if no icon specified.</li><li><code>icon</code> : Font Awesome icon name. Required if no text specified.</li><li><code>[class]</code> : <em>Optional parameter.</em> Font Awesome class(es): <code>fa-fw</code> | <code>fa-lg</code> | <code>fa-2x</code> | <code>fa-3x</code> | <code>fa-4x</code> | <code>fa-5x</code></li><li><code>[title]</code> : <em>Optional parameter.</em> Tooltip at mouseover.</li></ul><h4 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h4><pre class="line-numbers language-none"><code class="language-none">&#123;% button #, Text %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="文章-Front-matter-介绍-1"><a href="#文章-Front-matter-介绍-1" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解-1"><a href="#Front-matter-选项详解-1" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如:<code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>hide</td><td><code>false</code></td><td>隐藏文章，如果 <code>hide</code>值为 <code>true</code>，则文章不会在首页显示</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2">开源中国在线工具</a>、<a href="http://encode.chahuo.com/">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a>。</li><li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例-1"><a href="#最简示例-1" class="headerlink" title="最简示例"></a>最简示例</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最全示例-1"><a href="#最全示例-1" class="headerlink" title="最全示例"></a>最全示例</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 赵奇<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg<span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">hide</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> /images/1.jpg<span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">summary</span><span class="token punctuation">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<span class="token key atrule">categories</span><span class="token punctuation">:</span> Markdown<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> Typora  <span class="token punctuation">-</span> Markdown<span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="效果截图-1"><a href="#效果截图-1" class="headerlink" title="效果截图"></a>效果截图</h2><p><img src="http://static.blinkfox.com/matery-20181202-1.png" alt="首页"></p><p><img src="http://static.blinkfox.com/matery-20181202-2.png" alt="首页推荐文章"></p><p><img src="http://static.blinkfox.com/matery-20181202-3.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-7.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-8.png" alt="首页文章列表"></p><h2 id="自定制修改-1"><a href="#自定制修改-1" class="headerlink" title="自定制修改"></a>自定制修改</h2><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li><li><a href="http://busuanzi.ibruce.info/">不蒜子统计</a>和谷歌分析（<code>Google Analytics</code>）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图</li></ul><p><strong>我认为个人博客应该都有自己的风格和特色</strong>。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：</p><h3 id="修改主题颜色-1"><a href="#修改主题颜色-1" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h3><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */</span><span class="token selector">.bg-color</span> <span class="token punctuation">&#123;</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>to right<span class="token punctuation">,</span> #4cbf30 0%<span class="token punctuation">,</span> #0f9d58 100%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token atrule"><span class="token rule">@-webkit-keyframes</span> rainbow</span> <span class="token punctuation">&#123;</span>   <span class="token comment">/* 动态切换背景颜色. */</span><span class="token punctuation">&#125;</span><span class="token atrule"><span class="token rule">@keyframes</span> rainbow</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* 动态切换背景颜色. */</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改-banner-图和文章特色图-1"><a href="#修改-banner-图和文章特色图-1" class="headerlink" title="修改 banner 图和文章特色图"></a>修改 banner 图和文章特色图</h3><p>你可以直接在 <code>/source/medias/banner</code> 文件夹中更换你喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果你会 <code>JavaScript</code> 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.bg-cover'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'background-image'</span><span class="token punctuation">,</span> <span class="token string">'url(/medias/banner/'</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.jpg)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p><h2 id="版本变更记录-1"><a href="#版本变更记录-1" class="headerlink" title="版本变更记录"></a>版本变更记录</h2><p>参见 <a href="https://github.com/blinkfox/hexo-theme-matery/blob/master/CHANGELOG.md">CHANGELOG.md</a></p><h2 id="更多部署方式-1"><a href="#更多部署方式-1" class="headerlink" title="更多部署方式"></a>更多部署方式</h2><blockquote><p>Jsdelivr 已经被封了，这两个可以加速访问快一点</p></blockquote><h3 id="vercel-部署-1"><a href="#vercel-部署-1" class="headerlink" title="vercel 部署"></a><a href="https://blog.17lai.site/posts/5311b619/#vercel-%E9%83%A8%E7%BD%B2">vercel 部署</a></h3><h3 id="cloudflare-Pages-部署-1"><a href="#cloudflare-Pages-部署-1" class="headerlink" title="cloudflare Pages 部署"></a><a href="https://blog.17lai.site/posts/5311b619/#cloudflare-Pages-%E9%83%A8%E7%BD%B2">cloudflare Pages 部署</a></h3><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>fb72dae14cd9e0db202a1bf72852d247dcc943c9:source&#x2F;_posts&#x2F;trick&#x2F;matery食用指南.md</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>飞书ChatGPTBot使用指南</title>
      <link href="/article/b5c3f382.html"/>
      <url>/article/b5c3f382.html</url>
      
        <content type="html"><![CDATA[<p align="center">   飞书 ×（GPT-3.5 + DALL·E + Whisper）<br><br>    🚀 Feishu OpenAI 🚀</p><h2 id="👻-机器人功能"><a href="#👻-机器人功能" class="headerlink" title="👻 机器人功能"></a>👻 机器人功能</h2><p>🗣 语音交流：私人直接与机器人畅所欲言</p><p>💬 多话题对话：支持私人和群聊多话题讨论，高效连贯</p><p>🖼 文本成图：支持文本成图和以图搜图</p><p>🛖 场景预设：内置丰富场景列表，一键切换AI角色</p><p>🎭 角色扮演：支持场景模式，增添讨论乐趣和创意</p><p>🔄 上下文保留：回复对话框即可继续同一话题讨论</p><p>⏰ 自动结束：超时自动结束对话，支持清除讨论历史</p><p>📝 富文本卡片：支持富文本卡片回复，信息更丰富多彩</p><p>👍 交互式反馈：即时获取机器人处理结果</p><h2 id="🚩关于本项目"><a href="#🚩关于本项目" class="headerlink" title="🚩关于本项目"></a>🚩关于本项目</h2><p><a href="https://github.com/Leizhenpeng/feishu-chatgpt/blob/master/readme.md">feishu-chatgpt</a></p>]]></content>
      
      
      <categories>
          
          <category> Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 飞书机器人 </tag>
            
            <tag> GPT </tag>
            
            <tag> Engineering </tag>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Alpaca Plan</title>
      <link href="/article/bf637e11.html"/>
      <url>/article/bf637e11.html</url>
      
        <content type="html"><![CDATA[<h1 id="Alpaca-Plan"><a href="#Alpaca-Plan" class="headerlink" title="Alpaca Plan"></a>Alpaca Plan</h1><h2 id="1-如何在本地电脑（配置：3060desktop）训练这个URL（https-github-c…"><a href="#1-如何在本地电脑（配置：3060desktop）训练这个URL（https-github-c…" class="headerlink" title="1. 如何在本地电脑（配置：3060desktop）训练这个URL（https://github.c…"></a>1. 如何在本地电脑（配置：3060desktop）训练这个URL（<a href="https://github.c/">https://github.c</a>…</h2><h3 id="User"><a href="#User" class="headerlink" title="User"></a>User</h3><p>如何在本地电脑（配置：3060desktop）训练这个URL（<a href="https://github.com/tatsu-lab/stanford_alpaca%EF%BC%89%E4%B8%AD%E7%9A%84alpaca%E6%A8%A1%E5%9E%8B%EF%BC%8C%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BD%BF%E7%94%A8%E6%89%98%E7%A6%8F%E7%9A%84%E5%8F%A3%E8%AF%AD%E8%80%83%E8%AF%95%E8%B5%84%E6%96%99%EF%BC%8C%E8%AE%AD%E7%BB%83%E5%87%BA%E4%B8%80%E4%B8%AA%E6%A8%A1%E4%BB%BF%E6%89%98%E7%A6%8F%E5%8F%A3%E8%AF%AD%E8%80%83%E5%AE%98%E7%9A%84%E6%A8%A1%E5%9E%8B%EF%BC%8C%E8%AF%B7%E7%BB%99%E5%87%BA%E6%AD%A5%E9%AA%A4">https://github.com/tatsu-lab/stanford_alpaca）中的alpaca模型，目的是使用托福的口语考试资料，训练出一个模仿托福口语考官的模型，请给出步骤</a></p><h3 id="ChatGPT"><a href="#ChatGPT" class="headerlink" title="ChatGPT"></a>ChatGPT</h3><p>要在本地电脑（配置：3060desktop）上训练此 GitHub 仓库（<a href="https://github.com/tatsu-lab/stanford_alpaca%EF%BC%89%E4%B8%AD%E7%9A%84">https://github.com/tatsu-lab/stanford_alpaca）中的</a> ALPACA 模型并用托福口语考试资料训练一个模仿托福口语考官的模型，请按照以下步骤操作：</p><ol><li><p>安装所需软件：<br>首先确保您已经安装了以下软件：</p><ul><li>Python 3.6 或更高版本</li><li>Git</li><li>NVIDIA GPU 驱动和 CUDA 工具包（适用于您的 3060 显卡）</li></ul></li><li><p>克隆 GitHub 仓库：<br>在终端中运行以下命令以克隆 ALPACA 项目的 GitHub 仓库：</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;tatsu-lab&#x2F;stanford_alpaca.gitcd stanford_alpaca<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>创建虚拟环境并安装依赖：</p><pre class="line-numbers language-none"><code class="language-none">python -m venv venvsource venv&#x2F;bin&#x2F;activate  # 在 Windows 上使用 &quot;venv\Scripts\activate&quot;pip install -r requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>准备托福口语考试资料：<br>将您的托福口语考试资料整理成与 ALPACA 项目兼容的格式。您可能需要将数据划分为训练、验证和测试集，同时确保文本数据为纯文本文件（.txt 格式）。如果您的数据集包含音频文件，您可能需要将其转换为与项目兼容的格式（例如，WAV 或 MP3）。</p></li><li><p>预处理数据：<br>使用项目中提供的预处理脚本将您的托福口语数据转换为模型可以使用的格式。具体细节请参考项目的 README 文档和相关代码。</p></li><li><p>训练模型：<br>使用项目中提供的训练脚本和适当的命令行参数训练您的 ALPACA 模型。在训练期间，请密切关注训练损失、验证损失和其他性能指标。您可能需要尝试不同的超参数设置以获得最佳性能。</p></li><li><p>评估模型：<br>使用项目中提供的评估脚本对您的模型进行评估。这将帮助您了解模型在托福口语考试资料上的表现。</p></li><li><p>使用模型：<br>在完成训练和评估之后，您可以使用您的模型生成类似于托福口语考官的输出。具体操作请参考项目的 README 文档和相关代码。</p></li></ol><p>这些步骤应该帮助您在本地电脑上训练一个模仿托福口语考官的 ALPACA 模型。注意，具体实现可能需要根据您的数据和项目需求进行调整。祝</p><hr><h2 id="2-请详细介绍有关预处理数据和训练模型的步骤操作"><a href="#2-请详细介绍有关预处理数据和训练模型的步骤操作" class="headerlink" title="2. 请详细介绍有关预处理数据和训练模型的步骤操作"></a>2. 请详细介绍有关预处理数据和训练模型的步骤操作</h2><h3 id="User-1"><a href="#User-1" class="headerlink" title="User"></a>User</h3><p>请详细介绍有关预处理数据和训练模型的步骤操作</p><h3 id="ChatGPT-1"><a href="#ChatGPT-1" class="headerlink" title="ChatGPT"></a>ChatGPT</h3><p>我将为您详细介绍预处理数据和训练模型的步骤操作。请注意，这里的指南是基于 ALPACA 项目的结构和代码，但您可能需要根据您的数据和项目需求进行调整。</p><p>预处理数据：</p><ol><li><p>整理数据集：确保您的数据集已划分为训练、验证和测试集。这通常需要您将原始数据集按比例（例如，80%训练、10%验证、10%测试）划分为三个独立的子集。</p></li><li><p>文本数据预处理：对于纯文本文件，您需要执行以下预处理操作：</p><ul><li>删除多余的空格、换行符等。</li><li>对文本进行标准化，例如将所有字符转换为小写、替换特殊字符等。</li><li>将文本分割成句子或其他合适的单元。</li><li>对于需要转换为音频特征的文本，您可能需要使用一个文本到音频的工具（如 TTS 系统）。</li></ul></li><li><p>音频数据预处理：对于音频文件，您需要执行以下预处理操作：</p><ul><li>将音频转换为与项目兼容的格式，如单声道、16kHz 采样率的 WAV 文件。</li><li>提取音频特征，如 Mel 频谱图或 MFCC。这可能需要使用一个音频处理库，如 librosa。</li><li>对音频特征进行归一化，以便在训练过程中提高数值稳定性。</li></ul></li><li><p>生成数据文件：将预处理后的文本和音频数据保存为与 ALPACA 项目兼容的文件格式。这可能包括创建用于训练、验证和测试的单独文件，其中包含每个数据样本的音频特征和相应的文本标签。</p></li></ol><p>训练模型：</p><ol><li><p>确保您已安装所有必要的依赖项并成功激活虚拟环境。此外，请确保您已正确设置训练、验证和测试数据文件。</p></li><li><p>查看项目中提供的训练脚本。这可能是一个 Python 文件或 Jupyter 笔记本。在这个脚本中，您应该找到以下部分：</p><ul><li>超参数设置：这可能包括学习率、批次大小、训练迭代次数等。</li><li>数据加载器：用于读取和批量处理训练、验证和测试数据。</li><li>模型定义：包括模型结构、损失函数和优化器。</li><li>训练循环：包括在每个训练迭代中执行前向传播、计算损失、执行反向传播和更新模型权重的逻辑。</li></ul></li><li><p>根据您的数据和硬件需求调整超参数设置。这可能包括更改学习率、批次大小、训练迭</p></li></ol><hr><h2 id="3-继续"><a href="#3-继续" class="headerlink" title="3. 继续"></a>3. 继续</h2><h3 id="User-2"><a href="#User-2" class="headerlink" title="User"></a>User</h3><p>继续</p><h3 id="ChatGPT-2"><a href="#ChatGPT-2" class="headerlink" title="ChatGPT"></a>ChatGPT</h3><p>续训练模型：</p><ol start="3"><li>根据您的数据和硬件需求调整超参数设置。这可能包括更改学习率、批次大小、训练迭代次数等。对于初次尝试，您可以使用项目提供的默认参数，然后根据训练和验证性能进行调整。</li><li>运行训练脚本：在终端或 Jupyter 笔记本中执行训练脚本。在训练过程中，请密切关注训练损失、验证损失和其他性能指标。如果您发现训练过程中性能停滞不前或出现过拟合，您可能需要调整超参数或尝试其他优化技术。</li><li>保存训练的模型权重：在训练过程结束后，您需要保存模型权重以便后续使用。通常，项目提供的训练脚本会自动执行此操作。如果需要手动保存模型权重，您可以使用 PyTorch 的 <code>torch.save</code> 或 TensorFlow 的 <code>model.save</code> 函数。</li><li>调整和优化：根据您的训练和验证结果，您可能需要对模型进行调整和优化。这可能包括更改模型结构、添加正则化技术（如 dropout 或权重衰减）或使用不同的优化器。持续调整和优化直到您对模型的性能满意为止。</li><li>评估模型：使用项目中提供的评估脚本对训练好的模型进行评估。这将帮助您了解模型在托福口语考试资料上的表现。确保在测试集上进行评估，以获得对模型在未见过的数据上的性能的公正估计。</li></ol><p>这些步骤应该帮助您在本地电脑上训练一个模仿托福口语考官的 ALPACA 模型。注意，具体实现可能需要根据您的数据和项目需求进行调整。祝您训练顺利！</p><hr><h2 id="4-如果我想根据此模型搭建一个web服务（形式为飞书的机器人服务，服务器是Ubuntu或者Cent…"><a href="#4-如果我想根据此模型搭建一个web服务（形式为飞书的机器人服务，服务器是Ubuntu或者Cent…" class="headerlink" title="4. 如果我想根据此模型搭建一个web服务（形式为飞书的机器人服务，服务器是Ubuntu或者Cent…"></a>4. 如果我想根据此模型搭建一个web服务（形式为飞书的机器人服务，服务器是Ubuntu或者Cent…</h2><h3 id="User-3"><a href="#User-3" class="headerlink" title="User"></a>User</h3><p>如果我想根据此模型搭建一个web服务（形式为飞书的机器人服务，服务器是Ubuntu或者Centos），需要保存用户历史数据，可能会遇到高并发情况，后续可能需要加入微信支付和支付宝支付的收费功能，编程语言可以是python和golang，请给出实现步骤</p><h3 id="ChatGPT-3"><a href="#ChatGPT-3" class="headerlink" title="ChatGPT"></a>ChatGPT</h3><p>要根据此模型搭建一个飞书机器人服务，可参考以下步骤。请注意，这些步骤是通用的，您可能需要根据您的具体需求进行调整。</p><ol><li><p>将模型部署为API服务：<br>使用 FastAPI 或 Flask（Python）或 Gin（Golang）等Web框架，将您的模型部署为 REST API 服务。首先，创建一个用于处理模型预测请求的端点，然后加载训练好的模型权重。收到请求时，解析请求中的输入数据，将其传递给模型，然后将预测结果作为响应返回。</p></li><li><p>飞书机器人开发：<br>遵循飞书机器人开发文档，创建一个新的飞书机器人并获取相应的API密钥和Webhook。实现一个接收并处理飞书机器人消息的端点。当收到消息时，将消息内容发送到您在步骤1中创建的模型API服务。接收到API服务的响应后，将预测结果作为回复消息发送回飞书机器人。</p></li><li><p>保存用户历史数据：<br>使用数据库（如 PostgreSQL、MySQL 或 SQLite）存储用户历史数据。当用户与飞书机器人互动时，将相关数据（如用户ID、消息内容和时间戳）保存到数据库中。您还可以考虑使用缓存（如 Redis）来提高高并发情况下的性能。</p></li><li><p>处理高并发：<br>为了应对高并发，可以采用以下策略：</p><ul><li>使用负载均衡器（如 Nginx）分发请求到多个服务器实例。</li><li>将模型服务部署在容器化环境（如 Docker 和 Kubernetes）中，以便在需要时自动扩展。</li><li>优化API服务和数据库性能，以降低响应时间。</li></ul></li><li><p>集成支付功能：<br>要集成微信支付和支付宝支付功能，您需要：</p><ul><li>在微信和支付宝开放平台上注册开发者账号，并获取相应的 API 密钥。</li><li>遵循微信支付和支付宝支付的 API 文档，实现支付请求、回调处理和订单状态查询等功能。</li><li>将支付功能与您的飞书机器人服务集成，例如，通过发送带有支付链接的消息。</li></ul></li><li><p>部署到服务器：<br>将您的飞书机器人服务、模型API服务和数据库部署到您选择的 Ubuntu 或 CentOS 服务器上。可以使用诸如 PM2、Gunicorn 或 Systemd 等工具将您的服务作为守护进程运行。同时，确保配置了适当的防火墙规则和安全设置。</p></li></ol><p>这些步骤应该帮助您实现一个基于 ALPACA 模型的飞书机器人服务。</p><hr><h2 id="5-请分析这个项目的难点都有哪些，对于一个大学生团队来说，请设计一个可供实施的1个月可以上线服务的…"><a href="#5-请分析这个项目的难点都有哪些，对于一个大学生团队来说，请设计一个可供实施的1个月可以上线服务的…" class="headerlink" title="5. 请分析这个项目的难点都有哪些，对于一个大学生团队来说，请设计一个可供实施的1个月可以上线服务的…"></a>5. 请分析这个项目的难点都有哪些，对于一个大学生团队来说，请设计一个可供实施的1个月可以上线服务的…</h2><h3 id="User-4"><a href="#User-4" class="headerlink" title="User"></a>User</h3><p>请分析这个项目的难点都有哪些，对于一个大学生团队来说，请设计一个可供实施的1个月可以上线服务的计划，项目团队目前只有两个人</p><h3 id="ChatGPT-4"><a href="#ChatGPT-4" class="headerlink" title="ChatGPT"></a>ChatGPT</h3><p>针对这个项目，以下是一些可能的难点：</p><ol><li>数据预处理和格式转换：将托福口语考试资料转换为与ALPACA项目兼容的格式可能需要时间和技能。</li><li>模型调优：为了实现较好的性能，您可能需要进行多次尝试以调整超参数和模型结构。</li><li>高并发处理：针对高并发情况进行优化可能需要深入了解网络编程、数据库优化和缓存策略。</li><li>集成支付功能：集成微信支付和支付宝支付可能需要理解和遵循相应的API文档。</li><li>服务器部署和管理：部署和管理服务器可能需要对Linux系统管理和网络配置有一定了解。</li></ol><p>针对一个由两名大学生组成的团队，以下是一个可实施的1个月上线计划：</p><ol><li><p>第一周：数据准备和模型训练</p><ul><li>收集和整理托福口语考试资料</li><li>预处理数据并转换为ALPACA项目所需的格式</li><li>使用本地电脑或云服务器训练模型，并进行初步评估</li></ul></li><li><p>第二周：模型部署和飞书机器人开发</p><ul><li>使用FastAPI或Flask等框架将模型部署为API服务</li><li>开发飞书机器人，并将其与模型API服务集成</li><li>设置数据库以存储用户历史数据</li></ul></li><li><p>第三周：高并发优化和支付功能集成</p><ul><li>优化API服务和数据库性能，以提高高并发情况下的响应速度</li><li>实现微信支付和支付宝支付功能，并与飞书机器人服务集成</li></ul></li><li><p>第四周：部署、测试和上线</p><ul><li>将所有服务部署到Ubuntu或CentOS服务器上</li><li>对整个系统进行详细测试，包括功能测试、性能测试和压力测试</li><li>修复测试过程中发现的问题，并准备正式上线</li></ul></li></ol><p>请注意，这个计划可能需要根据实际情况进行调整。在整个项目过程中，请确保团队成员之间保持良好的沟通，并定期检查项目进度。祝您的项目成功！</p><hr><h2 id="6-请分析训练该模型可能需要的成本，包括后期的服务器维护等开销，如果将其作为创业项目，想要实现盈利…"><a href="#6-请分析训练该模型可能需要的成本，包括后期的服务器维护等开销，如果将其作为创业项目，想要实现盈利…" class="headerlink" title="6. 请分析训练该模型可能需要的成本，包括后期的服务器维护等开销，如果将其作为创业项目，想要实现盈利…"></a>6. 请分析训练该模型可能需要的成本，包括后期的服务器维护等开销，如果将其作为创业项目，想要实现盈利…</h2><h3 id="User-5"><a href="#User-5" class="headerlink" title="User"></a>User</h3><p>请分析训练该模型可能需要的成本，包括后期的服务器维护等开销，如果将其作为创业项目，想要实现盈利的话，关于用户的支付策略可以有什么实现</p><h3 id="ChatGPT-5"><a href="#ChatGPT-5" class="headerlink" title="ChatGPT"></a>ChatGPT</h3><p>训练模型和维护服务器的成本因多种因素而异，包括硬件、云服务提供商、数据存储和传输等。以下是一些可能的成本因素：</p><ol><li><p>训练成本：</p><ul><li>云服务器成本：如果在云端训练模型（如AWS、GCP或Azure），需要考虑GPU实例的成本。价格根据实例类型、地区和使用时长而异。</li><li>本地硬件成本：如果使用本地电脑训练，需要考虑购买高性能GPU、CPU和足够内存的成本。</li></ul></li><li><p>服务器维护成本：</p><ul><li>云服务器成本：用于部署API服务、飞书机器人和数据库的云服务器成本。可以选择按需付费或预留实例以节省成本。</li><li>数据存储和传输成本：数据库存储、备份和传输数据产生的费用。</li><li>域名和SSL证书：购买和续费域名及SSL证书的费用。</li></ul></li><li><p>其他成本：</p><ul><li>开发人员薪资：开发、部署和维护项目的人力成本。</li><li>软件许可和API费用：使用付费软件、API或服务的费用。</li><li>市场营销和用户支持：推广项目和提供用户支持的成本。</li></ul></li></ol><p>关于用户支付策略，以下是一些建议：</p><ol><li>订阅制：按月或年收取订阅费，用户在订阅期内可以无限次使用服务。可以提供不同级别的订阅套餐，以满足不同用户需求。</li><li>付费次数：用户每次使用服务时支付一定费用。可以设定不同的价格区间，根据服务的复杂性或所需资源收费。</li><li>免费试用：为吸引用户，提供免费试用期。试用期结束后，用户需要支付订阅费或按次数付费才能继续使用服务。</li><li>组合套餐：为不同类型的用户提供定制套餐，包括一次性付费、按需付费和订阅制等多种支付方式的组合。</li><li>企业版和团体折扣：针对企业和团体客户提供特殊价格和定制服务。</li></ol><p>为确保项目盈利，请根据实际成本和市场需求合理制定价格策略。同时，关注用户反馈和行业动态，以调整和优化支付策略。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
            <tag> Commercial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Alpaca Plan</title>
      <link href="/article/bf637e11.html"/>
      <url>/article/bf637e11.html</url>
      
        <content type="html"><![CDATA[<h1 id="Alpaca-Plan"><a href="#Alpaca-Plan" class="headerlink" title="Alpaca Plan"></a>Alpaca Plan</h1><h2 id="1-如何在本地电脑（配置：3060desktop）训练这个URL（https-github-c…"><a href="#1-如何在本地电脑（配置：3060desktop）训练这个URL（https-github-c…" class="headerlink" title="1. 如何在本地电脑（配置：3060desktop）训练这个URL（https://github.c…"></a>1. 如何在本地电脑（配置：3060desktop）训练这个URL（<a href="https://github.c/">https://github.c</a>…</h2><h3 id="User"><a href="#User" class="headerlink" title="User"></a>User</h3><p>如何在本地电脑（配置：3060desktop）训练这个URL（<a href="https://github.com/tatsu-lab/stanford_alpaca%EF%BC%89%E4%B8%AD%E7%9A%84alpaca%E6%A8%A1%E5%9E%8B%EF%BC%8C%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BD%BF%E7%94%A8%E6%89%98%E7%A6%8F%E7%9A%84%E5%8F%A3%E8%AF%AD%E8%80%83%E8%AF%95%E8%B5%84%E6%96%99%EF%BC%8C%E8%AE%AD%E7%BB%83%E5%87%BA%E4%B8%80%E4%B8%AA%E6%A8%A1%E4%BB%BF%E6%89%98%E7%A6%8F%E5%8F%A3%E8%AF%AD%E8%80%83%E5%AE%98%E7%9A%84%E6%A8%A1%E5%9E%8B%EF%BC%8C%E8%AF%B7%E7%BB%99%E5%87%BA%E6%AD%A5%E9%AA%A4">https://github.com/tatsu-lab/stanford_alpaca）中的alpaca模型，目的是使用托福的口语考试资料，训练出一个模仿托福口语考官的模型，请给出步骤</a></p><h3 id="ChatGPT"><a href="#ChatGPT" class="headerlink" title="ChatGPT"></a>ChatGPT</h3><p>要在本地电脑（配置：3060desktop）上训练此 GitHub 仓库（<a href="https://github.com/tatsu-lab/stanford_alpaca%EF%BC%89%E4%B8%AD%E7%9A%84">https://github.com/tatsu-lab/stanford_alpaca）中的</a> ALPACA 模型并用托福口语考试资料训练一个模仿托福口语考官的模型，请按照以下步骤操作：</p><ol><li><p>安装所需软件：<br>首先确保您已经安装了以下软件：</p><ul><li>Python 3.6 或更高版本</li><li>Git</li><li>NVIDIA GPU 驱动和 CUDA 工具包（适用于您的 3060 显卡）</li></ul></li><li><p>克隆 GitHub 仓库：<br>在终端中运行以下命令以克隆 ALPACA 项目的 GitHub 仓库：</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;tatsu-lab&#x2F;stanford_alpaca.gitcd stanford_alpaca<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>创建虚拟环境并安装依赖：</p><pre class="line-numbers language-none"><code class="language-none">python -m venv venvsource venv&#x2F;bin&#x2F;activate  # 在 Windows 上使用 &quot;venv\Scripts\activate&quot;pip install -r requirements.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>准备托福口语考试资料：<br>将您的托福口语考试资料整理成与 ALPACA 项目兼容的格式。您可能需要将数据划分为训练、验证和测试集，同时确保文本数据为纯文本文件（.txt 格式）。如果您的数据集包含音频文件，您可能需要将其转换为与项目兼容的格式（例如，WAV 或 MP3）。</p></li><li><p>预处理数据：<br>使用项目中提供的预处理脚本将您的托福口语数据转换为模型可以使用的格式。具体细节请参考项目的 README 文档和相关代码。</p></li><li><p>训练模型：<br>使用项目中提供的训练脚本和适当的命令行参数训练您的 ALPACA 模型。在训练期间，请密切关注训练损失、验证损失和其他性能指标。您可能需要尝试不同的超参数设置以获得最佳性能。</p></li><li><p>评估模型：<br>使用项目中提供的评估脚本对您的模型进行评估。这将帮助您了解模型在托福口语考试资料上的表现。</p></li><li><p>使用模型：<br>在完成训练和评估之后，您可以使用您的模型生成类似于托福口语考官的输出。具体操作请参考项目的 README 文档和相关代码。</p></li></ol><p>这些步骤应该帮助您在本地电脑上训练一个模仿托福口语考官的 ALPACA 模型。注意，具体实现可能需要根据您的数据和项目需求进行调整。祝</p><hr><h2 id="2-请详细介绍有关预处理数据和训练模型的步骤操作"><a href="#2-请详细介绍有关预处理数据和训练模型的步骤操作" class="headerlink" title="2. 请详细介绍有关预处理数据和训练模型的步骤操作"></a>2. 请详细介绍有关预处理数据和训练模型的步骤操作</h2><h3 id="User-1"><a href="#User-1" class="headerlink" title="User"></a>User</h3><p>请详细介绍有关预处理数据和训练模型的步骤操作</p><h3 id="ChatGPT-1"><a href="#ChatGPT-1" class="headerlink" title="ChatGPT"></a>ChatGPT</h3><p>我将为您详细介绍预处理数据和训练模型的步骤操作。请注意，这里的指南是基于 ALPACA 项目的结构和代码，但您可能需要根据您的数据和项目需求进行调整。</p><p>预处理数据：</p><ol><li><p>整理数据集：确保您的数据集已划分为训练、验证和测试集。这通常需要您将原始数据集按比例（例如，80%训练、10%验证、10%测试）划分为三个独立的子集。</p></li><li><p>文本数据预处理：对于纯文本文件，您需要执行以下预处理操作：</p><ul><li>删除多余的空格、换行符等。</li><li>对文本进行标准化，例如将所有字符转换为小写、替换特殊字符等。</li><li>将文本分割成句子或其他合适的单元。</li><li>对于需要转换为音频特征的文本，您可能需要使用一个文本到音频的工具（如 TTS 系统）。</li></ul></li><li><p>音频数据预处理：对于音频文件，您需要执行以下预处理操作：</p><ul><li>将音频转换为与项目兼容的格式，如单声道、16kHz 采样率的 WAV 文件。</li><li>提取音频特征，如 Mel 频谱图或 MFCC。这可能需要使用一个音频处理库，如 librosa。</li><li>对音频特征进行归一化，以便在训练过程中提高数值稳定性。</li></ul></li><li><p>生成数据文件：将预处理后的文本和音频数据保存为与 ALPACA 项目兼容的文件格式。这可能包括创建用于训练、验证和测试的单独文件，其中包含每个数据样本的音频特征和相应的文本标签。</p></li></ol><p>训练模型：</p><ol><li><p>确保您已安装所有必要的依赖项并成功激活虚拟环境。此外，请确保您已正确设置训练、验证和测试数据文件。</p></li><li><p>查看项目中提供的训练脚本。这可能是一个 Python 文件或 Jupyter 笔记本。在这个脚本中，您应该找到以下部分：</p><ul><li>超参数设置：这可能包括学习率、批次大小、训练迭代次数等。</li><li>数据加载器：用于读取和批量处理训练、验证和测试数据。</li><li>模型定义：包括模型结构、损失函数和优化器。</li><li>训练循环：包括在每个训练迭代中执行前向传播、计算损失、执行反向传播和更新模型权重的逻辑。</li></ul></li><li><p>根据您的数据和硬件需求调整超参数设置。这可能包括更改学习率、批次大小、训练迭</p></li></ol><hr><h2 id="3-继续"><a href="#3-继续" class="headerlink" title="3. 继续"></a>3. 继续</h2><h3 id="User-2"><a href="#User-2" class="headerlink" title="User"></a>User</h3><p>继续</p><h3 id="ChatGPT-2"><a href="#ChatGPT-2" class="headerlink" title="ChatGPT"></a>ChatGPT</h3><p>续训练模型：</p><ol start="3"><li>根据您的数据和硬件需求调整超参数设置。这可能包括更改学习率、批次大小、训练迭代次数等。对于初次尝试，您可以使用项目提供的默认参数，然后根据训练和验证性能进行调整。</li><li>运行训练脚本：在终端或 Jupyter 笔记本中执行训练脚本。在训练过程中，请密切关注训练损失、验证损失和其他性能指标。如果您发现训练过程中性能停滞不前或出现过拟合，您可能需要调整超参数或尝试其他优化技术。</li><li>保存训练的模型权重：在训练过程结束后，您需要保存模型权重以便后续使用。通常，项目提供的训练脚本会自动执行此操作。如果需要手动保存模型权重，您可以使用 PyTorch 的 <code>torch.save</code> 或 TensorFlow 的 <code>model.save</code> 函数。</li><li>调整和优化：根据您的训练和验证结果，您可能需要对模型进行调整和优化。这可能包括更改模型结构、添加正则化技术（如 dropout 或权重衰减）或使用不同的优化器。持续调整和优化直到您对模型的性能满意为止。</li><li>评估模型：使用项目中提供的评估脚本对训练好的模型进行评估。这将帮助您了解模型在托福口语考试资料上的表现。确保在测试集上进行评估，以获得对模型在未见过的数据上的性能的公正估计。</li></ol><p>这些步骤应该帮助您在本地电脑上训练一个模仿托福口语考官的 ALPACA 模型。注意，具体实现可能需要根据您的数据和项目需求进行调整。祝您训练顺利！</p><hr><h2 id="4-如果我想根据此模型搭建一个web服务（形式为飞书的机器人服务，服务器是Ubuntu或者Cent…"><a href="#4-如果我想根据此模型搭建一个web服务（形式为飞书的机器人服务，服务器是Ubuntu或者Cent…" class="headerlink" title="4. 如果我想根据此模型搭建一个web服务（形式为飞书的机器人服务，服务器是Ubuntu或者Cent…"></a>4. 如果我想根据此模型搭建一个web服务（形式为飞书的机器人服务，服务器是Ubuntu或者Cent…</h2><h3 id="User-3"><a href="#User-3" class="headerlink" title="User"></a>User</h3><p>如果我想根据此模型搭建一个web服务（形式为飞书的机器人服务，服务器是Ubuntu或者Centos），需要保存用户历史数据，可能会遇到高并发情况，后续可能需要加入微信支付和支付宝支付的收费功能，编程语言可以是python和golang，请给出实现步骤</p><h3 id="ChatGPT-3"><a href="#ChatGPT-3" class="headerlink" title="ChatGPT"></a>ChatGPT</h3><p>要根据此模型搭建一个飞书机器人服务，可参考以下步骤。请注意，这些步骤是通用的，您可能需要根据您的具体需求进行调整。</p><ol><li><p>将模型部署为API服务：<br>使用 FastAPI 或 Flask（Python）或 Gin（Golang）等Web框架，将您的模型部署为 REST API 服务。首先，创建一个用于处理模型预测请求的端点，然后加载训练好的模型权重。收到请求时，解析请求中的输入数据，将其传递给模型，然后将预测结果作为响应返回。</p></li><li><p>飞书机器人开发：<br>遵循飞书机器人开发文档，创建一个新的飞书机器人并获取相应的API密钥和Webhook。实现一个接收并处理飞书机器人消息的端点。当收到消息时，将消息内容发送到您在步骤1中创建的模型API服务。接收到API服务的响应后，将预测结果作为回复消息发送回飞书机器人。</p></li><li><p>保存用户历史数据：<br>使用数据库（如 PostgreSQL、MySQL 或 SQLite）存储用户历史数据。当用户与飞书机器人互动时，将相关数据（如用户ID、消息内容和时间戳）保存到数据库中。您还可以考虑使用缓存（如 Redis）来提高高并发情况下的性能。</p></li><li><p>处理高并发：<br>为了应对高并发，可以采用以下策略：</p><ul><li>使用负载均衡器（如 Nginx）分发请求到多个服务器实例。</li><li>将模型服务部署在容器化环境（如 Docker 和 Kubernetes）中，以便在需要时自动扩展。</li><li>优化API服务和数据库性能，以降低响应时间。</li></ul></li><li><p>集成支付功能：<br>要集成微信支付和支付宝支付功能，您需要：</p><ul><li>在微信和支付宝开放平台上注册开发者账号，并获取相应的 API 密钥。</li><li>遵循微信支付和支付宝支付的 API 文档，实现支付请求、回调处理和订单状态查询等功能。</li><li>将支付功能与您的飞书机器人服务集成，例如，通过发送带有支付链接的消息。</li></ul></li><li><p>部署到服务器：<br>将您的飞书机器人服务、模型API服务和数据库部署到您选择的 Ubuntu 或 CentOS 服务器上。可以使用诸如 PM2、Gunicorn 或 Systemd 等工具将您的服务作为守护进程运行。同时，确保配置了适当的防火墙规则和安全设置。</p></li></ol><p>这些步骤应该帮助您实现一个基于 ALPACA 模型的飞书机器人服务。</p><hr><h2 id="5-请分析这个项目的难点都有哪些，对于一个大学生团队来说，请设计一个可供实施的1个月可以上线服务的…"><a href="#5-请分析这个项目的难点都有哪些，对于一个大学生团队来说，请设计一个可供实施的1个月可以上线服务的…" class="headerlink" title="5. 请分析这个项目的难点都有哪些，对于一个大学生团队来说，请设计一个可供实施的1个月可以上线服务的…"></a>5. 请分析这个项目的难点都有哪些，对于一个大学生团队来说，请设计一个可供实施的1个月可以上线服务的…</h2><h3 id="User-4"><a href="#User-4" class="headerlink" title="User"></a>User</h3><p>请分析这个项目的难点都有哪些，对于一个大学生团队来说，请设计一个可供实施的1个月可以上线服务的计划，项目团队目前只有两个人</p><h3 id="ChatGPT-4"><a href="#ChatGPT-4" class="headerlink" title="ChatGPT"></a>ChatGPT</h3><p>针对这个项目，以下是一些可能的难点：</p><ol><li>数据预处理和格式转换：将托福口语考试资料转换为与ALPACA项目兼容的格式可能需要时间和技能。</li><li>模型调优：为了实现较好的性能，您可能需要进行多次尝试以调整超参数和模型结构。</li><li>高并发处理：针对高并发情况进行优化可能需要深入了解网络编程、数据库优化和缓存策略。</li><li>集成支付功能：集成微信支付和支付宝支付可能需要理解和遵循相应的API文档。</li><li>服务器部署和管理：部署和管理服务器可能需要对Linux系统管理和网络配置有一定了解。</li></ol><p>针对一个由两名大学生组成的团队，以下是一个可实施的1个月上线计划：</p><ol><li><p>第一周：数据准备和模型训练</p><ul><li>收集和整理托福口语考试资料</li><li>预处理数据并转换为ALPACA项目所需的格式</li><li>使用本地电脑或云服务器训练模型，并进行初步评估</li></ul></li><li><p>第二周：模型部署和飞书机器人开发</p><ul><li>使用FastAPI或Flask等框架将模型部署为API服务</li><li>开发飞书机器人，并将其与模型API服务集成</li><li>设置数据库以存储用户历史数据</li></ul></li><li><p>第三周：高并发优化和支付功能集成</p><ul><li>优化API服务和数据库性能，以提高高并发情况下的响应速度</li><li>实现微信支付和支付宝支付功能，并与飞书机器人服务集成</li></ul></li><li><p>第四周：部署、测试和上线</p><ul><li>将所有服务部署到Ubuntu或CentOS服务器上</li><li>对整个系统进行详细测试，包括功能测试、性能测试和压力测试</li><li>修复测试过程中发现的问题，并准备正式上线</li></ul></li></ol><p>请注意，这个计划可能需要根据实际情况进行调整。在整个项目过程中，请确保团队成员之间保持良好的沟通，并定期检查项目进度。祝您的项目成功！</p><hr><h2 id="6-请分析训练该模型可能需要的成本，包括后期的服务器维护等开销，如果将其作为创业项目，想要实现盈利…"><a href="#6-请分析训练该模型可能需要的成本，包括后期的服务器维护等开销，如果将其作为创业项目，想要实现盈利…" class="headerlink" title="6. 请分析训练该模型可能需要的成本，包括后期的服务器维护等开销，如果将其作为创业项目，想要实现盈利…"></a>6. 请分析训练该模型可能需要的成本，包括后期的服务器维护等开销，如果将其作为创业项目，想要实现盈利…</h2><h3 id="User-5"><a href="#User-5" class="headerlink" title="User"></a>User</h3><p>请分析训练该模型可能需要的成本，包括后期的服务器维护等开销，如果将其作为创业项目，想要实现盈利的话，关于用户的支付策略可以有什么实现</p><h3 id="ChatGPT-5"><a href="#ChatGPT-5" class="headerlink" title="ChatGPT"></a>ChatGPT</h3><p>训练模型和维护服务器的成本因多种因素而异，包括硬件、云服务提供商、数据存储和传输等。以下是一些可能的成本因素：</p><ol><li><p>训练成本：</p><ul><li>云服务器成本：如果在云端训练模型（如AWS、GCP或Azure），需要考虑GPU实例的成本。价格根据实例类型、地区和使用时长而异。</li><li>本地硬件成本：如果使用本地电脑训练，需要考虑购买高性能GPU、CPU和足够内存的成本。</li></ul></li><li><p>服务器维护成本：</p><ul><li>云服务器成本：用于部署API服务、飞书机器人和数据库的云服务器成本。可以选择按需付费或预留实例以节省成本。</li><li>数据存储和传输成本：数据库存储、备份和传输数据产生的费用。</li><li>域名和SSL证书：购买和续费域名及SSL证书的费用。</li></ul></li><li><p>其他成本：</p><ul><li>开发人员薪资：开发、部署和维护项目的人力成本。</li><li>软件许可和API费用：使用付费软件、API或服务的费用。</li><li>市场营销和用户支持：推广项目和提供用户支持的成本。</li></ul></li></ol><p>关于用户支付策略，以下是一些建议：</p><ol><li>订阅制：按月或年收取订阅费，用户在订阅期内可以无限次使用服务。可以提供不同级别的订阅套餐，以满足不同用户需求。</li><li>付费次数：用户每次使用服务时支付一定费用。可以设定不同的价格区间，根据服务的复杂性或所需资源收费。</li><li>免费试用：为吸引用户，提供免费试用期。试用期结束后，用户需要支付订阅费或按次数付费才能继续使用服务。</li><li>组合套餐：为不同类型的用户提供定制套餐，包括一次性付费、按需付费和订阅制等多种支付方式的组合。</li><li>企业版和团体折扣：针对企业和团体客户提供特殊价格和定制服务。</li></ol><p>为确保项目盈利，请根据实际成本和市场需求合理制定价格策略。同时，关注用户反馈和行业动态，以调整和优化支付策略。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLM </tag>
            
            <tag> Commercial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频制作学习总结</title>
      <link href="/article/eed73e40.html"/>
      <url>/article/eed73e40.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>传统的视频制作人工参与成本高昂，做到一定规模很可能需要小规模的团队，以往的视频制作推荐也大多需要较强的视频制作剪辑技术，而这并不适合信息爆炸短视频流行的今天，根据观看诸多视频教程，结合很火的AIGC（Artificial Intelligent Generates Content）技术，我总结出以下的视频制作Tricks。</p></blockquote><p>如今的AI在<strong>图像</strong>、<strong>音频</strong>、<strong>自然语言处理</strong>等方面的进展堪称可怕，如果可以善用一些开源的AI技术，无疑可以提高自己的生产力。</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>传统的视频制作流程也无外乎这么几步，但是要想做出高质量传播广的视频还是要注意很多细节，首先还是要了解大致流程</p><h2 id="创意文案"><a href="#创意文案" class="headerlink" title="创意文案"></a>创意文案</h2><p>其实还是视频的定位在哪里<br>根据我的研究（基于<em><strong>YouTube</strong></em>上的各种Themes分析），数据来源自然是<em><strong>Social Blade</strong></em>，大致有以下几种主题：</p><ul><li><strong>料理</strong></li><li><strong>宠物</strong></li><li><strong>旅行</strong></li><li><strong>艺术</strong>（绘画、雕刻） <em>CPM非常高，有巨大收益，当然也有很高的技术门槛</em></li><li><strong>手工类制作</strong>  <em>CPM也非常高</em></li><li><strong>开箱</strong></li><li><strong>软件教程</strong></li><li><strong>游戏</strong></li><li><strong>Vlog</strong> <em>CPM比较低，不怎么样</em></li><li><strong>白板动画</strong>  <em>新颖的技术，有学习门槛，但是也比较受欢迎</em><ul><li>推荐工具 <code>Doodly</code></li></ul></li></ul><p>利用AI收集分析信息：</p><blockquote><p>传统的创意文案自然是人工创作，但是如今 <code>chatGPT</code>可以用于制作创意文案、<code>Copy.ai</code>可以用于制作销售文案、<code>Plexity.ai</code>可以用作总结。进一步还可以进行SEO优化，让你的视频更容易被搜索引擎推荐。</p></blockquote><h2 id="拍摄"><a href="#拍摄" class="headerlink" title="拍摄"></a>拍摄</h2><p>拍摄应该分为两类：</p><ul><li>适合露脸的拍摄<ul><li><strong>知识分享</strong></li><li><strong>穿搭推荐</strong></li><li><strong>美妆</strong></li><li><strong>时事评论</strong></li><li><strong>冷知识</strong></li></ul></li><li>适合不露脸的拍摄<ul><li><strong>娱乐八卦</strong></li><li><strong>影视评价</strong></li><li><strong>恶搞视频</strong></li></ul></li></ul><h3 id="根据需求可以选择硬件装备："><a href="#根据需求可以选择硬件装备：" class="headerlink" title="根据需求可以选择硬件装备："></a>根据需求可以选择硬件装备：</h3><ul><li><strong>补光</strong>（露脸需要）<ul><li>平板灯</li><li>ring-light</li></ul></li><li><strong>相机</strong>（露脸和vtuber需要）<ul><li>Canon M50 mark ii</li></ul></li><li><strong>麦克风</strong>（这个应该是必需品）<ul><li>saramonic 大的室内固定+小的外出佩戴</li></ul></li><li><strong>移动硬盘</strong>（户外可能需要）</li></ul><h3 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h3><p>如果套皮出道的话，其实所有主题都挺适合的。<br>接下来是完全套皮（从外貌到声音到场景）<br>工具平台大部分基于 <code>NVIDIA Omniverse</code><br>具体学习可以参考<a href="https://www.youtube.com/channel/UCoJun_nF0I90wzXq5t4SdqA">YouTuber JSFILMZ</a></p><ul><li><strong>人物面部</strong> <code>Audio2Face</code> 可以完成文字转面部表情</li><li><strong>文字台词</strong> <code>chatGPT</code>足矣</li><li><strong>人物模型</strong> <code>Meta Human</code> 基于虚幻引擎<ul><li>可以导出通用格式 <code>USD</code>，由 <code>Audio2Face</code>直接驱动</li></ul></li><li><strong>人物动作</strong>  <code>Machinime</code></li><li><strong>文字转人物动画</strong> <code>Audio2Gesture</code></li><li><strong>真实动作转3D模型</strong> <code>Pose Tracker</code></li><li><strong>渲染4k分辨率</strong> <code>Topaz Video Enhance AI@2.6</code></li><li><strong>场景</strong> <code>Create</code><ul><li><strong>光线渲染</strong> <code>Path Tracing</code></li></ul></li><li><strong>目光接触</strong> <code>Eye Contact</code><ul><li>内嵌于 <code>NVIDIA Broadcast</code></li></ul></li></ul><h2 id="后期"><a href="#后期" class="headerlink" title="后期"></a>后期</h2><h3 id="剪辑"><a href="#剪辑" class="headerlink" title="剪辑"></a>剪辑</h3><p>具体工具推荐：<br>iOS用户推荐自带的 <code>imovie</code><br>当然也可以使用 <code>剪映</code><br>专业用户可以使用 <code>PR</code>，说实话学习成本太高</p><h3 id="字幕"><a href="#字幕" class="headerlink" title="字幕"></a>字幕</h3><p>字幕工具可以使用 <code>剪映专业版</code><br>或者 <code>GitHub</code>上的开源工具 <code>auto-cut</code>（AI根据文字粗剪视频）<br>以及功能非常强大的 <code>飞书</code>提供的 <code>妙记</code>功能提取字幕甚至还可以转成英文字幕。结合使用可能效果更佳。</p><h3 id="封面"><a href="#封面" class="headerlink" title="封面"></a>封面</h3><p>港台地区可能会叫做缩图，也就是视频的封面，如果打算露脸出镜（或者套皮出道），最好把个人形象P在封面上，这是个人IP形成的强有力的推手，当然也可以放视频专题主角的脸。<br>图片的来源以及加工制作有多个工具：</p><ul><li><code>canva</code>  传统封面可以用它完成全部工作</li><li><code>PS</code> 专业p图工具，对小白也有友好操作，但是推荐专业人士使用</li><li><code>fotor</code>  修图在线网页</li><li><code>lama-cleaner</code>  一个用 <code>Python</code>写的 <code>GitHub</code>开源工具，可以实现相当完美的图片去水印以及替换图中物体的功能，有多种AI模型可以选择</li><li><code>StockAI</code>  免费生成商用图片，也支持网上收集免费无版权图片</li></ul><h2 id="小Tips"><a href="#小Tips" class="headerlink" title="小Tips"></a>小Tips</h2><h3 id="开头动画"><a href="#开头动画" class="headerlink" title="开头动画"></a>开头动画</h3><p>可以使用开源工具 <code>TOOLL3</code>完成动画可视化制作，门槛也不是特别高。</p><h3 id="末尾"><a href="#末尾" class="headerlink" title="末尾"></a>末尾</h3><p>音乐节奏舒缓，可以换背景，改变语速。进而是套话（如果有任何问题欢迎评论区留言，感谢观看…）</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>不要做标题党，因为如果用户被标题吸引进来结果发现内容根本不是这么回事会立刻退出，推荐算法发现大量用户在视频开头退出，会认为视频质量不佳，进而不推荐视频。<br>当然标题的制作也有技巧，通过观察大的YouTuber的视频发现都有一些规律可言：</p><ul><li>吸引人眼球的第一句话（一般6个字以内，可以使疑问句、反问句、感叹句）</li><li>简短概述视频内容</li><li>末尾附上keyword<br>非常符合SEO优化</li></ul><h3 id="视频描述"><a href="#视频描述" class="headerlink" title="视频描述"></a>视频描述</h3><p>如实描述视频内容，可以附上引用链接等等，YouTube的description末尾附上#关键字词，可以起到tag的作用方便SEO</p><h3 id="tags优化"><a href="#tags优化" class="headerlink" title="tags优化"></a>tags优化</h3><p>一定要填满，方便搜索引擎关联该视频，如果是中文创作者的话，可以考虑加上繁体方便推荐给港澳台地区的用户，因为大家语言都是相通的。</p><h3 id="BGM选择"><a href="#BGM选择" class="headerlink" title="BGM选择"></a>BGM选择</h3><p>如果是YouTube上传自创视频，一定要选择 <code>no copyright music</code>，否则后台识别到有版权音乐的话，会将收入全部给予音乐版权所有者。</p><h3 id="视频上传频率"><a href="#视频上传频率" class="headerlink" title="视频上传频率"></a>视频上传频率</h3><p>可以根据后台数据，一旦播放峰值曲线出现回落就可以上传新的视频，为了与推荐算法的周期相匹配，可以选择5-7个工作日上传一个新视频，一定要保持创作，否则YouTube会认为该用户不再进行内容创作，进而不推荐视频。</p><h2 id="成为一名YouTuber"><a href="#成为一名YouTuber" class="headerlink" title="成为一名YouTuber"></a>成为一名YouTuber</h2><ul><li>创建一个Gmail邮箱</li><li>最近的十二个月内达到1000订阅+4000小时的观看时长</li><li>申请Google Adsense账户</li><li>绑定银行账户</li></ul>]]></content>
      
      
      <categories>
          
          <category> Skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> YouTuber </tag>
            
            <tag> 视频制作 </tag>
            
            <tag> AIGC </tag>
            
            <tag> softskills </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鲲鹏聚数:基于华为GaussDB数据库的应用与实践</title>
      <link href="/article/8fe4ecaf.html"/>
      <url>/article/8fe4ecaf.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-Chapter1-GaussDB数据库概述"><a href="#1-1-Chapter1-GaussDB数据库概述" class="headerlink" title="1.1. Chapter1 GaussDB数据库概述"></a>1.1. Chapter1 GaussDB数据库概述</h2><p>edition：opengauss 3.1.0 </p><h3 id="1-1-1-数据库系统基本概念"><a href="#1-1-1-数据库系统基本概念" class="headerlink" title="1.1.1. 数据库系统基本概念"></a>1.1.1. 数据库系统基本概念</h3><blockquote><p>定义：数据库是长期存储在计算机内，有组织的，可共享的大量数据集合。（目前定义，新定义与云原生数据库有关）</p></blockquote><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>数据按一定的数据模型组织、描述、和存储</li><li>可为各种用户共享</li><li>冗余度较小</li><li>数据独立性高</li><li>易扩展</li></ul><p>关于数据独立性和逻辑独立性：<br>逻辑独立性通过 <strong>视图（view）</strong> 实现一个映射关系</p><h4 id="数据库管理系统（DBMS）"><a href="#数据库管理系统（DBMS）" class="headerlink" title="数据库管理系统（DBMS）"></a>数据库管理系统（DBMS）</h4><blockquote><p>定义：能够让用户定义、创建和维护数据库以及对数据库访问的软件系统。</p></blockquote><p>组成：查询处理器和存储处理器</p><h4 id="三层模式体系结构"><a href="#三层模式体系结构" class="headerlink" title="三层模式体系结构"></a>三层模式体系结构</h4><ul><li>内模式（internal schema）物理数据库 <ul><li>Index 定义数据<ul><li>例如 （non）cluster index （非）聚集索引</li></ul></li></ul></li><li>概念模式（conceptual schema）概念数据库</li><li>外模式（external schema） <ul><li>是概念模式的子集</li><li>保证了数据库数据的安全，每个用户对数据的访问权限不同</li></ul></li></ul><h4 id="关系数据模型"><a href="#关系数据模型" class="headerlink" title="关系数据模型"></a>关系数据模型</h4><ul><li>关系模式<ul><li>关系必须是规范化的，满足第一范式（1NF），每一个分量必须是不可分的数据项，不能表中有表</li></ul></li></ul><p>可以用作唯一标识的属性可以当作<code>候选建（Candidate key）</code>，DBA可以根据需要选一个当<code>主键（Primary Key）</code><br><code>外键（Foreign Key）</code>：这个键在某个表中是主键，但是在另外一个表中不是主键，那么在非主键关系表中这个键叫做<strong>外键</strong> </p><h4 id="关系完整性"><a href="#关系完整性" class="headerlink" title="关系完整性"></a>关系完整性</h4><p>三类完整性约束：</p><ul><li>实体完整性：主码不能取空值</li><li>参照完整性：<ul><li>取空</li><li>和主码一样的值</li></ul></li></ul><h3 id="1-1-2-鲲鹏生态体系"><a href="#1-1-2-鲲鹏生态体系" class="headerlink" title="1.1.2. 鲲鹏生态体系"></a>1.1.2. 鲲鹏生态体系</h3><h3 id="1-1-3-GaussDB数据库的发展历程及其特点"><a href="#1-1-3-GaussDB数据库的发展历程及其特点" class="headerlink" title="1.1.3. GaussDB数据库的发展历程及其特点"></a>1.1.3. GaussDB数据库的发展历程及其特点</h3><h3 id="1-1-4-GuassDB数据库的体系结构和主要功能"><a href="#1-1-4-GuassDB数据库的体系结构和主要功能" class="headerlink" title="1.1.4. GuassDB数据库的体系结构和主要功能"></a>1.1.4. GuassDB数据库的体系结构和主要功能</h3><h2 id="1-2-Chapter2-结构化查询语言SQL"><a href="#1-2-Chapter2-结构化查询语言SQL" class="headerlink" title="1.2. Chapter2 结构化查询语言SQL"></a>1.2. Chapter2 结构化查询语言SQL</h2><h3 id="1-2-1-SQL语言基础"><a href="#1-2-1-SQL语言基础" class="headerlink" title="1.2.1. SQL语言基础"></a>1.2.1. SQL语言基础</h3><p>核心功能只有九个指令：</p><ul><li>DDL: CREATE DROP ALTER</li><li>DML: SELECT INSERT UPDATE DELETE</li><li>DCL: GRANT REMOVE</li></ul><h3 id="1-2-2-数据库对象定义"><a href="#1-2-2-数据库对象定义" class="headerlink" title="1.2.2. 数据库对象定义"></a>1.2.2. 数据库对象定义</h3><h3 id="1-2-3-数据查询和数据修改SQL语句"><a href="#1-2-3-数据查询和数据修改SQL语句" class="headerlink" title="1.2.3. 数据查询和数据修改SQL语句"></a>1.2.3. 数据查询和数据修改SQL语句</h3><p>许多检测工具会执行一条SELECT 1;来测试数据库连接</p><h4 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h4><ul><li>无条件查询</li><li>聚集查询</li><li>多表查询<ul><li>自然连接：相同属性列下面的值必须相等，最终返回的视图会删掉重复的列</li><li>等值连接：不会删除重复的列，会显示来自哪张表中的属性</li><li>自连接：可以比较不同表的不同列</li><li>非等值连接：比较关系是其他比较符号</li><li>嵌套查询：<code>SELECT</code>嵌套，理论上限为200个</li><li>联合查询：关键字<code>UNION</code>，就是并运算<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">[</span><span class="token keyword">ALL</span><span class="token operator">|</span><span class="token keyword">DISTINCT</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>目标列表达式<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">></span>目标列表达式<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span><span class="token operator">&lt;</span>新表名<span class="token operator">></span><span class="token punctuation">]</span><span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名或视图名<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>表名或视图名<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token keyword">WHERE</span><span class="token operator">&lt;</span>条件表达式<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span><span class="token operator">&lt;</span>列名<span class="token number">1</span><span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">HAVING</span><span class="token operator">&lt;</span>条件表达式<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span><span class="token operator">&lt;</span>列名<span class="token number">2</span><span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">ASC</span><span class="token operator">|</span><span class="token keyword">DESC</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h4 id="数据增加"><a href="#数据增加" class="headerlink" title="数据增加"></a>数据增加</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> 表一 <span class="token punctuation">[</span><span class="token operator">&lt;</span>列<span class="token operator">></span><span class="token punctuation">]</span> VALUEE 表二<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="数据修改"><a href="#数据修改" class="headerlink" title="数据修改"></a>数据修改</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">UPDATE</span><span class="token operator">&lt;</span>基表名<span class="token operator">></span><span class="token keyword">SET</span> <span class="token operator">&lt;</span>列名<span class="token number">1</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token operator">&lt;</span>表达式<span class="token number">2</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>条件表达式<span class="token operator">></span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>WITH CHECK OPTION是一个SQL语言中的约束条件，它用于限制向数据库中插入或更新数据的行为。</p></blockquote><blockquote><p>当使用WITH CHECK OPTION约束条件时，它可以确保插入或更新的行满足指定的WHERE子句。如果插入或更新的行不符合WHERE子句，则操作将被拒绝，并返回错误信息。</p></blockquote><h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> CLUSTER <span class="token keyword">INDEX</span> stusname <span class="token keyword">ON</span> Student<span class="token punctuation">(</span>Sname<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在建立好索引后，需要按照顺序在条件判断中使用索引：比如先建立索引A，然后B，就不能先判断B再判断A</p><h5 id="目标列表达式格式"><a href="#目标列表达式格式" class="headerlink" title="目标列表达式格式"></a>目标列表达式格式</h5><p><code> */表名.属性列/count(*)/属性列表达式</code><br>其中<code>count(*)</code>自动去重，计算主码分量个数</p><h2 id="1-3-Chapter3-GaussDB的运行环境及安装"><a href="#1-3-Chapter3-GaussDB的运行环境及安装" class="headerlink" title="1.3. Chapter3 GaussDB的运行环境及安装"></a>1.3. Chapter3 GaussDB的运行环境及安装</h2><h3 id="1-3-1-GaussDB单机版运行环境搭建"><a href="#1-3-1-GaussDB单机版运行环境搭建" class="headerlink" title="1.3.1. GaussDB单机版运行环境搭建"></a>1.3.1. GaussDB单机版运行环境搭建</h3><p>见pdf文件<br>利用ssh终端连接软件</p><h3 id="1-3-2-数据库连接管理"><a href="#1-3-2-数据库连接管理" class="headerlink" title="1.3.2. 数据库连接管理"></a>1.3.2. 数据库连接管理</h3><p>TableSpace DataBase<br>一个表空间可以有多个数据库，数据库是逻辑概念<br>Segment</p><ul><li>表空间table space</li><li>模式scheme</li><li>用户user</li></ul><h3 id="1-3-3-数据库实例管理"><a href="#1-3-3-数据库实例管理" class="headerlink" title="1.3.3. 数据库实例管理"></a>1.3.3. 数据库实例管理</h3><h2 id="1-4-Chapter4-SQL基础实验"><a href="#1-4-Chapter4-SQL基础实验" class="headerlink" title="1.4. Chapter4 SQL基础实验"></a>1.4. Chapter4 SQL基础实验</h2><h3 id="1-4-1-在GaussDB数据库环境下执行SQL命令的方式"><a href="#1-4-1-在GaussDB数据库环境下执行SQL命令的方式" class="headerlink" title="1.4.1. 在GaussDB数据库环境下执行SQL命令的方式"></a>1.4.1. 在GaussDB数据库环境下执行SQL命令的方式</h3><h3 id="1-4-2-使用数据定义-数据查询以及数据操纵SQL命令完成数据库实验"><a href="#1-4-2-使用数据定义-数据查询以及数据操纵SQL命令完成数据库实验" class="headerlink" title="1.4.2. 使用数据定义,数据查询以及数据操纵SQL命令完成数据库实验"></a>1.4.2. 使用数据定义,数据查询以及数据操纵SQL命令完成数据库实验</h3><h2 id="1-5-Chapter5-数据库应用程序设计实验"><a href="#1-5-Chapter5-数据库应用程序设计实验" class="headerlink" title="1.5. Chapter5 数据库应用程序设计实验"></a>1.5. Chapter5 数据库应用程序设计实验</h2><h3 id="1-5-1-数据库应用程序设计的方式"><a href="#1-5-1-数据库应用程序设计的方式" class="headerlink" title="1.5.1. 数据库应用程序设计的方式"></a>1.5.1. 数据库应用程序设计的方式</h3><h3 id="1-5-2-SQL语言嵌入到高级程序语言中访问和操纵数据库的方法"><a href="#1-5-2-SQL语言嵌入到高级程序语言中访问和操纵数据库的方法" class="headerlink" title="1.5.2. SQL语言嵌入到高级程序语言中访问和操纵数据库的方法"></a>1.5.2. SQL语言嵌入到高级程序语言中访问和操纵数据库的方法</h3><h3 id="1-5-3-高级语言访问GaussDB数据库的接口"><a href="#1-5-3-高级语言访问GaussDB数据库的接口" class="headerlink" title="1.5.3. 高级语言访问GaussDB数据库的接口"></a>1.5.3. 高级语言访问GaussDB数据库的接口</h3><h2 id="GitHub项目地址"><a href="#GitHub项目地址" class="headerlink" title="GitHub项目地址"></a>GitHub项目地址</h2><p><a href="https://github.com/SKDDJ/HR-management-system">HR-management-system</a></p><blockquote><p>Forked from Mr. Cai, an alumnus of the Internet Plus program in the class of 2020, and made some changes to the code.</p></blockquote><ol><li>Change the datanode from remote OpenEuler to local host.</li><li>Change the database from GaussDB to PostgreSQL.</li><li>Changed part of the front-end layout.</li><li>Attempted to use Docker to package GaussDB and run it on a local ARM-based server(MacBook M1 2020).</li></ol>]]></content>
      
      
      <categories>
          
          <category> Course </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二下 </tag>
            
            <tag> GaussDB数据库 </tag>
            
            <tag> Open Euler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金融学基础</title>
      <link href="/article/a0d51f41.html"/>
      <url>/article/a0d51f41.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-Module1-金融和金融系统"><a href="#1-1-Module1-金融和金融系统" class="headerlink" title="1.1. Module1 金融和金融系统"></a>1.1. Module1 金融和金融系统</h2><h3 id="1-1-1-金融的概念-含义及学科体系"><a href="#1-1-1-金融的概念-含义及学科体系" class="headerlink" title="1.1.1. 金融的概念,含义及学科体系"></a>1.1.1. 金融的概念,含义及学科体系</h3><blockquote><p>概念: 金融学是研究人们如何在不确定环境下跨时期进行稀缺资源配置的学问</p></blockquote><p>金融学三大支柱: 3 issues in finance：</p><ul><li>跨时期优化</li><li>风险管理</li><li>资产估值</li></ul><p>资产收益 &#x3D; 风险补偿 + 无风险收益</p><blockquote><p>实例: 伊犁州东西运河</p></blockquote><h4 id="1-1-1-1-个人-x2F-家庭的金融决策"><a href="#1-1-1-1-个人-x2F-家庭的金融决策" class="headerlink" title="1.1.1.1. 个人&#x2F;家庭的金融决策"></a>1.1.1.1. 个人&#x2F;家庭的金融决策</h4><ul><li>投资决策(Investment Decision) 钱向哪去?</li><li>融资决策(Financing Decision) 钱从哪来?<ul><li>对抗时间</li></ul></li><li>风险管理决策(Risk Management Decision) 抵抗风险<ul><li>对抗不确定性</li></ul></li></ul><h4 id="1-1-1-2-企业的金融决策"><a href="#1-1-1-2-企业的金融决策" class="headerlink" title="1.1.1.2. 企业的金融决策"></a>1.1.1.2. 企业的金融决策</h4><ul><li>战略规划(Strategy Planning)</li><li>资本预算&#x2F;投资决策(Captital Budget&#x2F;Investment Decision)</li><li>资本结构&#x2F;融资决策(Capital Structure&#x2F;Financing Decision)<ul><li>股票or债券</li></ul></li><li>营运资本管理决策(Working Capital Management Decision)<ul><li>$流动资产(Current Assests)-流动负债(Current Liability)&#x3D;净营运资本(Net Working Capital)$</li></ul></li><li>股利决策(Dividend Decision)<ul><li>债权人(优先获得利息或者到期本金)</li><li>股东(剩余索偿权 Residual Claim)</li></ul></li><li>风险管理决策(Risk-management Decision)<ul><li>投资失败or成本上升</li></ul></li></ul><h3 id="1-1-2-资金流动与金融系统"><a href="#1-1-2-资金流动与金融系统" class="headerlink" title="1.1.2. 资金流动与金融系统"></a>1.1.2. 资金流动与金融系统</h3><blockquote><p>金融系统(Financial System): 通过一系列的金融资产&#x2F;合约交易(包括各种风险的交易), 帮助个人&#x2F;家庭,企业或政府执行各种金融决策的系统;</p><ul><li>金融市场(交易所市场,场外市场…)</li><li>金融中介(商业银行,投资银行…)<ul><li>商业银行主要依靠贷款，资产负债表特点是负债率高</li><li>投资银行主要业务是： IPO和SEO，还提供咨询服务</li></ul></li><li>服务公司(信用评级公司,投资咨询公司…)<ul><li>保险公司 保费和利率成反比</li></ul></li><li>其他机构(监管部门,非营利性机构…)</li></ul></blockquote><h4 id="1-1-2-1-直接的资金流动"><a href="#1-1-2-1-直接的资金流动" class="headerlink" title="1.1.2.1. 直接的资金流动"></a>1.1.2.1. 直接的资金流动</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212282023975.png"></p><p>红色箭头中有潜在的<em>搜索成本(Searching Cost)以及信用风险(Credit Risk)</em></p><h4 id="1-1-2-2-通过”金融中介”的资金流动"><a href="#1-1-2-2-通过”金融中介”的资金流动" class="headerlink" title="1.1.2.2. 通过”金融中介”的资金流动"></a>1.1.2.2. 通过”金融中介”的资金流动</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212282026076.png"></p><h4 id="1-1-2-3-通过”金融市场-Financial-Market-”的资金流动"><a href="#1-1-2-3-通过”金融市场-Financial-Market-”的资金流动" class="headerlink" title="1.1.2.3. 通过”金融市场(Financial Market)”的资金流动"></a>1.1.2.3. 通过”金融市场(Financial Market)”的资金流动</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212282027155.png"></p><h4 id="1-1-2-4-先通过”金融中介”-再通过”金融市场”的资金流动"><a href="#1-1-2-4-先通过”金融中介”-再通过”金融市场”的资金流动" class="headerlink" title="1.1.2.4. 先通过”金融中介”,再通过”金融市场”的资金流动"></a>1.1.2.4. 先通过”金融中介”,再通过”金融市场”的资金流动</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212282028330.png"></p><h3 id="1-1-3-金融市场的类型"><a href="#1-1-3-金融市场的类型" class="headerlink" title="1.1.3. 金融市场的类型"></a>1.1.3. 金融市场的类型</h3><p>根据是否有交易地点分类:</p><ul><li>交易所市场(Exchanges)<ul><li>xxx交易所</li></ul></li><li>场外市场(Over-the-counter Market,OTC)<ul><li>纳斯达克交易市场</li></ul></li></ul><p>根据合约特征分类:</p><p>根据金融产品的期限分类:</p><h3 id="1-1-4-金融系统的功能"><a href="#1-1-4-金融系统的功能" class="headerlink" title="1.1.4. 金融系统的功能"></a>1.1.4. 金融系统的功能</h3><ul><li>清算与结算(Clearing and Setting Payments)</li><li>跨时间和空间转移资源(Transferring Resources across Time or Space)</li><li>风险管理(Managing Risk)<ul><li>风险分散 Diversifying</li><li>风险对冲 Hedging</li><li>期权&#x2F;保险 Insuring</li></ul></li><li>集合资源和分割股份(Pooling Resource &amp; Subdividing Shares)</li><li>提供信息(Providing Information)</li><li>处理激励问题(Dealing with the Incentive Problems)</li></ul><h4 id="1-1-4-1-处理激励问题-Dealing-with-the-Incentive-Problems"><a href="#1-1-4-1-处理激励问题-Dealing-with-the-Incentive-Problems" class="headerlink" title="1.1.4.1. 处理激励问题(Dealing with the Incentive Problems)"></a>1.1.4.1. 处理激励问题(Dealing with the Incentive Problems)</h4><blockquote><p>银行提高利率无法解决激励问题，可以通过信贷配给（credit rationing）抵押贷款的形式解决这个问题。</p></blockquote><ul><li>信息不对称与激励问题(Information Asymmetry and Incentive Problem)<ul><li>事后隐藏行动-道德风险(Moral Hazard) 变更资金使用用途<ul><li>通过保险&#x2F;贷款条款的设计</li><li>募集资金使用的监管方法</li><li>分阶段投资</li></ul></li><li>事先隐藏类型-逆向选择(Adverse Selection) 二手车市场<ul><li>解决方法：信号传递(Signaling)和甄别(Screening)</li><li>学校文凭和各种证书</li><li>抵押collateralized担保guaranteed贷款</li></ul></li></ul></li></ul><h2 id="1-2-Module2-资金时间价值与跨时期优化"><a href="#1-2-Module2-资金时间价值与跨时期优化" class="headerlink" title="1.2. Module2 资金时间价值与跨时期优化"></a>1.2. Module2 资金时间价值与跨时期优化</h2><h3 id="1-2-1-资金时间价值-Time-value-of-Money-的概念"><a href="#1-2-1-资金时间价值-Time-value-of-Money-的概念" class="headerlink" title="1.2.1. 资金时间价值(Time value of Money)的概念"></a>1.2.1. 资金时间价值(Time value of Money)的概念</h3><p>现值（Present Value）比终值&#x2F;将来值（Future Value）更有价值</p><p>$$FV &#x3D; PV\times (1+i)^n$$</p><ul><li>i : interest rate</li><li>n: times</li><li>资金具有时间价值 * 人们的选择偏好<ul><li>机会成本</li><li>不确定性因素</li></ul></li></ul><p>（无风险）利率是将来消费和现在消费的边际替代率。</p><h4 id="两种利率计算方法"><a href="#两种利率计算方法" class="headerlink" title="两种利率计算方法"></a>两种利率计算方法</h4><ul><li>单利（single interest）只在本金上计算</li><li>复利（compound interest）利滚利</li></ul><p>这里有几个公式需要会用，不难但是需要理解：</p><ul><li>根据年度复合利率计算月度复合利率</li><li>根据将来值和现值计算年度复合利率</li><li>可以参考spoc上的测验题</li></ul><h5 id="Compound-amp-single"><a href="#Compound-amp-single" class="headerlink" title="Compound &amp; single"></a>Compound &amp; single</h5><h5 id="the-rule-of-72"><a href="#the-rule-of-72" class="headerlink" title="the rule of 72:"></a>the rule of 72:</h5><p>the years to double is :</p><p>$$Y &#x3D; \frac{72}{n}:where\ n\ is\ the\ interest\ rate$$</p><h3 id="1-2-2-复利-计息频率与有效年利率"><a href="#1-2-2-复利-计息频率与有效年利率" class="headerlink" title="1.2.2. 复利,计息频率与有效年利率"></a>1.2.2. 复利,计息频率与有效年利率</h3><ul><li>Annual percentage rate: APR 挂牌年利率</li><li>Effective annuanl rate: EFF 有效年利率</li></ul><p>$$EFF(APR,m) &#x3D; (1+\frac{APR}{m})^m -1$$</p><ul><li>where $m$ is 记息频率</li></ul><h3 id="1-2-3-年金与分期摊还"><a href="#1-2-3-年金与分期摊还" class="headerlink" title="1.2.3. 年金与分期摊还"></a>1.2.3. 年金与分期摊还</h3><ul><li>annuity 年金</li></ul><h4 id="Ordinary-Annuity"><a href="#Ordinary-Annuity" class="headerlink" title="Ordinary Annuity"></a>Ordinary Annuity</h4><p>$$PV &#x3D; PMT\times \frac{1-(1+i)^{-n}}{i}$$</p><p>可用于等额本息计算那个PMT&#x2F;C</p><p>$$FV &#x3D; PMT\times \frac{(1+i)^n-1}{i}$$</p><h4 id="Perpetual-Annuity"><a href="#Perpetual-Annuity" class="headerlink" title="Perpetual Annuity"></a>Perpetual Annuity</h4><p>$$PV &#x3D; \frac{PMT}{i}$$</p><h3 id="1-2-4-个人生命周期规划"><a href="#1-2-4-个人生命周期规划" class="headerlink" title="1.2.4. 个人生命周期规划"></a>1.2.4. 个人生命周期规划</h3><h4 id="Human-Capital"><a href="#Human-Capital" class="headerlink" title="Human Capital"></a>Human Capital</h4><h4 id="跨时期预算约束-The-x3D-Budget-Constraint"><a href="#跨时期预算约束-The-x3D-Budget-Constraint" class="headerlink" title="跨时期预算约束 The &#x3D; Budget Constraint"></a>跨时期预算约束 The &#x3D; Budget Constraint</h4><h3 id="1-2-5-资本预算决策与净现值法则"><a href="#1-2-5-资本预算决策与净现值法则" class="headerlink" title="1.2.5. 资本预算决策与净现值法则"></a>1.2.5. 资本预算决策与净现值法则</h3><ul><li>Net Present Value: NPV 净现值</li><li>Internal Return Rate： IRR 内部收益率 Net Income &#x3D; Revenue - Expenses - Taxes Cash Flow &#x3D; Net Income - NonCash Expenses 关于值不值得投资的三个参考：</li><li>NPV</li><li>IRR</li><li>Payback Period</li></ul><blockquote><p>NPV更看重时间价值和折现率（融资） IRR更看重回报率（投资） Payback Period更看重回本时间</p></blockquote><p>折现NPV可以判断是否值得投资 令折现公式等于0可以算出IRR</p><h5 id="NPV-Rule"><a href="#NPV-Rule" class="headerlink" title="NPV Rule"></a>NPV Rule</h5><p>if NPV &gt; 0, then invest.</p><p>$$NPV &#x3D; \sum_{t&#x3D;0}^{n}\frac{CF_t}{(1+k)^t}$$</p><ul><li>forecasting cash flow($CF_t$)</li><li>discount rate(k):<ul><li>opportunity cost</li><li>market capitalization rate</li><li>cost of capital</li><li>required return</li></ul></li></ul><h4 id="Loan-Amortization"><a href="#Loan-Amortization" class="headerlink" title="Loan Amortization"></a>Loan Amortization</h4><ul><li>等额本金<ul><li>每个月还的本金固定，利息从剩下的还款中计算</li></ul></li><li>等额本息<ul><li>每个月还的总金额固定</li></ul></li></ul><h4 id="loan-payment-formula"><a href="#loan-payment-formula" class="headerlink" title="loan payment formula"></a>loan payment formula</h4><p>$$Remaining\ Balance &#x3D;P(1+r)^n - (PMT * (((1+r)^n - 1) &#x2F; r))$$</p><h4 id="Working-Capital"><a href="#Working-Capital" class="headerlink" title="Working Capital"></a>Working Capital</h4><p>关于会计利润（Account Profit）$\to$现金流$\to$NPV</p><h5 id="Sensitivity-Analysis"><a href="#Sensitivity-Analysis" class="headerlink" title="Sensitivity Analysis"></a>Sensitivity Analysis</h5><h5 id="Break-even-Point"><a href="#Break-even-Point" class="headerlink" title="Break-even Point"></a>Break-even Point</h5><ul><li>通常不光计算金额还要计算销量</li></ul><p>$$WK &#x3D; LA - LL$$</p><p>which is :</p><p>$$Working\ Capital &#x3D; Liquidity\ assets - Liquidity\ Liability$$</p><p>计算时看作必要投资 WK增加Cash Flow减少</p><ul><li>因为存货增加 现金流减少</li><li>应收帐款增加 现金流减少</li><li>短期负债增加 现金流增加</li></ul><h2 id="1-3-Module3-资产估值原理与债券-股票估值"><a href="#1-3-Module3-资产估值原理与债券-股票估值" class="headerlink" title="1.3. Module3 资产估值原理与债券,股票估值"></a>1.3. Module3 资产估值原理与债券,股票估值</h2><p>Chapter 9 Valuation of common stocks</p><h3 id="1-3-1-账面价值与市场价值"><a href="#1-3-1-账面价值与市场价值" class="headerlink" title="1.3.1. 账面价值与市场价值"></a>1.3.1. 账面价值与市场价值</h3><h3 id="1-3-2-信息-价格与有效市场假说-EMH"><a href="#1-3-2-信息-价格与有效市场假说-EMH" class="headerlink" title="1.3.2. 信息,价格与有效市场假说(EMH)"></a>1.3.2. 信息,价格与有效市场假说(EMH)</h3><h3 id="1-3-3-一价定律与债券估值"><a href="#1-3-3-一价定律与债券估值" class="headerlink" title="1.3.3. 一价定律与债券估值"></a>1.3.3. 一价定律与债券估值</h3><h3 id="1-3-4-股利折现模型-DDM"><a href="#1-3-4-股利折现模型-DDM" class="headerlink" title="1.3.4. 股利折现模型(DDM)"></a>1.3.4. 股利折现模型(DDM)</h3><p>Discounted Dividend Model(DDM)</p><ul><li>cash flow: Dividend or future price</li><li>Discount rate:Expected rate of return Stocks:</li></ul><p>$$D_0 &#x3D; \sum_{i&#x3D;1}^{\infty}\frac{D_t}{(1+k)^t}$$</p><p>$$&#x3D; \frac{D_1}{(1+k)} + \frac{P_1}{(1+k)}&#x3D; \frac{D_1}{(1+k)} + \frac{D_2}{(1+k)^2} + \frac{P_2}{(1+k)^2}$$</p><p>compared to Bonds:</p><ul><li>uncertainty</li><li>four factors…</li></ul><h4 id="Simply-the-Model"><a href="#Simply-the-Model" class="headerlink" title="Simply the Model"></a>Simply the Model</h4><p>Assumption:</p><ol><li>Dividends are constant</li><li>A constant growth rate</li></ol><p>$$D_0 &#x3D; \sum_{t&#x3D;1}^{\infty}\frac{D_t}{(1+k)^t} &#x3D; \sum_{t&#x3D;1}^{\infty}\frac{D}{(1+k)^t} &#x3D; \frac{D}{K}$$</p><p>$$P_0 &#x3D; \frac{D}{K} &#x3D; \frac{E}{K} \to \frac{D_0}{E} &#x3D; \frac{1}{k}$$</p><h4 id="Constant-Growth-Rate-DDM"><a href="#Constant-Growth-Rate-DDM" class="headerlink" title="Constant-Growth-Rate DDM"></a>Constant-Growth-Rate DDM</h4><p>$$D_t &#x3D; D_1(1+g)^{t-1}$$</p><p>$$D_0 &#x3D; \frac{D_1}{k-g}$$</p><p>公比：$\frac{1+k}{1+g}$</p><blockquote><p>if $g &gt; k$ then the $P_0$ doesn’t depend on Dividend</p></blockquote><p>$$P_0 &#x3D; \frac{D_1}{k-g} \to k &#x3D; \frac{D_1}{P_0} + g &#x3D; \frac{D_1}{P_0} + \frac{P_1-P_0}{P_0}$$</p><p>here k is Required return(Risk adjusted) $\frac{D_1}{P_0}$ &#x3D; Dividend $\frac{P_1-P_0}{P_0}$ &#x3D; yield + Capital gain</p><h3 id="1-3-5-基于盈利与投资机会的股票估值模型"><a href="#1-3-5-基于盈利与投资机会的股票估值模型" class="headerlink" title="1.3.5. 基于盈利与投资机会的股票估值模型"></a>1.3.5. 基于盈利与投资机会的股票估值模型</h3><h4 id="Earnings-and-Investment-Opprtunity"><a href="#Earnings-and-Investment-Opprtunity" class="headerlink" title="Earnings and Investment Opprtunity"></a>Earnings and Investment Opprtunity</h4><p>$$E_t &#x3D; D_t + RE_t$$</p><p>$$D_t &#x3D; E_t - NetI_t$$</p><p>$$&#x3D; E_t - (GrossI_t - Depreciation_t)$$</p><p>$$&#x3D; CF_t - GrossI_t$$</p><h5 id="then-we-have"><a href="#then-we-have" class="headerlink" title="then we have"></a>then we have</h5><p>$$Dividends_t &#x3D; Earning_t - Net\ Investment_t$$</p><p>$$P_0 &#x3D; \sum_{t&#x3D;1}^{\infty}\frac{D}{(1+k)^t} &#x3D; \sum_{t&#x3D;1}^{\infty}\frac{E_t}{(1+k)^t}-\sum_{t&#x3D;1}^{\infty}\frac{I_t}{(1+k)^t}$$</p><p>$\sum_{t&#x3D;1}^{\infty}\frac{E_t}{(1+k)^t}-\sum_{t&#x3D;1}^{\infty}\frac{I_t}{(1+k)^t}$ is NPV</p><p>$$P_0 &#x3D; \frac{E_t}{k} + NPV\ of\ future\ Investment$$</p><h4 id="Growth-Rate"><a href="#Growth-Rate" class="headerlink" title="Growth Rate"></a>Growth Rate</h4><p>$$\Delta Earnings &#x3D; Reinvestment \times Return\ on\ Reinvestment$$</p><p>$$&#x3D; Retained\ earning \times Return\ on\ Reinvestment$$</p><p>$$&#x3D; earnings \times Retention\ Rate \times Return\ on\ Reinvestment$$</p><h5 id="Both-side-divided-by-earnings"><a href="#Both-side-divided-by-earnings" class="headerlink" title="(Both side divided by earnings)"></a>(Both side divided by earnings)</h5><p>Then</p><p>$$g &#x3D; \frac{\Delta earnings}{earnings} &#x3D; Retention\ Rate \times Return\ on\ Reinvestment$$</p><blockquote><p>Rate of return on future investment compared to “Market Capitalization rate”</p></blockquote><h2 id="1-4-Module4-风险管理概述-Risk-Management"><a href="#1-4-Module4-风险管理概述-Risk-Management" class="headerlink" title="1.4. Module4 风险管理概述 Risk Management"></a>1.4. Module4 风险管理概述 Risk Management</h2><h3 id="Chapter-11"><a href="#Chapter-11" class="headerlink" title="Chapter 11"></a>Chapter 11</h3><p><strong>Terminologies</strong></p><ul><li>aversion 厌恶</li><li>underlying asset 标定资产</li><li>Spot price 现货价格</li><li>long position 多头位置&#x2F;看涨</li><li>short position 空头位置&#x2F;看跌</li><li>A call&amp; A put 买入&#x2F;卖出 option（看涨&#x2F;跌 option）</li><li>Strike or exercise price 敲定&#x2F;行权&#x2F;执行价格</li><li>Expiration or maturity date</li><li>European or American type 美式期权可以随时执行</li><li>Out&#x2F;In&#x2F;At of the money 价外&#x2F;内&#x2F;中（赚钱为内）</li><li>Tangible(Intrisic) value 内在&#x2F;执行价值</li></ul><h3 id="1-4-1-风险的概念与测度"><a href="#1-4-1-风险的概念与测度" class="headerlink" title="1.4.1. 风险的概念与测度"></a>1.4.1. 风险的概念与测度</h3><p>The concept of risk</p><p>$$Uncertainty \neq risk$$</p><h3 id="1-4-2-风险管理的基本框架"><a href="#1-4-2-风险管理的基本框架" class="headerlink" title="1.4.2. 风险管理的基本框架"></a>1.4.2. 风险管理的基本框架</h3><p>Risk aversion &amp; premium</p><ul><li>Utility function U(W)</li><li>Premium</li><li>Certainty Equvalent</li></ul><p><img src="/article/a0d51f4/shiym/Library/CloudStorage/OneDrive-6x26s6/Pictures/IMG_0620.HEIC"></p><h4 id="Three-dimensions-of-risk-transfer"><a href="#Three-dimensions-of-risk-transfer" class="headerlink" title="Three dimensions of risk transfer"></a>Three dimensions of risk transfer</h4><ul><li>Hedging Ch14: Forward and Future markets</li><li>Insuring Ch15 Option Markets</li><li>Diversifying Ch12&#x2F;13 Portfolio selection Theory&#x2F;Capital Market Equilibrium(CAPM)</li></ul><h4 id="Swap-Contract"><a href="#Swap-Contract" class="headerlink" title="Swap Contract"></a>Swap Contract</h4><p>LIBOR</p><h3 id="1-4-3-分散化的基本原理-系统风险与非系统风险"><a href="#1-4-3-分散化的基本原理-系统风险与非系统风险" class="headerlink" title="1.4.3. 分散化的基本原理:系统风险与非系统风险"></a>1.4.3. 分散化的基本原理:系统风险与非系统风险</h3><h3 id="1-4-4-对冲的基本原理-远期-期货与互换"><a href="#1-4-4-对冲的基本原理-远期-期货与互换" class="headerlink" title="1.4.4. 对冲的基本原理:远期,期货与互换"></a>1.4.4. 对冲的基本原理:远期,期货与互换</h3><h3 id="1-4-5-保险的基本原理-期权相关概念"><a href="#1-4-5-保险的基本原理-期权相关概念" class="headerlink" title="1.4.5. 保险的基本原理:期权相关概念"></a>1.4.5. 保险的基本原理:期权相关概念</h3><h4 id="Insuring"><a href="#Insuring" class="headerlink" title="Insuring"></a>Insuring</h4><p>Features of Insurance Contracts</p><ul><li>Exclusion</li><li>Caps: upper limit</li><li>Deductibles</li><li>Copayments</li></ul><h4 id="Options-as-Insurance"><a href="#Options-as-Insurance" class="headerlink" title="Options as Insurance"></a>Options as Insurance</h4><p>Difference from futures: deliver or abandon <img src="/article/a0d51f4/shiym/Library/CloudStorage/OneDrive-6x26s6/Pictures/IMG_0621.heic"></p><h2 id="1-5-Module5-组合选择理论与资本资产定价模型"><a href="#1-5-Module5-组合选择理论与资本资产定价模型" class="headerlink" title="1.5. Module5 组合选择理论与资本资产定价模型"></a>1.5. Module5 组合选择理论与资本资产定价模型</h2><h3 id="1-5-1-风险资产与风险资产的组合过程"><a href="#1-5-1-风险资产与风险资产的组合过程" class="headerlink" title="1.5.1. 风险资产与风险资产的组合过程"></a>1.5.1. 风险资产与风险资产的组合过程</h3><h4 id="Portfolio-of-many-risky-assets"><a href="#Portfolio-of-many-risky-assets" class="headerlink" title="Portfolio of many risky assets"></a>Portfolio of many risky assets</h4><p><img src="/article/a0d51f4/shiym/Documents/credits_system/WechatIMG408.jpeg"></p><h3 id="1-5-2-无风险资产与风险资产的组合过程"><a href="#1-5-2-无风险资产与风险资产的组合过程" class="headerlink" title="1.5.2. 无风险资产与风险资产的组合过程"></a>1.5.2. 无风险资产与风险资产的组合过程</h3><h4 id="The-optimational-portfolio-of-risy-assets"><a href="#The-optimational-portfolio-of-risy-assets" class="headerlink" title="The optimational portfolio of risy assets"></a>The optimational portfolio of risy assets</h4><p><img src="/article/a0d51f4/shiym/Documents/credits_system/WechatIMG409.jpeg"></p><p>$$E[rp] &#x3D; rf + \frac{E[rT]-rf}{\delta T}\delta p$$</p><h4 id="Efficient-trade-off-line"><a href="#Efficient-trade-off-line" class="headerlink" title="Efficient trade-off line"></a>Efficient trade-off line</h4><p>$$rp &#x3D; rf + \frac{\vec{r_T}-rf}{\delta T}\delta p$$</p><p>$\frac{\vec{r_T}-rf}{\delta T}\delta p$是风险补偿</p><h3 id="1-5-3-两基金分离定理"><a href="#1-5-3-两基金分离定理" class="headerlink" title="1.5.3. 两基金分离定理"></a>1.5.3. 两基金分离定理</h3><h4 id="Two-funds-seperation-Theory"><a href="#Two-funds-seperation-Theory" class="headerlink" title="Two-funds seperation Theory"></a>Two-funds seperation Theory</h4><p>all investors can create an optimal portfolio by combining a risk-free asset with a market portfolio of risky assets.</p><h3 id="1-5-4-资本市场均衡与资本市场线-CML"><a href="#1-5-4-资本市场均衡与资本市场线-CML" class="headerlink" title="1.5.4. 资本市场均衡与资本市场线(CML)"></a>1.5.4. 资本市场均衡与资本市场线(CML)</h3><h4 id="Equlibrium-The-Capital-Market-Line-CML"><a href="#Equlibrium-The-Capital-Market-Line-CML" class="headerlink" title="Equlibrium: The Capital Market Line(CML)"></a>Equlibrium: The Capital Market Line(CML)</h4><p>$$E(r_p) &#x3D; r_f + \frac{E(r_M)-r_f}{\delta_M}.\delta p$$</p><h3 id="1-5-5-证券市场线-SML"><a href="#1-5-5-证券市场线-SML" class="headerlink" title="1.5.5. 证券市场线(SML)"></a>1.5.5. 证券市场线(SML)</h3><h3 id="1-5-6-CAPM的推导及综合应用"><a href="#1-5-6-CAPM的推导及综合应用" class="headerlink" title="1.5.6. CAPM的推导及综合应用"></a>1.5.6. CAPM的推导及综合应用</h3><h4 id="CAPM"><a href="#CAPM" class="headerlink" title="CAPM"></a>CAPM</h4><p>Market Portfolio &#x3D; tengency portfolio <img src="/article/a0d51f4/shiym/Documents/FinalCut/picbed/%E5%9B%BE%E5%83%8F.jpeg" alt="pic"></p><p>$$\left{\begin{aligned}&amp; E(r_p) &#x3D; r_f + \frac{[E(r_M)-r_f]}{\delta_M}.\delta_p \&amp; \delta_p^2 &#x3D; w_f^2\delta_f^2+w_M^2\delta_M^2+2w_fw_M\delta_f\delta_M\rho_{fM}\end{aligned}\right.$$</p><p>where:</p><ul><li>$[E(r_M)-r_f]$ is market risk premium</li><li>$\frac{1}{\delta_M}.\delta_p$ is Weight on portfolio</li><li>$\frac{[E(r_M)-r_f]}{\delta_M}.\delta_p$is compensation for bearing risk(risk premium)</li><li>$\frac{[E(r_M)-r_f]}{\delta_M}$ is market price of risk</li></ul><p>and we have</p><p>$$\delta_p &#x3D; w_M\delta_M$$</p><p>$\to$</p><p>$$E(r_p) &#x3D; r_f + w_M(E(r_M)-r_f)$$</p><p>$$E(r_p) &#x3D; w_fr_f + w_ME(r_M) $$</p><blockquote><p>$$\delta_p^2 &#x3D; \frac{1}{n}\bar{\delta}^2 +\frac{n-1}{n}\bar{Cov} \ (non-diversifiable) $$</p></blockquote><p>Owing to the <strong>One Price Law</strong>:</p><p>$$E(r_p) &#x3D; r_f + \frac{Cov(r_M,r_i)}{\delta_M^2}.E(r_M-r_f)$$</p><h3 id="CAPM-Capital-Asset-Pricing-Model"><a href="#CAPM-Capital-Asset-Pricing-Model" class="headerlink" title="CAPM(Capital Asset Pricing Model)"></a>CAPM(Capital Asset Pricing Model)</h3><p>$$E(r_i) &#x3D; r_f + \beta_i[E(r_M) - r_f] $$</p><p>where</p><ul><li>$r_f$ is compensation for delaying consumption</li><li>$\beta_i[E(r_M) - r_f]$ is Reward for bearing market risk</li></ul><p>$$\beta_i &#x3D; \frac{Cov(r_M,r_f)}{\delta_M^2}$$</p><ul><li>$\beta$ of market portfolio is 1</li><li>$\beta$ is the weighted average of individuel stock’s $\beta$</li></ul><h2 id="1-6-Module6-期货与期权定价与风险管理"><a href="#1-6-Module6-期货与期权定价与风险管理" class="headerlink" title="1.6. Module6 期货与期权定价与风险管理"></a>1.6. Module6 期货与期权定价与风险管理</h2><h3 id="Chapter-14-Forward-and-Future-Markets"><a href="#Chapter-14-Forward-and-Future-Markets" class="headerlink" title="Chapter 14 Forward and Future Markets"></a>Chapter 14 Forward and Future Markets</h3><h4 id="Concepts-amp-Differences-between-Forward-and-Futures"><a href="#Concepts-amp-Differences-between-Forward-and-Futures" class="headerlink" title="Concepts &amp; Differences between Forward and Futures"></a>Concepts &amp; Differences between Forward and Futures</h4><ul><li>Forward is customized</li><li>Futures is liquidity</li></ul><h4 id="The-function-of-futures"><a href="#The-function-of-futures" class="headerlink" title="The function of futures"></a>The function of futures</h4><ul><li>Hedging</li><li>Speculators</li><li>Arbitragues</li></ul><h3 id="1-6-1-期货-现货平价关系"><a href="#1-6-1-期货-现货平价关系" class="headerlink" title="1.6.1. 期货-现货平价关系"></a>1.6.1. 期货-现货平价关系</h3><h4 id="Spot-Futures-Price-Parity"><a href="#Spot-Futures-Price-Parity" class="headerlink" title="Spot-Futures Price Parity"></a>Spot-Futures Price Parity</h4><p>(Cost of Carry Model)</p><ul><li>Commodity Futures: Owing to the One Price Law $\to$</li></ul><p>$$F &#x3D; (1 + h + r_f)S_0$$</p><p>where:</p><ul><li>$F$ is delivery price</li><li>$h$ is Storage cost</li><li>$r_f$ is risk-free interest rate(funding cost)</li><li>$S_0$ is current spot price Stock futures: Cost(h) &#x3D; 0,$F&#x3D;(1+r_f)^TS_0$ Bonds futures: Complex</li></ul><h3 id="1-6-2-套期保值的基本原理"><a href="#1-6-2-套期保值的基本原理" class="headerlink" title="1.6.2. 套期保值的基本原理"></a>1.6.2. 套期保值的基本原理</h3><p>$$Spot &#x3D; Future + Bond$$</p><p>we get future can be reduplicated cause we can sell short spot</p><h4 id="Replication-of-Non-dividend-Stock"><a href="#Replication-of-Non-dividend-Stock" class="headerlink" title="Replication of Non-dividend Stock"></a>Replication of Non-dividend Stock</h4><p>Using bond and future contract</p><p>$$S &#x3D; \frac{F}{1+r_f}$$</p><h4 id="Replication-of-Pay-dividend-Stock"><a href="#Replication-of-Pay-dividend-Stock" class="headerlink" title="Replication of Pay-dividend Stock"></a>Replication of Pay-dividend Stock</h4><p>$$S &#x3D; \frac{D+F}{1+r_f}$$</p><p>$$F &#x3D; S + r_f.S-D$$</p><blockquote><p>if $D &gt; r_f.S$, the basis price is negative</p></blockquote><h3 id="Coverd-Interest-Rate-Parity-CIRP"><a href="#Coverd-Interest-Rate-Parity-CIRP" class="headerlink" title="Coverd Interest-Rate Parity(CIRP)"></a>Coverd Interest-Rate Parity(CIRP)</h3><p>the relationship between the spot exchange rate, the forward exchange rate, and the interest rates in two different countries. According to CIRP, the difference between the interest rates in two countries should be equal to the forward premium or discount of their currencies.</p><h3 id="1-6-3-期货的杠杆机制与投机交易"><a href="#1-6-3-期货的杠杆机制与投机交易" class="headerlink" title="1.6.3. 期货的杠杆机制与投机交易"></a>1.6.3. 期货的杠杆机制与投机交易</h3><p>08&#x2F;06&#x2F;2023 15:19</p><h4 id="Ch15-Market-for-Option-amp-Continent-Claims"><a href="#Ch15-Market-for-Option-amp-Continent-Claims" class="headerlink" title="Ch15 Market for Option &amp; Continent Claims"></a>Ch15 Market for Option &amp; Continent Claims</h4><h3 id="1-6-4-看涨-看跌期权平价关系"><a href="#1-6-4-看涨-看跌期权平价关系" class="headerlink" title="1.6.4. 看涨-看跌期权平价关系"></a>1.6.4. 看涨-看跌期权平价关系</h3><h4 id="Put-Call-Parity"><a href="#Put-Call-Parity" class="headerlink" title="Put-Call Parity"></a>Put-Call Parity</h4><p>$$C+E(1+r)^{-T}&#x3D;P+S$$</p><p>With Present Value Dividend D:</p><p>$$C+E(1+r)^{-T} &#x3D; P + (1-d)^{T}S$$</p><p>Where $D&#x3D;d\times S$</p><h4 id="Sythetic-Security-Replication"><a href="#Sythetic-Security-Replication" class="headerlink" title="Sythetic Security(Replication)"></a>Sythetic Security(Replication)</h4><p>Owing to One Price Law</p><p>$$C + B &#x3D; P + S$$</p><p>and we have:</p><p>$$Futures &#x3D; S - B &#x3D; C - P$$</p><h3 id="1-6-5-二项式期权定价模型"><a href="#1-6-5-二项式期权定价模型" class="headerlink" title="1.6.5. 二项式期权定价模型"></a>1.6.5. 二项式期权定价模型</h3><h4 id="Two-State-binominal-option-pricing-model"><a href="#Two-State-binominal-option-pricing-model" class="headerlink" title="Two State binominal option pricing model"></a>Two State binominal option pricing model</h4><p>(one step tree)</p><p>$$C &#x3D; x.S - \frac{y}{1+r_f}$$</p><p>$$P &#x3D; -x.S+\frac{y}{1+r_f}$$</p><p>where: x is hedging ratio &#x3D; $\frac{\Delta C}{\Delta S}$</p><h3 id="1-6-6-二阶段二项式期权定价-动态复制技术"><a href="#1-6-6-二阶段二项式期权定价-动态复制技术" class="headerlink" title="1.6.6. 二阶段二项式期权定价:动态复制技术"></a>1.6.6. 二阶段二项式期权定价:动态复制技术</h3><h4 id="Dynamic-Replication-Technique-of-option-pricing"><a href="#Dynamic-Replication-Technique-of-option-pricing" class="headerlink" title="Dynamic Replication Technique of option pricing"></a>Dynamic Replication Technique of option pricing</h4><p>(two step tree)</p><blockquote><p>and there maybe some questions about calculation</p></blockquote><h3 id="1-6-7-Black-Scholes期权定价公式"><a href="#1-6-7-Black-Scholes期权定价公式" class="headerlink" title="1.6.7. Black-Scholes期权定价公式"></a>1.6.7. Black-Scholes期权定价公式</h3><h4 id="Black-Scholes-of-option-pricing"><a href="#Black-Scholes-of-option-pricing" class="headerlink" title="Black-Scholes of option pricing"></a>Black-Scholes of option pricing</h4><p>owing to the two step tree: we have :</p><p>$$C &#x3D; x.S - \frac{y}{1+r_f}$$</p><p>and</p><p>$$C &#x3D; N(d_1)\times S - E.N(d_2).e^{-rT}$$</p><p>these two fomulas coresponding arugments are equal.</p><h3 id="1-6-8-或有权益分析-股东权益与债务的期权特征"><a href="#1-6-8-或有权益分析-股东权益与债务的期权特征" class="headerlink" title="1.6.8. 或有权益分析:股东权益与债务的期权特征"></a>1.6.8. 或有权益分析:股东权益与债务的期权特征</h3><h2 id="1-7-Module7-公司金融系统"><a href="#1-7-Module7-公司金融系统" class="headerlink" title="1.7. Module7 公司金融系统"></a>1.7. Module7 公司金融系统</h2><h3 id="1-7-1-实物期权的概念"><a href="#1-7-1-实物期权的概念" class="headerlink" title="1.7.1. 实物期权的概念"></a>1.7.1. 实物期权的概念</h3><h3 id="1-7-2-实物期权与金融期权的联系与区别"><a href="#1-7-2-实物期权与金融期权的联系与区别" class="headerlink" title="1.7.2. 实物期权与金融期权的联系与区别"></a>1.7.2. 实物期权与金融期权的联系与区别</h3><h3 id="1-7-3-资本结构无关性定理-MM定理I"><a href="#1-7-3-资本结构无关性定理-MM定理I" class="headerlink" title="1.7.3. 资本结构无关性定理(MM定理I)"></a>1.7.3. 资本结构无关性定理(MM定理I)</h3><h3 id="1-7-4-最优资本结构理论"><a href="#1-7-4-最优资本结构理论" class="headerlink" title="1.7.4. 最优资本结构理论"></a>1.7.4. 最优资本结构理论</h3><h3 id="1-7-5-加权资本成本的估计"><a href="#1-7-5-加权资本成本的估计" class="headerlink" title="1.7.5. 加权资本成本的估计"></a>1.7.5. 加权资本成本的估计</h3><h3 id="1-7-6-企业股利政策-MM定理II"><a href="#1-7-6-企业股利政策-MM定理II" class="headerlink" title="1.7.6. 企业股利政策(MM定理II)"></a>1.7.6. 企业股利政策(MM定理II)</h3>]]></content>
      
      
      <categories>
          
          <category> Course </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Finance </tag>
            
            <tag> 大二下 </tag>
            
            <tag> 金融学基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Macro Economic</title>
      <link href="/article/1540240c.html"/>
      <url>/article/1540240c.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-Chapter1-宏观经济学概述"><a href="#1-1-Chapter1-宏观经济学概述" class="headerlink" title="1.1. Chapter1 宏观经济学概述"></a>1.1. Chapter1 宏观经济学概述</h2><h3 id="1-1-1-宏观经济学的产生与发展概述"><a href="#1-1-1-宏观经济学的产生与发展概述" class="headerlink" title="1.1.1. 宏观经济学的产生与发展概述"></a>1.1.1. 宏观经济学的产生与发展概述</h3><h3 id="1-1-2-宏观经济学的基本概念"><a href="#1-1-2-宏观经济学的基本概念" class="headerlink" title="1.1.2. 宏观经济学的基本概念"></a>1.1.2. 宏观经济学的基本概念</h3><h3 id="1-1-3-国内生产总值及其核算方法"><a href="#1-1-3-国内生产总值及其核算方法" class="headerlink" title="1.1.3. 国内生产总值及其核算方法"></a>1.1.3. 国内生产总值及其核算方法</h3><p>GDP（Gross Demostic Production）<br> $Y &#x3D; C + I + NX + G$<br> GDP &#x3D; private consumption + gross private investment + government investment + government spending + (exports – imports).</p><h3 id="1-1-4-其他宏观经济指标"><a href="#1-1-4-其他宏观经济指标" class="headerlink" title="1.1.4. 其他宏观经济指标"></a>1.1.4. 其他宏观经济指标</h3><h4 id="Consumer-Price-Index"><a href="#Consumer-Price-Index" class="headerlink" title="Consumer Price Index"></a>Consumer Price Index</h4><p>This index can also be used to calculate the $inflation$:</p><p>$$inflation\ rate\ in\ year2 &#x3D; \frac{CPI year2 - CPI year1}{CPI year1}\times 100$$</p><p>which is constucted of a basket of goods and services. problems:</p><ul><li>substitution bias</li><li>introduction of new goods</li><li>unmeasured quanlity change</li></ul><p>K:capital L:labor</p><h4 id="The-production-function"><a href="#The-production-function" class="headerlink" title="The production function"></a>The production function</h4><p>$Y &#x3D; F(K,L)$</p><h4 id="AK模型"><a href="#AK模型" class="headerlink" title="AK模型"></a>AK模型</h4><p>Solow模型： $Y &#x3D; Af(\frac{K}{L})$ or $Y&#x3D;Af(k)$ :where k is tech fixed factor supplies and fixed tech.</p><p>Determing GDP:$Y&#x3D;F(\hat{K},\hat{L})$</p><h4 id="Constant-returns-to-scale"><a href="#Constant-returns-to-scale" class="headerlink" title="Constant returns to scale"></a>Constant returns to scale</h4><ul><li>decreasing returns to scale</li><li>increasing returns to scale<ul><li>if technology is fixed, then $K &#x3D; \hat{K},L &#x3D; \hat{L}$</li></ul></li></ul><h4 id="W-R-P"><a href="#W-R-P" class="headerlink" title="W R P"></a>W R P</h4><p>W: nominal wage R: nominal rental rete P: price of output W&#x2F;P: real wage R&#x2F;P: real rental rate</p><h4 id="Marginal-product-of-labor"><a href="#Marginal-product-of-labor" class="headerlink" title="Marginal product of labor"></a>Marginal product of labor</h4><p>$MPL &#x3D; F(K,L+1)-F(K,L)$</p><h4 id="Diminishing-marginal-returns"><a href="#Diminishing-marginal-returns" class="headerlink" title="Diminishing marginal returns"></a>Diminishing marginal returns</h4><p>while K is fixed and L is increasing</p><ul><li>fewer machines per worker</li><li>lower worker producting cause marginal product decreasing</li></ul><blockquote><p>the firms should hire worker s.t. $MPL &#x3D; \frac{W}{P}$</p></blockquote><h4 id="diminishing-the-rental-rate"><a href="#diminishing-the-rental-rate" class="headerlink" title="diminishing the rental rate"></a>diminishing the rental rate</h4><p>Same logic: $MPK &#x3D; \frac{R}{P}$</p><h4 id="The-neoclassical-theory-of-distribution"><a href="#The-neoclassical-theory-of-distribution" class="headerlink" title="The neoclassical theory of distribution"></a>The neoclassical theory of distribution</h4><h2 id="1-2-Chapter2-商品市场"><a href="#1-2-Chapter2-商品市场" class="headerlink" title="1.2. Chapter2 商品市场"></a>1.2. Chapter2 商品市场</h2><h3 id="Types-of-Financial-institution-and-their-function"><a href="#Types-of-Financial-institution-and-their-function" class="headerlink" title="Types of Financial institution and their function"></a>Types of Financial institution and their function</h3><h4 id="Financial-Institution"><a href="#Financial-Institution" class="headerlink" title="Financial Institution"></a>Financial Institution</h4><ul><li>the Bond Market<ul><li>Term</li><li>Credit Risk:Probability of default</li></ul></li><li>the Stock Market</li><li>Financial immediaries<ul><li>bank</li><li>mutual funds</li></ul></li></ul><h3 id="1-2-1-消费"><a href="#1-2-1-消费" class="headerlink" title="1.2.1. 消费"></a>1.2.1. 消费</h3><h3 id="1-2-2-储蓄与投资"><a href="#1-2-2-储蓄与投资" class="headerlink" title="1.2.2. 储蓄与投资"></a>1.2.2. 储蓄与投资</h3><p>Saving V.S. Investment Saving:</p><ul><li>buy stocks</li></ul><p>Investment:</p><ul><li>buying a house</li></ul><h4 id="Assumption"><a href="#Assumption" class="headerlink" title="Assumption"></a>Assumption</h4><p>As is known:</p><p>$$Y &#x3D; C + I + G + NX $$</p><p>Assumpting NX &#x3D; 0 then:</p><p>$$Y-C-G &#x3D; I$$</p><p>$$(Y-T-C)+(T-G) &#x3D; I$$</p><p>where T is Taxes and $(Y-T-C)$ is private saving $(T-G)$ is public saving when $T-G &lt;0$ $\to$ Budget Deficit when $T-G &gt; 0$ $\to$ Budget Supplies</p><h3 id="1-2-3-商品市场均衡"><a href="#1-2-3-商品市场均衡" class="headerlink" title="1.2.3. 商品市场均衡"></a>1.2.3. 商品市场均衡</h3><h4 id="How-the-financial-system-candinate-saving-amp-investment"><a href="#How-the-financial-system-candinate-saving-amp-investment" class="headerlink" title="How the financial system candinate saving &amp; investment?"></a>How the financial system candinate saving &amp; investment?</h4><h5 id="The-Market-for-Loanable-Funds"><a href="#The-Market-for-Loanable-Funds" class="headerlink" title="The Market for Loanable Funds"></a>The Market for Loanable Funds</h5><p>which y-axis is Interest rate and x-axis is Loanable Funds Supply &#x3D; Saving Demand &#x3D; Investment</p><h4 id="How-government-policies-affect-saving-investment-and-the-interest-rate"><a href="#How-government-policies-affect-saving-investment-and-the-interest-rate" class="headerlink" title="How government policies affect saving, investment and the interest rate?"></a>How government policies affect saving, investment and the interest rate?</h4><blockquote><p>by using Taxes</p></blockquote><ul><li>Saving incentive (S moves to right)</li><li>Investment incentive (D moves to right)</li><li>Government budget deficits or surpluses (S moves to left or right)</li></ul><h2 id="1-3-Chapter3-货币市场"><a href="#1-3-Chapter3-货币市场" class="headerlink" title="1.3. Chapter3 货币市场"></a>1.3. Chapter3 货币市场</h2><h3 id="1-3-1-货币简介"><a href="#1-3-1-货币简介" class="headerlink" title="1.3.1. 货币简介"></a>1.3.1. 货币简介</h3><h4 id="What-is-money"><a href="#What-is-money" class="headerlink" title="What is money?"></a>What is money?</h4><p>123 points</p><h5 id="Money-Functions-Types-of-money"><a href="#Money-Functions-Types-of-money" class="headerlink" title="Money Functions?Types of money"></a>Money Functions?Types of money</h5><ul><li><p>medium of exchange</p></li><li><p>unit of account</p></li><li><p>store of value</p></li><li><p>liquidity</p></li><li><p>Commodity money</p><ul><li>with instrinct money</li></ul></li><li><p>fiat money</p><ul><li>with govn power</li></ul></li></ul><h6 id="Money-Stock"><a href="#Money-Stock" class="headerlink" title="Money Stock"></a>Money Stock</h6><ul><li>currency</li><li>demand deposit</li></ul><h6 id="Measurement"><a href="#Measurement" class="headerlink" title="Measurement"></a>Measurement</h6><p>$M_1 : currency + Demand$ $M_2: M_1 + savings + mutual funds$</p><h6 id="For-China"><a href="#For-China" class="headerlink" title="For China"></a>For China</h6><p>There exists $M_0,M_1,M_2$</p><h3 id="1-3-2-现代金融系统和货币政策"><a href="#1-3-2-现代金融系统和货币政策" class="headerlink" title="1.3.2. 现代金融系统和货币政策"></a>1.3.2. 现代金融系统和货币政策</h3><h3 id="1-3-3-中央银行与货币政策"><a href="#1-3-3-中央银行与货币政策" class="headerlink" title="1.3.3. 中央银行与货币政策"></a>1.3.3. 中央银行与货币政策</h3><h4 id="Banlc-and-money-supply-How-banks-create-money"><a href="#Banlc-and-money-supply-How-banks-create-money" class="headerlink" title="Banlc and money supply. How banks create money?"></a>Banlc and money supply. How banks create money?</h4><ul><li>Fractional reserve Banking<ul><li>reserve ratio</li><li>reserve requirement</li><li>excess reserve</li></ul></li></ul><h4 id="How-does-the-central-bank-control-the-money-supply"><a href="#How-does-the-central-bank-control-the-money-supply" class="headerlink" title="How does the central bank control the money supply"></a>How does the central bank control the money supply</h4><p>$$Money supply &#x3D; (Initial Doposit\times \frac{1}{1-R})$$</p><h5 id="Money-Multiplier"><a href="#Money-Multiplier" class="headerlink" title="Money Multiplier"></a>Money Multiplier</h5><p>$$&#x3D; \frac{Money Supply}{Initial Doposit} &#x3D; \frac{1}{R}$$</p><h4 id="Reserve-Rate"><a href="#Reserve-Rate" class="headerlink" title="Reserve Rate"></a>Reserve Rate</h4><ul><li>Reserve Rate<ul><li>paying interest on reserves<ul><li>high -&gt; less money supply</li><li>low -&gt; more money supply</li></ul></li></ul></li><li>Discount Rate<ul><li>high -&gt; less money supply</li><li>low -&gt; more money supply</li></ul></li></ul><h3 id="1-3-4-货币数量论"><a href="#1-3-4-货币数量论" class="headerlink" title="1.3.4. 货币数量论"></a>1.3.4. 货币数量论</h3><h4 id="How-close-the-MS-affect-infiation-and-nominal-interest-rate"><a href="#How-close-the-MS-affect-infiation-and-nominal-interest-rate" class="headerlink" title="How close the MS affect infiation and nominal interest rate?"></a>How close the MS affect infiation and nominal interest rate?</h4><p>The classic theory of infiation</p><ul><li>Money supply:vertical</li><li>Money demand:downward sloping<ul><li>interest rate</li><li>the average level of price</li></ul></li></ul><h5 id="Two-conclusion"><a href="#Two-conclusion" class="headerlink" title="Two conclusion:"></a>Two conclusion:</h5><ul><li>The quantity of money determines the price level</li></ul><p>$$Price Level &#x3D; Nominal GDP &#x2F; Real GDP$$</p><ul><li>The growth of money avaiable determines inflation rate</li></ul><h5 id="The-Velocity-and-quantity-equation"><a href="#The-Velocity-and-quantity-equation" class="headerlink" title="The Velocity and quantity equation"></a>The Velocity and quantity equation</h5><h6 id="Velocity-of-money-V"><a href="#Velocity-of-money-V" class="headerlink" title="Velocity of money(V)"></a>Velocity of money(V)</h6><ul><li>Rate at which money changes hands</li></ul><p>$$V &#x3D; (P\times Y)&#x2F;M$$</p><p>where P &#x3D; Price level (GDP deflator) Y &#x3D; nominal GDP M &#x3D; money supply</p><h6 id="Quantity-equation"><a href="#Quantity-equation" class="headerlink" title="Quantity equation"></a>Quantity equation</h6><p>$$M\times V &#x3D; P\times Y$$</p><h6 id="The-infiation-Tax"><a href="#The-infiation-Tax" class="headerlink" title="The infiation Tax"></a>The infiation Tax</h6><h6 id="The-fisher-effect"><a href="#The-fisher-effect" class="headerlink" title="The fisher effect"></a>The fisher effect</h6><p>$$\frac{1+i}{1+\pi} &#x3D; 1+r$$</p><p>$$\to i &#x3D; r+\pi$$</p><p>where $i &#x3D; nominal rate$ $r &#x3D; real rate$ $\pi &#x3D; inflation rate$</p><h2 id="1-4-Chapter4-总需求与总供给"><a href="#1-4-Chapter4-总需求与总供给" class="headerlink" title="1.4. Chapter4 总需求与总供给"></a>1.4. Chapter4 总需求与总供给</h2><h3 id="1-4-1-IS-LM模型"><a href="#1-4-1-IS-LM模型" class="headerlink" title="1.4.1. IS-LM模型"></a>1.4.1. IS-LM模型</h3><h3 id="1-4-2-AD-AS模型"><a href="#1-4-2-AD-AS模型" class="headerlink" title="1.4.2. AD-AS模型"></a>1.4.2. AD-AS模型</h3><ul><li>aggregate-demand curve</li></ul><p>$$Y &#x3D; C + I + G + NX$$</p><p>for long run where: $C : wealth$ $I:interest rate$ $NX:exchange rate$ $G: assumpted policy fixed$ downward slope</p><ul><li>aggregate-supply curve</li><li>Services&amp;products upward slope</li></ul><h4 id="Natural-level-of-output-might-shift-right"><a href="#Natural-level-of-output-might-shift-right" class="headerlink" title="Natural level of output(might shift right)"></a>Natural level of output(might shift right)</h4><p>in short run:</p><ul><li>labor</li><li>capital</li><li>natural resource</li><li>technological knowledge</li></ul><h4 id="Short-run-about-AS-curve"><a href="#Short-run-about-AS-curve" class="headerlink" title="Short run about AS curve"></a>Short run about AS curve</h4><p>shifts depends on:</p><h5 id="Sticky-wage-theory"><a href="#Sticky-wage-theory" class="headerlink" title="Sticky wage theory"></a>Sticky wage theory</h5><ul><li>expected theory</li></ul><h5 id="Sticky-price-theory"><a href="#Sticky-price-theory" class="headerlink" title="Sticky-price theory"></a>Sticky-price theory</h5><ul><li>expected price(about goods&amp;services)<ul><li>adjusted to macro economics condition(unexpected)</li></ul></li></ul><h5 id="Misperceptions-theory"><a href="#Misperceptions-theory" class="headerlink" title="Misperceptions theory"></a>Misperceptions theory</h5><ul><li>unexpeted price of overall level might mislead supplies</li></ul><p>$$Quantity\ of\ output\ supplied &#x3D; Natural\ level\ of\ output + a(real\  price-expected\  price)$$</p><h3 id="1-4-3-财政政策和货币政策的影响"><a href="#1-4-3-财政政策和货币政策的影响" class="headerlink" title="1.4.3. 财政政策和货币政策的影响"></a>1.4.3. 财政政策和货币政策的影响</h3><h4 id="Economics-Fluctuations"><a href="#Economics-Fluctuations" class="headerlink" title="Economics Fluctuations"></a>Economics Fluctuations</h4><ul><li>Three fluctuations<ul><li>short run</li><li>medium run</li><li>long run</li></ul></li><li>Three variables<ul><li>real GDP</li><li>Invest Spending</li><li>Unemployment rate</li></ul></li></ul><h4 id="For-short-x2F-long-run"><a href="#For-short-x2F-long-run" class="headerlink" title="For short&#x2F;long run"></a>For short&#x2F;long run</h4><h5 id="Economics-fluctuations-in-long-run"><a href="#Economics-fluctuations-in-long-run" class="headerlink" title="Economics fluctuations in long run"></a>Economics fluctuations in long run</h5><ul><li>classic dichotomy &amp; monetary neotrality<ul><li>affect price &amp; other nominal variables</li><li>not affect real GDP</li></ul></li><li>in short run<ul><li>push the real GDP away</li></ul></li></ul><h2 id="1-5-Chapter5-失业与通货膨胀"><a href="#1-5-Chapter5-失业与通货膨胀" class="headerlink" title="1.5. Chapter5 失业与通货膨胀"></a>1.5. Chapter5 失业与通货膨胀</h2><h3 id="1-5-1-失业"><a href="#1-5-1-失业" class="headerlink" title="1.5.1. 失业"></a>1.5.1. 失业</h3><h4 id="How-is-unemployment-measured"><a href="#How-is-unemployment-measured" class="headerlink" title="How is unemployment measured"></a>How is unemployment measured</h4><h5 id="Labor-Force-Statistics"><a href="#Labor-Force-Statistics" class="headerlink" title="Labor Force Statistics"></a>Labor Force Statistics</h5><ul><li>unemployment rate(u-rate)<ul><li>&#x3D; $100\times \frac{unemployment}{labor force}$</li></ul></li><li>Labor-Paticipation Rate(LFP-rate)<ul><li>&#x3D; $100\times \frac{labor force}{population}$</li></ul></li></ul><p>$$Labor Force &#x3D; Employed + Unemployed$$</p><ul><li>lost job then finding news U-rate$\uparrow$</li><li>lost job for 1 year then exit U-rate$\downarrow$</li><li>lost job then do part-time U-rate -</li></ul><h4 id="What-is-the-natural-rate-of-unemployment"><a href="#What-is-the-natural-rate-of-unemployment" class="headerlink" title="What is the natural rate of unemployment"></a>What is the natural rate of unemployment</h4><ul><li>natural rate of unemployment</li><li>cyclical unemployment</li></ul><h4 id="Why-are-there-always-some-people-unemployed"><a href="#Why-are-there-always-some-people-unemployed" class="headerlink" title="Why are there always some people unemployed"></a>Why are there always some people unemployed</h4><ul><li>frictional unemployment</li><li>structural unemployment</li></ul><h5 id="Job-Search"><a href="#Job-Search" class="headerlink" title="Job Search"></a>Job Search</h5><ul><li>job search</li><li>sectoral shifts</li></ul><h5 id="Unemployment-Insurance"><a href="#Unemployment-Insurance" class="headerlink" title="Unemployment Insurance"></a>Unemployment Insurance</h5><h4 id="Minimum-Wage-amp-Union"><a href="#Minimum-Wage-amp-Union" class="headerlink" title="Minimum Wage &amp; Union"></a>Minimum Wage &amp; Union</h4><h4 id="Efficiency-Wage"><a href="#Efficiency-Wage" class="headerlink" title="Efficiency Wage"></a>Efficiency Wage</h4><ul><li>worker health</li><li>hiring &amp; traininig costing</li><li>worker quanlity</li><li>worker effort</li></ul><h3 id="1-5-2-通货膨胀"><a href="#1-5-2-通货膨胀" class="headerlink" title="1.5.2. 通货膨胀"></a>1.5.2. 通货膨胀</h3><h3 id="1-5-3-失业与通货膨胀的关系"><a href="#1-5-3-失业与通货膨胀的关系" class="headerlink" title="1.5.3. 失业与通货膨胀的关系"></a>1.5.3. 失业与通货膨胀的关系</h3><h2 id="1-6-Chapter6-经济增长"><a href="#1-6-Chapter6-经济增长" class="headerlink" title="1.6. Chapter6 经济增长"></a>1.6. Chapter6 经济增长</h2><h3 id="1-6-1-经济增长概述"><a href="#1-6-1-经济增长概述" class="headerlink" title="1.6.1. 经济增长概述"></a>1.6.1. 经济增长概述</h3><h3 id="1-6-2-影响经济增长的公共政策"><a href="#1-6-2-影响经济增长的公共政策" class="headerlink" title="1.6.2. 影响经济增长的公共政策"></a>1.6.2. 影响经济增长的公共政策</h3><h3 id="1-6-3-中国的经济增长"><a href="#1-6-3-中国的经济增长" class="headerlink" title="1.6.3. 中国的经济增长"></a>1.6.3. 中国的经济增长</h3><h2 id="1-7-Chapter7-开放经济"><a href="#1-7-Chapter7-开放经济" class="headerlink" title="1.7. Chapter7 开放经济"></a>1.7. Chapter7 开放经济</h2><h3 id="1-7-1-开放经济的基本概念"><a href="#1-7-1-开放经济的基本概念" class="headerlink" title="1.7.1. 开放经济的基本概念"></a>1.7.1. 开放经济的基本概念</h3><h3 id="1-7-2-开放经济的基本理论及应用"><a href="#1-7-2-开放经济的基本理论及应用" class="headerlink" title="1.7.2. 开放经济的基本理论及应用"></a>1.7.2. 开放经济的基本理论及应用</h3>]]></content>
      
      
      <categories>
          
          <category> Course </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二下 </tag>
            
            <tag> 宏观经济学 </tag>
            
            <tag> Macro Economic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据挖掘与大数据分析</title>
      <link href="/article/5d312595.html"/>
      <url>/article/5d312595.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-Chapter1-数据挖掘与大数据简介"><a href="#1-1-Chapter1-数据挖掘与大数据简介" class="headerlink" title="1.1. Chapter1 数据挖掘与大数据简介"></a>1.1. Chapter1 数据挖掘与大数据简介</h2><h3 id="1-1-1-什么是大数据"><a href="#1-1-1-什么是大数据" class="headerlink" title="1.1.1. 什么是大数据"></a>1.1.1. 什么是大数据</h3><blockquote><p>Big data is a buzzword, or catch-phrase, used to describe a massive volume of both structed and unstructured data that is so large that it’s difficult to process using traditional database and software techniques.</p></blockquote><h3 id="1-1-2-大数据的定义与理念"><a href="#1-1-2-大数据的定义与理念" class="headerlink" title="1.1.2. 大数据的定义与理念"></a>1.1.2. 大数据的定义与理念</h3><p>Four features of Big data:</p><ul><li>Volume<ul><li>Scale of data</li></ul></li><li>Variety:<ul><li>Different forms of data</li></ul></li><li>Velocity:<ul><li>Analysis of streaming data</li></ul></li><li>Veracity:<ul><li>Uncertainy of data</li></ul></li></ul><h3 id="1-1-3-数据挖掘产生的背景及原因"><a href="#1-1-3-数据挖掘产生的背景及原因" class="headerlink" title="1.1.3. 数据挖掘产生的背景及原因"></a>1.1.3. 数据挖掘产生的背景及原因</h3><ul><li>存储能力的提升</li><li>计算能力的提升</li><li>海量的数据生成</li></ul><blockquote><p>我们浸没在数据的海洋, 却渴望知识的淡水</p></blockquote><p>通过数据挖掘从矿山中获得有用的信息</p><h3 id="1-1-4-什么是数据挖掘以及在何种数据上挖掘"><a href="#1-1-4-什么是数据挖掘以及在何种数据上挖掘" class="headerlink" title="1.1.4. 什么是数据挖掘以及在何种数据上挖掘"></a>1.1.4. 什么是数据挖掘以及在何种数据上挖掘</h3><blockquote><p>Data mining consists of applying data analysis and discovery algorithms that, under acceptable computational efficiency limitations, produce a particular enumeration of patterns over the data.</p></blockquote><p>KDD过程:</p><p>$$数据清洗\to 数据集成\to 数据选择\to 变换\to 数据挖掘\to 模式评估\to 知识表示(可视化)$$</p><h3 id="1-1-5-数据挖掘的应用"><a href="#1-1-5-数据挖掘的应用" class="headerlink" title="1.1.5. 数据挖掘的应用"></a>1.1.5. 数据挖掘的应用</h3><ul><li>流感预测</li><li>电信推销</li><li>银行借贷</li><li>保险识别</li><li>等</li></ul><h3 id="1-1-6-数据挖掘的主要功能"><a href="#1-1-6-数据挖掘的主要功能" class="headerlink" title="1.1.6. 数据挖掘的主要功能"></a>1.1.6. 数据挖掘的主要功能</h3><ol><li>关联规则挖掘(关联分析)</li></ol><blockquote><p>发现数据之间的关联规则, 这些规则展示属性&#x2F;值频繁的再给定的数据中所一起出现的条件</p></blockquote><p>应用: 每当暴风季节来临, 美国沃尔玛的飓风用品和蛋挞销量都会增加,所以把二者放在一起销售可以提高销量.</p><p>Example: 空气质量与气象之间的关联挖掘<br>2. 聚类分析 （无标签）</p><blockquote><p>把类似的数据归类到一起,形成一个新的类别进行分析</p></blockquote><p>   Example: 大脑神经纤维聚类<br>3. 分类&#x2F;预测 （有标签</p><blockquote><p>找出描述和区分数据类&#x2F;概念的模型, 用以使模型能预测未知的对象类标签</p></blockquote><ol start="4"><li>孤立点(离群点)检测</li></ol><blockquote><p>孤立点:一些与数据的一般行为或模型不一致的孤立数据</p></blockquote><p>   通常孤立点被作为”噪声”或异常被丢弃, 但是在欺骗检测中可以通过对罕见事件进行孤立点分析得到结论</p><h3 id="1-1-7-数据挖掘面临的挑战"><a href="#1-1-7-数据挖掘面临的挑战" class="headerlink" title="1.1.7. 数据挖掘面临的挑战"></a>1.1.7. 数据挖掘面临的挑战</h3><ul><li>数据容量(Scale of Data)<ul><li>Scalable Data Mining Algorithms<ul><li>Novel scalable algorithms(Sampling, Hashing, Divide-and-Conquer, etc)</li><li>Map-reduce oriented Parallell platforms(Hadoop, Spark, GraphLab)</li><li>Speed-up Hardwares(GPUs&#x2F;Clouds&#x2F;Clusters)</li></ul></li></ul></li><li>数据实时性(Data Stream)<ul><li>Data Stream Mining<ul><li>Handle Evolving Data Streams</li><li>Clustering on Massive Data Streams</li><li>Classification&#x2F;Regression on Data Streams</li><li>Outlier Detection on Data Streams</li></ul></li></ul></li><li>数据多样性(Different types of data)<ul><li>Multi-source or multi-type data mining<ul><li>Different types of data(Categorical&#x2F;nominal data, mixed-type data mining)</li><li>Different forms of data(vector data, graph data, image data, text data, hetergeneous data)</li><li>Learning on different sources of data(Multi-view learning, Transfer learning, Multi-task learning, etc)</li><li>Data fusion or data integration(multiple-kernel learning)</li></ul></li></ul></li><li>数据不确定性(Uncertainty, missing value)<ul><li>Uncertainty Analysis, Link&#x2F;Missing value prediction<ul><li>Uncertain data Clustering(Probability-function based)</li><li>Link Prediction(Clustering-based, Structure-based, Multi-view based)</li><li>Recommender System(Missing items prediction,…)</li><li>Robust Machine Learning(Adversarial Examples)</li></ul></li></ul></li></ul><h2 id="1-2-Chapter2-认识数据与数据预处理"><a href="#1-2-Chapter2-认识数据与数据预处理" class="headerlink" title="1.2. Chapter2 认识数据与数据预处理"></a>1.2. Chapter2 认识数据与数据预处理</h2><h3 id="1-2-1-认识数据"><a href="#1-2-1-认识数据" class="headerlink" title="1.2.1. 认识数据"></a>1.2.1. 认识数据</h3><h4 id="数据相似性度量"><a href="#数据相似性度量" class="headerlink" title="数据相似性度量"></a>数据相似性度量</h4><h5 id="标称"><a href="#标称" class="headerlink" title="标称"></a>标称</h5><ul><li>标称</li></ul><p>$d(i,j) &#x3D; \frac{p-m}{p}$</p><ul><li>非对称</li></ul><p>$d(i,j) &#x3D; \frac{\ Differences}{Total -(0)}$<br>雅各比距离</p><ul><li>序数：转换到（0，1）</li></ul><p>$Z_1 &#x3D; \frac{Z_{n-r}-1}{R(Rank)-1}$</p><h5 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h5><p>闵可夫斯基距离</p><ul><li>曼哈顿距离 p &#x3D; 1</li><li>欧氏距离 p &#x3D; 2</li></ul><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul><li>余弦相似性</li><li>相关系数</li><li>马氏距离（不考 考虑局部分布的距离）</li><li>KL散度（复杂 计算分布的差异性）</li></ul><h3 id="1-2-2-为什么要预处理数据"><a href="#1-2-2-为什么要预处理数据" class="headerlink" title="1.2.2. 为什么要预处理数据"></a>1.2.2. 为什么要预处理数据</h3><h3 id="1-2-3-数据清洗"><a href="#1-2-3-数据清洗" class="headerlink" title="1.2.3. 数据清洗"></a>1.2.3. 数据清洗</h3><ul><li>空缺值 <ul><li>平均值代替空值</li><li>直接删去</li><li>矩阵分解（不考）<ul><li>如果是nominal类型的数据就是采用大多数类型赋值</li></ul></li></ul></li><li>去噪<ul><li>平滑值</li><li>利用中值滤波</li></ul></li></ul><h3 id="1-2-4-数据集成和变换"><a href="#1-2-4-数据集成和变换" class="headerlink" title="1.2.4. 数据集成和变换"></a>1.2.4. 数据集成和变换</h3><ul><li>数值值 相关分析</li><li>标称型 卡方分析（考试计算）</li></ul><p>$$\chi^2 &#x3D; \frac{\sum_{i&#x3D;1}^{n}(a_{ij}-e_{ij})^2}{e_{ij}}$$<br>$$e_{ij} &#x3D; \frac{cout(a_i&#x3D;a)\times cout(b_i &#x3D; b)}{N}$$</p><p>变换是为了规范化</p><ul><li>最小最大规范化<br>$$Z_i &#x3D; \frac{x_i - minV}{maxV - minV}$$</li><li>z- score 把变量当成正态分布进行标准化操作<br>$$\frac{x_i - \mu}{\delta}$$</li></ul><h3 id="1-2-5-数据归约"><a href="#1-2-5-数据归约" class="headerlink" title="1.2.5. 数据归约"></a>1.2.5. 数据归约</h3><h4 id="维度归约"><a href="#维度归约" class="headerlink" title="维度归约"></a>维度归约</h4><ul><li>降维<ul><li>PCA主成分分析（方差最大化）</li><li>小波分析</li></ul></li><li>特征筛选<ul><li>信息增益 - 信息熵</li><li>（均匀分布熵最大）</li></ul></li></ul><h4 id="数量归约"><a href="#数量归约" class="headerlink" title="数量归约"></a>数量归约</h4><ul><li>直方图</li><li>聚类</li><li>采样</li></ul><h3 id="数据离散化处理"><a href="#数据离散化处理" class="headerlink" title="数据离散化处理"></a>数据离散化处理</h3><p>比如年龄、身高、体重</p><h2 id="1-3-Chapter3-关联规则挖掘"><a href="#1-3-Chapter3-关联规则挖掘" class="headerlink" title="1.3. Chapter3 关联规则挖掘"></a>1.3. Chapter3 关联规则挖掘</h2><h3 id="1-3-1-关联规则概述"><a href="#1-3-1-关联规则概述" class="headerlink" title="1.3.1. 关联规则概述"></a>1.3.1. 关联规则概述</h3><ul><li>支持度</li><li>置信度</li><li>频繁项集<ul><li>项集<ul><li>项 其中（少青老、高低、胖瘦）属于nominal</li></ul></li></ul></li><li>Brute Force 蛮力算法（类似于决策树）<ul><li>降低候选集需要使用Aprior算法，利用两条性质<ul><li>频繁子集也频繁</li><li>不频繁超急也不频繁</li></ul></li></ul></li></ul><h3 id="1-3-2-由事务数据库挖掘关联规则"><a href="#1-3-2-由事务数据库挖掘关联规则" class="headerlink" title="1.3.2. 由事务数据库挖掘关联规则"></a>1.3.2. 由事务数据库挖掘关联规则</h3><h3 id="1-3-3-FP增长树算法"><a href="#1-3-3-FP增长树算法" class="headerlink" title="1.3.3. FP增长树算法"></a>1.3.3. FP增长树算法</h3><h3 id="1-3-4-关联模式的评估"><a href="#1-3-4-关联模式的评估" class="headerlink" title="1.3.4. 关联模式的评估"></a>1.3.4. 关联模式的评估</h3><p>不重要</p><h2 id="1-4-Chapter4-分类"><a href="#1-4-Chapter4-分类" class="headerlink" title="1.4. Chapter4 分类"></a>1.4. Chapter4 分类</h2><h3 id="1-4-1-分类和预测概述"><a href="#1-4-1-分类和预测概述" class="headerlink" title="1.4.1. 分类和预测概述"></a>1.4.1. 分类和预测概述</h3><ul><li>有监督学习（连续型数据，既有feature也有label）</li><li>无监督学习（离散型数据，只有feature没有label）<ul><li>Generative Model<ul><li>Naive Bayers</li></ul></li><li>Discriminative Model<ul><li>SVM、Decision Tree</li></ul></li></ul></li></ul><h3 id="1-4-2-决策树分类算法"><a href="#1-4-2-决策树分类算法" class="headerlink" title="1.4.2. 决策树分类算法"></a>1.4.2. 决策树分类算法</h3><h4 id="信息增益选择划分节点（ID3）"><a href="#信息增益选择划分节点（ID3）" class="headerlink" title="信息增益选择划分节点（ID3）"></a><strong>信息增益</strong>选择划分节点（ID3）</h4><p>信息增益率（C4.5）<br>$$信息熵E &#x3D; -\sum_{i &#x3D;1}^{n}p_ilogp_i$$<br>信息增益率为两次作差再比上第一次的信息熵<br>Gini率（CART）<br>$$Gini(D) &#x3D; 1-\sum_{i&#x3D;1}^{n}p_i^2$$<br>测算不纯度，和信息增益反过来</p><h4 id="过拟合问题"><a href="#过拟合问题" class="headerlink" title="过拟合问题"></a>过拟合问题</h4><p>过拟合原因是数据量太小<br>剪枝可以降低过拟合</p><h3 id="1-4-3-KNN最邻近算法"><a href="#1-4-3-KNN最邻近算法" class="headerlink" title="1.4.3. KNN最邻近算法"></a>1.4.3. KNN最邻近算法</h3><p>K-nearest-neighbor<br>优缺点<br>性能问题</p><h3 id="1-4-4-朴素贝叶斯分类算法"><a href="#1-4-4-朴素贝叶斯分类算法" class="headerlink" title="1.4.4. 朴素贝叶斯分类算法"></a>1.4.4. 朴素贝叶斯分类算法</h3><p>Naive-Bayers<br>$$Pr(c|x) &#x3D; \frac{Pr(c\cap x)}{Pr(x)} &#x3D; \frac{Pr(c)Pr(x|c)}{Pr(x)}$$<br>Where $Pr(c|x)$ is Posterior  probability and $Pr(c)$ is Prior probability.<br>And $Pr(x|c)$ is 似然概率.</p><h3 id="1-4-5-SVM和其他经典分类方法"><a href="#1-4-5-SVM和其他经典分类方法" class="headerlink" title="1.4.5. SVM和其他经典分类方法"></a>1.4.5. SVM和其他经典分类方法</h3><p>Support Vector Machine<br>$Y^* &#x3D; H(x|\theta)$<br>for Training :<br>Empired Risk<br>$$min\sum_{i &#x3D; 1}^{n}(Y_i^*-Y_i)^2 \to loss$$<br>核心问题：最大间隔化</p><h3 id="w、b使分类正确"><a href="#w、b使分类正确" class="headerlink" title="w、b使分类正确"></a>w、b使分类正确</h3><p> $wx_i +b\geq 1$<br> $wx_i+b\leq 1$<br> $\to$ $y_i(wx_i+b)\geq 1$</p><h3 id="距离最大间隔"><a href="#距离最大间隔" class="headerlink" title="距离最大间隔"></a>距离最大间隔</h3><p>$$d(x_0,wx+b &#x3D; 0) &#x3D; \frac{|wx_0+b|}{||w||} &#x3D; \frac{1}{||w||}$$<br>使用拉格朗日乘子法<br>求解凸二次规划问题</p><ul><li>convex</li><li>KTT condition<br>从极大值求极小值</li></ul><h3 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h3><p>Kernel Function<br>$$K(x_1,x_2) &#x3D; \Phi (x_1) * \Phi(x_2)$$<br>通过低维到高维的映射，使线性不可分 $\to$ 线性可分</p><h3 id="ANN"><a href="#ANN" class="headerlink" title="ANN"></a>ANN</h3><p>Artificial Nerual Nerwork</p><h4 id="作用函数"><a href="#作用函数" class="headerlink" title="作用函数"></a>作用函数</h4><ul><li>阈值型<br>等两个</li></ul><h4 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h4><ul><li>FeedForward(一般神经元都是全连接)</li><li>FeedBack（类似于时序逻辑电路，输入受输出的影响）</li></ul><h4 id="优化模型"><a href="#优化模型" class="headerlink" title="优化模型"></a>优化模型</h4><ul><li>调整权重<ul><li>相关学习（旧方法）</li><li>误差修正学习<br>$\delta$学习规则（改权值）<br>$$w_{ji}(t+1)&#x3D;w_{ji}(t)+\eta[d_j-y_j(t)]x_i(t)$$</li></ul></li></ul><h3 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h3><h3 id="后向传播算法（BP）"><a href="#后向传播算法（BP）" class="headerlink" title="后向传播算法（BP）"></a>后向传播算法（BP）</h3><ul><li>信息的正向输入</li><li>误差的反向传播<ul><li>利用梯度下降</li></ul></li></ul><h3 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h3><ul><li>同质（多）&#x2F;异质（少）<ul><li>增加学习器的多样性</li></ul></li><li>Bagging<ul><li>Random Forest<ul><li>传统决策树节点利用信息增益选出划分</li><li>RF算法随机选每个节点中的k个属性，再选最优划分（增加随机性）</li></ul></li></ul></li><li>Boosting<ul><li>(Ada-Boost)由弱到强<ul><li>关注错误，增大权重，调整样本，n个学习器套娃</li></ul></li></ul></li><li>Stacking <ul><li>对初始样本集–处理后的新样本集（经过初级学习器）</li></ul></li></ul><h3 id="1-4-6-分类算法评估"><a href="#1-4-6-分类算法评估" class="headerlink" title="1.4.6. 分类算法评估"></a>1.4.6. 分类算法评估</h3><h4 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h4><ul><li>精确度<br>$$Accuracy &#x3D; (TP+TN)&#x2F;ALL$$</li><li>误差率<br>$$(FP+FN)&#x2F;ALL$$</li><li>$F_1$分数<br>$$F_1 &#x3D; \frac{2\times Precision\times Recall}{Precision+Recall}$$</li><li>Precision<br>$$Precision &#x3D; \frac{TP}{TP+FP}$$</li><li>Recall<br>$$Recall &#x3D; \frac{TP}{TP+FN}$$</li></ul><h2 id="1-5-Chapter5-聚类分析和噪声检测"><a href="#1-5-Chapter5-聚类分析和噪声检测" class="headerlink" title="1.5. Chapter5 聚类分析和噪声检测"></a>1.5. Chapter5 聚类分析和噪声检测</h2><h3 id="1-5-1-聚类分析概述"><a href="#1-5-1-聚类分析概述" class="headerlink" title="1.5.1. 聚类分析概述"></a>1.5.1. 聚类分析概述</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote><p>聚类分析是一种数据挖掘技术，将数据集中的对象按照相似性分成不同的簇（cluster），每个簇内的对象都具有较高的相似性，而不同簇之间的对象则具有较大的差异性。<br>应用巨大：</p></blockquote><ul><li>价格歧视为用户制定画像</li><li>数据预处理</li><li>离群点检测</li><li>等等</li></ul><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>找出数据中潜在的自然规律</p><h4 id="划分方法（Partitioning-method）"><a href="#划分方法（Partitioning-method）" class="headerlink" title="划分方法（Partitioning method）"></a>划分方法（Partitioning method）</h4><h5 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h5><p>目标函数：<br>$$min\sum_{i&#x3D;1}^{k}\sum_{x_i-x_j}(x_i-x_j)^2-\sum_{i&#x3D;1}^k\sum_{x_i\in C_k}\sum_{x_j\in C_m}(x_i-x_j)^2$$<br>这玩意谁算的过来，so<br>$$E &#x3D; \sum_{i&#x3D;1}^k\sum_{x\in C_i}|x-\hat{x_i}|^2$$<br>which:<br>$\hat{x_i}$ 是第 $i$个簇的均值</p><p>$C_i$为第 $i$ 个簇</p><h3 id="1-5-2-聚类分析中的数据类型"><a href="#1-5-2-聚类分析中的数据类型" class="headerlink" title="1.5.2. 聚类分析中的数据类型"></a>1.5.2. 聚类分析中的数据类型</h3><h4 id="基于划分"><a href="#基于划分" class="headerlink" title="基于划分"></a>基于划分</h4><h4 id="基于层次"><a href="#基于层次" class="headerlink" title="基于层次"></a>基于层次</h4><ul><li>凝聚<ul><li>AGNES</li></ul></li><li>分裂<ul><li>DIANA</li></ul></li></ul><h4 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h4><ul><li>minimum distance</li><li>maximum distance</li><li>mean distance</li></ul><h3 id="1-5-3-聚类分析方法"><a href="#1-5-3-聚类分析方法" class="headerlink" title="1.5.3. 聚类分析方法"></a>1.5.3. 聚类分析方法</h3><h4 id="DBSCAN-Destiny-Based-Spatial-Clusters-of-Applications-with-Noise"><a href="#DBSCAN-Destiny-Based-Spatial-Clusters-of-Applications-with-Noise" class="headerlink" title="DBSCAN Destiny-Based Spatial Clusters of Applications with Noise"></a>DBSCAN Destiny-Based Spatial Clusters of Applications with Noise</h4><ul><li>$\epsilon$邻域</li><li>核心对象</li><li>直接密度可达</li><li>间接密度可达</li></ul><p>从k的选取改为$\epsilon$与MinPst的选取<br>I&#x2F;O开销比较大</p><h4 id="网格聚类"><a href="#网格聚类" class="headerlink" title="网格聚类"></a>网格聚类</h4><h5 id="STING算法"><a href="#STING算法" class="headerlink" title="STING算法"></a>STING算法</h5><p>Statistical Information Grid-based Method<br>多分辨率聚类技术</p><h3 id="补充内容（无监督学习）"><a href="#补充内容（无监督学习）" class="headerlink" title="* 补充内容（无监督学习）"></a>* 补充内容（无监督学习）</h3><h4 id="Auto-Encoder"><a href="#Auto-Encoder" class="headerlink" title="Auto Encoder"></a>Auto Encoder</h4><p>$$X \to Encoder \to E \to Decoder \to X’$$<br>Expection: $min||X-X’||$</p><h4 id="Word2Vector-词向量"><a href="#Word2Vector-词向量" class="headerlink" title="Word2Vector(词向量)"></a>Word2Vector(词向量)</h4><p>相似性度量<br>由词带模型推广<br>缺点：<br>    举个例子，you love I， I love you<br>    都可以表示为101，但是词义不同</p><h4 id="提示补全"><a href="#提示补全" class="headerlink" title="提示补全"></a>提示补全</h4><p>比如 I love __ , 这个__ 就是利用极大似然估计推断可能是“you”。<br>$$f(x|\theta) &#x3D; \prod_{i&#x3D;1}^{n}f(x_i|\theta)$$<br>使得联合概率密度最大</p><p>$$Pr(\omega_1,\omega_2,…,\omega_n|context(\omega_i))$$<br>$$log\prod_{i&#x3D;1}^{N}Pr(\omega_i|context(\omega_i))$$<br>$$max\sum_{i&#x3D;1}^{N}logPr(\omega_i|context(\omega_i))$$<br>然后使用$sigmoid$函数</p><h3 id="异常点检测"><a href="#异常点检测" class="headerlink" title="异常点检测"></a>异常点检测</h3><h4 id="基于距离的检测"><a href="#基于距离的检测" class="headerlink" title="基于距离的检测"></a>基于距离的检测</h4><p>低维中使用</p><ul><li>基于单元（cell- based）的算法</li></ul><h4 id="基于统计量的检测"><a href="#基于统计量的检测" class="headerlink" title="基于统计量的检测"></a>基于统计量的检测</h4><p>需要知道分布（现实情况中有些不知道）</p><h4 id="基于偏离的检测"><a href="#基于偏离的检测" class="headerlink" title="基于偏离的检测"></a>基于偏离的检测</h4><ul><li>基于序列<ul><li>模仿人类推理、去除方差</li><li>平滑因子（smoothing factor）</li></ul></li><li>异常集（exception set）</li></ul><h4 id="基于密度的方法（LOF）"><a href="#基于密度的方法（LOF）" class="headerlink" title="基于密度的方法（LOF）"></a>基于密度的方法（LOF）</h4><ul><li>对象p的k距离（$k- distance$）</li><li>对象p的k邻域（$N_k-distance$）<ul><li>关于这个$N_k-distance$有个计算公式</li></ul></li><li>对象p相对于O的可达距离<ul><li>$$reach-distance(p,o) &#x3D; max{k-distance(p),d(p,o)}$$</li></ul></li><li>对象p的局部可达密度（Local Reachable Distance）<ul><li>$$lrdMinPst(p) &#x3D; 1&#x2F; \frac{o\in N_MinPst(p)\sum reach-distMinPst(p,o)}{NMinPst(p)}$$</li></ul></li><li>对象p的局部异常因子（Local Outlier Factor）<ul><li>$$LOF_{MinPts}(p)&#x3D;\frac{\sum_{o\in N_{MinPts(p)}} \frac{lrd_{MinPts}(o)}{lrd_{MinPts}(p)}}{|N_{MinPts}(p)|}$$</li></ul></li></ul><h4 id="Synchronization"><a href="#Synchronization" class="headerlink" title="Synchronization"></a>Synchronization</h4><p>压缩簇、最后剩下的就都是outliers</p><h2 id="1-6-Chapter6-大数据分析"><a href="#1-6-Chapter6-大数据分析" class="headerlink" title="1.6. Chapter6 大数据分析"></a>1.6. Chapter6 大数据分析</h2><ol><li>哈希的作用</li><li>k- shingling（k from 3-10）</li><li>MinHash<br> 3.1 定义：首次提出行号<br> 3.2 如何计算签名矩阵<br> 3.3 可选&#x2F;近似<br>$$sim(c_1,c_2) &#x3D; \frac{a}{a+b+c} &#x3D; Pr(h(c_1))&#x3D;h(c_2)$$</li><li>LSH（局部敏感哈希）<br> 4.1 基本思想： Hash Bond<br> take the similarities into different bucket</li></ol><h3 id="1-6-1-大数据简介"><a href="#1-6-1-大数据简介" class="headerlink" title="1.6.1. 大数据简介"></a>1.6.1. 大数据简介</h3><h3 id="1-6-2-哈希技术"><a href="#1-6-2-哈希技术" class="headerlink" title="1.6.2. 哈希技术"></a>1.6.2. 哈希技术</h3><ul><li>信息检索</li><li>存储</li><li>最邻近点检索</li></ul><h4 id="局部敏感哈希（LSH）"><a href="#局部敏感哈希（LSH）" class="headerlink" title="局部敏感哈希（LSH）"></a>局部敏感哈希（LSH）</h4><ol><li>shingling： convert document emails … – sets</li><li>Minhashing: large sets -&gt; signature</li><li>locality-sensitive hashing:focus on pairs of signatures</li></ol><h3 id="1-6-3-数据流挖掘"><a href="#1-6-3-数据流挖掘" class="headerlink" title="1.6.3. 数据流挖掘"></a>1.6.3. 数据流挖掘</h3><h4 id="数据流（Data-Stream）-lt-x3D-实时性"><a href="#数据流（Data-Stream）-lt-x3D-实时性" class="headerlink" title="数据流（Data Stream） &lt;&#x3D; 实时性"></a>数据流（Data Stream） &lt;&#x3D; 实时性</h4><h4 id="Concept-Drift"><a href="#Concept-Drift" class="headerlink" title="Concept Drift"></a>Concept Drift</h4><p>hyper-plane</p><h4 id="Concept-Drift-Detection"><a href="#Concept-Drift-Detection" class="headerlink" title="Concept Drift Detection"></a>Concept Drift Detection</h4><ul><li>Distribution-based detector<ul><li>Adaptive window(ADWIN)</li><li>Error-rate Based detector</li><li>DDM</li></ul></li><li>KNN(可以直接处理Concept Drift Detection，需要压缩数据)</li><li>SVM等需要</li></ul><h4 id="VFDT-very-fast-dicision-tree"><a href="#VFDT-very-fast-dicision-tree" class="headerlink" title="VFDT(very fast dicision tree)"></a>VFDT(very fast dicision tree)</h4><p>$$\overline{G}(x_i) - \overline{G}(x_j) &gt; \epsilon$$<br>处理流式数据</p><h4 id="Data-Stream-Cluster"><a href="#Data-Stream-Cluster" class="headerlink" title="Data Stream Cluster"></a>Data Stream Cluster</h4><p>The clustream framework<br>线上阶段： 压缩（数据结构）<br>线下阶段： k-means，DBSCAN、STING</p><h5 id="Micro-Cluster-微簇"><a href="#Micro-Cluster-微簇" class="headerlink" title="Micro Cluster 微簇"></a>Micro Cluster 微簇</h5><h6 id="Cluster-feature"><a href="#Cluster-feature" class="headerlink" title="Cluster feature"></a>Cluster feature</h6><p>$$CF &#x3D; (N,\vec{LS},\vec{SS})$$<br>Where:<br>N : <code>data point</code><br>LS &#x3D;  $\sum_{i&#x3D;1}^{N}\vec{X_i}$<br>SS &#x3D; $\sum_{i&#x3D;1}^{N}\vec{X_i}^2$</p><p> Stream:<br> $$CF(N+1,\vec{LS}+x,\vec{SS}+x^2)$$<br>     key point: additivity property</p><p>压缩everything from a circle into a array</p><h4 id="Clusteam-Pyramical-Time-Frame"><a href="#Clusteam-Pyramical-Time-Frame" class="headerlink" title="Clusteam : Pyramical Time Frame"></a>Clusteam : Pyramical Time Frame</h4><p>金字塔时间窗口</p><h3 id="1-6-4-大数据处理平台-Hadoop-x2F-Spark"><a href="#1-6-4-大数据处理平台-Hadoop-x2F-Spark" class="headerlink" title="1.6.4. 大数据处理平台 Hadoop&#x2F;Spark"></a>1.6.4. 大数据处理平台 Hadoop&#x2F;Spark</h3><p> 复习：</p><ol><li>数据流面临的挑战</li><li>什么是概念漂移$P(c|x)$</li><li>概念漂移检测方法<br> 3.1 基于分布（缺点）<br> 3.2 基于错误率 （$3\sigma$ 原则）</li><li>分类（VFDT）<br> Hoeffding Tree:<br> VFDT（Very Fast Decision Tree）算法中，有一种基于 Hoeffding 不等式的增量式决策树叫做 Hoeffding Tree。Hoeffding Tree 是 VFDT 算法的一种实现方式，它使用 Hoeffding 不等式来估计节点分裂的置信度，并在满足一定置信度要求时进行节点分裂，从而构建出决策树模型。与传统的决策树算法不同，Hoeffding Tree 可以在处理大规模数据时快速构建决策树，并且具有较好的泛化性能和可解释性。</li><li>数据流聚类<br> 5.1 在线数据抽象<br> $CF(N,\vec{LS},\vec{SS}$)<br> 5.2 线下聚类（DBSCAN，k-means）</li></ol><h4 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h4><p>分布式并行计算 parallel<br>心跳机制判断单点故障<br>Essence：Divide and Conquer</p><ul><li>HDFS: Hadoop Distribution File System<ul><li>Centralized namenode<ul><li>maintains metedata info about files</li></ul></li><li>Data Nodes<ul><li>Files are divided into blocks</li></ul></li></ul></li></ul><h4 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h4><p>Reduce I&#x2F;O Costs, use cache<br>弹性分布式数据集（Resilient distributed datasets）<br>Essentials：</p><ul><li>Transformations</li></ul><h1 id="期末复习"><a href="#期末复习" class="headerlink" title="期末复习"></a>期末复习</h1><h1 id="CH1-简介"><a href="#CH1-简介" class="headerlink" title="CH1 简介"></a>CH1 简介</h1><ol><li>什么是大数据</li><li>大数据三大驱动力</li><li>大数据4V特征</li><li>什么是数据挖掘</li><li>（重点）知识发现的流程是什么？（核心：数据挖掘）</li><li>数据挖掘的四大任务<ol><li>关联规则挖掘</li><li>分类&#x2F;回归</li><li>聚类分析</li><li>离群点检测</li></ol></li><li>数据挖掘与其他学科的关系<ol><li>数学&#x2F;机器学习&#x2F;统计</li></ol></li></ol><h1 id="CH2-认识数据与数据预处理"><a href="#CH2-认识数据与数据预处理" class="headerlink" title="CH2 认识数据与数据预处理"></a>CH2 认识数据与数据预处理</h1><ol><li>数据对象属性<ol><li>分类性（离散）<ol><li>标称型</li><li>序数型</li></ol></li><li>数值型（连续）</li></ol></li><li>二值型<ol><li>对称</li><li>非对称</li></ol></li><li>数据类型</li><li>数据相似性度量<ol><li>标称型（非对称二值型）</li><li>序数型</li><li>数值型<ol><li>欧氏距离</li><li>曼哈顿距离</li><li>闵可夫斯基距离</li></ol></li></ol></li><li>其他度量<ol><li>余弦距离</li><li>相关系数</li><li>（*）马氏距离</li><li>（*）KL散度</li></ol></li><li>数据描述<ol><li>中心性描述<ol><li>均值&#x2F;中位数&#x2F;中间数&#x2F;众数</li></ol></li><li>散度描述<ol><li>方差&#x2F;标准差&#x2F;百分位数&#x2F;极差</li></ol></li></ol></li><li>数据预处理（可选）<ol><li>数据清理<ol><li>缺失值填充<ol><li>忽略&#x2F;NaN&#x2F;均值&#x2F;类似值&#x2F;预测</li></ol></li><li>噪声<ol><li>平滑、滤波 </li><li>离群点检测</li></ol></li></ol></li><li>数据集成<ol><li>相关分析<ol><li>分类（标称）</li><li>数值（相关系数）</li></ol></li><li>卡方分析<ol><li>这该有个公式</li></ol></li></ol></li><li>数据规约<ol><li>维度压缩<ol><li>PCA、小波分析 </li><li>特征筛选<ol><li>相关性分析（卡方、信息增益）</li></ol></li></ol></li><li>数据量规约<ol><li>采样</li><li>直方图</li></ol></li></ol></li><li>数据归一化<ol><li>最小最大归一化</li><li>Z-Score</li></ol></li><li>数据离散化<ol><li>直方图 xmin—xmax</li></ol></li></ol></li></ol><h1 id="CH3-关联规则挖掘"><a href="#CH3-关联规则挖掘" class="headerlink" title="CH3 关联规则挖掘"></a>CH3 关联规则挖掘</h1><ol><li>基本定义</li><li>（重点）Aporior算法<ol><li>性质（两大性质）</li><li>流程（计算）</li></ol></li><li>Aporiori的性能影响（支持度、置信度）</li><li>Aporiori改进方法<ol><li>4个（看ppt）</li></ol></li><li>FP- Growth<ol><li>范式比较（Aporiori）-》产生测试</li><li>生成FP树（重点、 ）</li><li>流程</li></ol></li></ol><h1 id="CH4-分类问题"><a href="#CH4-分类问题" class="headerlink" title="CH4 分类问题"></a>CH4 分类问题</h1><ol><li>机器学习的分类<ol><li>有监督&#x2F;无监督&#x2F;半监督</li></ol></li><li>有监督vs无监督</li><li>有监督学习<ol><li>生成模型</li><li>判别模型</li></ol></li><li>经典算法<ol><li>决策树<ol><li>决策树的构造流程</li><li>选择属性划分的准则（使得划分后的数据类别越准越好）</li><li>常见的属性选择指标<ol><li>信息增益</li><li>信息增益率</li><li>基尼指数</li></ol></li><li>过拟合问题<ol><li>原因：训练集和测试集分布不一致</li><li>如何避免过拟合问题<ol><li>增加样本量</li><li>去除噪声</li><li>降低模型复杂度</li><li>加正则</li><li>Train- Validation-Test</li></ol></li><li>如何在决策树中避免过拟合<ol><li>降低层数</li><li>控制叶子结点个数</li><li>先剪枝&#x2F;后剪枝</li></ol></li><li>决策树优点<ol><li>可解释性强IF&#x2F;Then</li></ol></li></ol></li></ol></li><li>KNN<ol><li>注释</li><li>懒惰学习（Lazy Learning）无需训练</li><li>算法优缺点<ol><li>优点：适合流式增量数据</li><li>适合大量类别数据</li><li>准确率一般较高</li><li>缺点：K值敏感</li><li>类别不平衡问题</li><li>测试耗时</li></ol></li></ol></li><li>Naive-Bayers<ol><li>思想：求后验分布</li><li>优点：概率输出</li></ol></li><li>SVM<ol><li>基本思想：间隔最大化</li><li>SVM为什么支持小样本（决策边界只由几个支持向量决定）</li><li>SVM为什么泛化能力强（因为结构风险最小化【置信风险】）</li><li>SVM如何实现线性不可分问题（核技巧，通过点积运算实现了数据从低维到高维的映射；核技巧不一定解决线性不可分问题）</li></ol></li><li>ANN<ol><li>信息正向传播，梯度反向传播</li><li>优点：拟合几乎所有函数</li><li>缺点：慢、过拟合</li></ol></li></ol></li><li>集成学习<ol><li>准则：<ol><li>基学习器足够好</li><li>有多样性</li></ol></li><li>Bagging（Random Forest）<ol><li>Boosting（Ada Boost）</li><li>Stacking</li></ol></li></ol></li><li>分类评估<ol><li>常见指标：pre、rec、f1、acc</li><li>类别不平衡：sensitivity、specificity</li></ol></li></ol><h1 id="CH5-聚类分析与离群点检测"><a href="#CH5-聚类分析与离群点检测" class="headerlink" title="CH5 聚类分析与离群点检测"></a>CH5 聚类分析与离群点检测</h1><ol><li>什么是聚类分析</li><li>聚类的作用（检测离群点、噪声）</li><li>聚类的分类<ol><li>（重点）基于划分的方法（k-means）【kmeans流程计算】 </li><li>基于层次的方法（AGENS、DIANA）</li><li>基于密度的方法（DBSCAN）</li><li>基于网格的方法（STING）</li></ol></li><li>k-means流程（计算）</li><li>k-means优缺点<ol><li>优点：快</li><li>缺点：<ol><li>对k值敏感</li><li>对初始值敏感</li><li>对噪声敏感</li><li>不能发现非球形（任意形状）的簇</li></ol></li></ol></li><li>DBSCAN优缺点：<ol><li>优点：<ol><li>可以发现任意形状的簇</li><li>无需设置k</li><li>可以任意检测噪声</li></ol></li></ol></li><li>什么是离群点</li><li>离群点分类<ol><li>全局&#x2F;局部&#x2F;集成</li></ol></li><li>离群点检测方法<ol><li>基于统计&#x2F;距离&#x2F;密度（LOF）&#x2F;序列</li></ol></li></ol><h1 id="CH6-大数据分析"><a href="#CH6-大数据分析" class="headerlink" title="CH6 大数据分析"></a>CH6 大数据分析</h1><ol><li>哈希技术<ol><li>作用</li><li>k- shingling </li><li>minHash（定义）【如何计算签名矩阵】（近似计算； ）</li><li>LSH（局部敏感哈希）思想：找哈希函数把相似的对象映射到同一个桶中</li></ol></li><li>数据流挑战<ol><li>挑战（四大） </li><li>什么是概念漂移 </li><li>概念漂移检测方法 <ol><li>基于分布</li><li>基于错误率【都有缺点】</li></ol></li><li>分类（VFDT） </li><li>数据流聚类<ol><li>线上数据抽象（簇特征）</li><li>线下聚类CF（N，LS，SS）可加减性</li></ol></li></ol></li><li>Hadoop&amp;Spark<ol><li>什么是Hadoop</li><li>Hadoop设计准则</li><li>Hadoop组件<ol><li>HDFS（hadoop distribution file system） 存储<ol><li>Meta data 《- Meta node》 + data node（实际数据）心跳机制维持</li></ol></li><li>mapreduce</li></ol></li><li>spark是什么<ol><li>RDD（弹性分布式数据集）</li><li>RDD操作（Transform &#x2F;Action）</li></ol></li><li>MapReduce与Spark区别<ol><li>mapreduce是one pass</li><li>spark是多轮、共享机制、RDD内存、API</li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Course </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Big Data </tag>
            
            <tag> Data Mining </tag>
            
            <tag> 大二下 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件技术基础</title>
      <link href="/article/4eb64ed2.html"/>
      <url>/article/4eb64ed2.html</url>
      
        <content type="html"><![CDATA[<ul><li>Chapter1 编写单机API<ul><li>排序</li><li>归类</li><li>最短路径</li></ul></li><li>Chapter2 多进程API</li><li>Chapter4 SQL &#x3D;》API</li><li>Chapter5 数据 &#x3D;》数据库</li></ul><h2 id="1-1-Chapter1-绪论"><a href="#1-1-Chapter1-绪论" class="headerlink" title="1.1. Chapter1 绪论"></a>1.1. Chapter1 绪论</h2><h3 id="1-1-1-软件开发流程"><a href="#1-1-1-软件开发流程" class="headerlink" title="1.1.1. 软件开发流程"></a>1.1.1. 软件开发流程</h3><ul><li>问题分析与抽象</li><li>系统结构设计</li><li>数据库设计</li><li>算法分析与设计</li><li>数据结构分析与设计</li><li>编译实现</li><li>性能分析与改进</li><li>编程与测试</li></ul><h3 id="1-1-2-软件系统核心逻辑"><a href="#1-1-2-软件系统核心逻辑" class="headerlink" title="1.1.2. 软件系统核心逻辑"></a>1.1.2. 软件系统核心逻辑</h3><ul><li>数据结构与算法设计类型</li></ul><h3 id="1-1-3-软件系统运行平台"><a href="#1-1-3-软件系统运行平台" class="headerlink" title="1.1.3. 软件系统运行平台"></a>1.1.3. 软件系统运行平台</h3><ul><li>计算机操作系统–”硬件上的第一层软件”(实际不恰当,因为还有BIOS)</li><li>管理三大资源:<ul><li>管理CPU</li><li>管理存储<ul><li>进程管理</li></ul></li><li>管理I&#x2F;O</li><li>提供用户接口<ul><li>命令行</li><li>GUI</li></ul></li><li>提供开发接口</li></ul></li></ul><p>发展历史:</p><ul><li>纸带阶段</li><li>批处理阶段</li><li>管理程序阶段<ul><li>通道:用于控制I&#x2F;O设备与内存间的数据传输</li><li>中断</li><li>控制程序发展为executive system,常驻内存</li></ul></li><li>多批批处理</li><li>分时系统(Time-Sharing System)</li><li>工业化军事金融领域:实时系统(Real-Time System)</li></ul><p>操作系统功能:</p><ul><li>处理机资源: 以进程或线程为单位完成处理机资源的分配调度<ul><li>进程控制:创建,撤销,挂起,改变运行优先级等–主动改变进程状态</li><li>进程同步:协调并发进程之间的推进步骤–交换信息能力弱</li><li>进程通信:进程间的数据传输</li><li>进程调度:作业和进程的运行交换</li></ul></li><li>存储器管理: 提高内存利用率,提供足够的存储空间,方便进程并发运行<ul><li>存储分配与回收</li><li>存储保护:保证进程互不干扰,相互保密</li><li>地址映射:进程逻辑地址到内存物理地址的映射</li><li>内存扩充(覆盖,交换和虚拟存储):提高内存利用率,扩大进程的内存空间</li></ul></li><li>设备管理: 方便设备使用,提高CPU与I&#x2F;O设备利用率<ul><li>设备操作:利用设备驱动(位于Kernel)完成对设备的操作</li><li>设备独立性(device independence):提供统一的I&#x2F;O接口,应用程序独立于物理设备</li><li>设备分配与回收:多用户间共享I&#x2F;O设备资源<ul><li>虚拟设备(virtual device):设备有多个进程共享,比方说虚拟打印机</li></ul></li><li>缓冲区管理:匹配CPU和外设的速度</li></ul></li><li>文件管理: 解决软件资源的存储,共享,保密和保护<ul><li>文件存储空间管理:解决如何存放信息,提高空间利用率和读写性能</li><li>目录管理:解决信息检索问题</li><li>文件的读写管理和存储控制:解决信息安全问题,文件权限,系统token</li><li>软件管理:软件版本,相互依赖关系,安装和拆除</li></ul></li><li>作业管理: 提供用户访问操作系统的接口<ul><li>系统命令:供用户用于<em>组织和控制自己的作业运行</em>.命令行或GUI联机,命令脚本-“脱机”</li><li>编程接口:供用户程序和系统程序<em>调用操作系统功能</em>.系统调用和高级语言库函数</li></ul></li></ul><h3 id="1-1-4-软件系统数据管理"><a href="#1-1-4-软件系统数据管理" class="headerlink" title="1.1.4. 软件系统数据管理"></a>1.1.4. 软件系统数据管理</h3><ul><li>数据库体系<br>DBMS系统对数据库操作</li></ul><h3 id="1-1-5-软件系统程序编译"><a href="#1-1-5-软件系统程序编译" class="headerlink" title="1.1.5. 软件系统程序编译"></a>1.1.5. 软件系统程序编译</h3><ul><li>编译连接</li></ul><h2 id="1-2-Chapter2-软件系统逻辑"><a href="#1-2-Chapter2-软件系统逻辑" class="headerlink" title="1.2. Chapter2 软件系统逻辑"></a>1.2. Chapter2 软件系统逻辑</h2><h3 id="1-2-1-简单物流质询系统最优路线计算案例分析"><a href="#1-2-1-简单物流质询系统最优路线计算案例分析" class="headerlink" title="1.2.1. 简单物流质询系统最优路线计算案例分析"></a>1.2.1. 简单物流质询系统最优路线计算案例分析</h3><p>需要考虑很多因素：</p><ul><li>物品的优先级排序</li><li>路径的选择问题</li><li>采用海陆空哪种运输最便宜</li></ul><h3 id="1-2-2-线性数据结构"><a href="#1-2-2-线性数据结构" class="headerlink" title="1.2.2. 线性数据结构"></a>1.2.2. 线性数据结构</h3><p>23.3.7 上午一二节</p><ul><li>线性表的存储结构<ul><li>顺序存储和链式存储以及存储特点</li></ul></li><li>线性表的基本操作编程实现<ul><li>查找</li><li>插入</li><li>删除</li></ul></li></ul><h3 id="1-2-3-树数据结构"><a href="#1-2-3-树数据结构" class="headerlink" title="1.2.3. 树数据结构"></a>1.2.3. 树数据结构</h3><ul><li>二叉树和树的递归定义和基本性质</li><li>二叉树,树和森林的顺序存储及链式存储,各种遍历方法</li></ul><h3 id="1-2-4-图数据结构"><a href="#1-2-4-图数据结构" class="headerlink" title="1.2.4. 图数据结构"></a>1.2.4. 图数据结构</h3><ul><li>图的基本概念,基本操作和存储<ul><li>邻接矩阵,邻接表(逆邻接表)</li><li>DFS和BFS</li></ul></li></ul><h3 id="1-2-5-分治递归和贪心算法"><a href="#1-2-5-分治递归和贪心算法" class="headerlink" title="1.2.5. 分治递归和贪心算法"></a>1.2.5. 分治递归和贪心算法</h3><ul><li>分治递归算法的思想</li><li>贪心算法思想</li><li>最短路径问题</li></ul><h3 id="1-2-6-查询排序算法"><a href="#1-2-6-查询排序算法" class="headerlink" title="1.2.6. 查询排序算法"></a>1.2.6. 查询排序算法</h3><p>23.3.14</p><ul><li>基本排序算法<ul><li>内部排序（内存）<ul><li>插入</li><li>选择</li><li>交换</li><li>改进（分治）从$O(n^2)\to O(nlogn)$</li></ul></li><li>外部排序</li></ul></li><li>利用分治递归思想的改进型排序算法</li><li>基本查询算法</li></ul><h2 id="1-3-Chapter3-软件系统运行平台"><a href="#1-3-Chapter3-软件系统运行平台" class="headerlink" title="1.3. Chapter3 软件系统运行平台"></a>1.3. Chapter3 软件系统运行平台</h2><h3 id="1-3-1-多进程多用户文件一致性读写访问案例分析"><a href="#1-3-1-多进程多用户文件一致性读写访问案例分析" class="headerlink" title="1.3.1. 多进程多用户文件一致性读写访问案例分析"></a>1.3.1. 多进程多用户文件一致性读写访问案例分析</h3><h3 id="1-3-2-软件并发与进程-进程"><a href="#1-3-2-软件并发与进程-进程" class="headerlink" title="1.3.2. 软件并发与进程-进程"></a>1.3.2. 软件并发与进程-进程</h3><ul><li>程序并发执行</li><li>进程的定义与特征</li><li>进程的基本状态</li><li>进程控制模块的基础知识</li><li>线程</li></ul><h3 id="1-3-3-软件并发与进程-同步"><a href="#1-3-3-软件并发与进程-同步" class="headerlink" title="1.3.3. 软件并发与进程-同步"></a>1.3.3. 软件并发与进程-同步</h3><ul><li>进程互斥与同步问题及其解决办法</li><li>信号量与管程机制</li><li>进程直接通信和间接通信方式</li><li>生产者&#x2F;消费者问题</li></ul><h3 id="1-3-4-程序的装入和链接"><a href="#1-3-4-程序的装入和链接" class="headerlink" title="1.3.4. 程序的装入和链接"></a>1.3.4. 程序的装入和链接</h3><ul><li>现代计算机系统的程序装入和链接机制</li><li>程序空间分类</li><li>链接技术</li></ul><h2 id="1-4-Chapter4-软件系统程序编译"><a href="#1-4-Chapter4-软件系统程序编译" class="headerlink" title="1.4. Chapter4 软件系统程序编译"></a>1.4. Chapter4 软件系统程序编译</h2><h3 id="1-4-1-编译概述"><a href="#1-4-1-编译概述" class="headerlink" title="1.4.1. 编译概述"></a>1.4.1. 编译概述</h3><h3 id="1-4-2-语言及文法"><a href="#1-4-2-语言及文法" class="headerlink" title="1.4.2. 语言及文法"></a>1.4.2. 语言及文法</h3><h3 id="1-4-3-词法分析"><a href="#1-4-3-词法分析" class="headerlink" title="1.4.3. 词法分析"></a>1.4.3. 词法分析</h3><h4 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h4><p>词：二元组（type，value）<br>符号表（名称｜value）<br>（*）DFS，NFS</p><h3 id="1-4-4-语法分析"><a href="#1-4-4-语法分析" class="headerlink" title="1.4.4. 语法分析"></a>1.4.4. 语法分析</h3><ul><li>上下文无关文法</li><li>下推自动机<br>文法：</li><li>上-下<ul><li>使用左递归<ul><li>不确定-词法分析过程中不确定分析过程</li><li>确定-清除回溯-无左递归<ul><li>1&#x2F;2</li><li>右递归<br>（*）First集&#x2F;Follow集</li></ul></li></ul></li></ul></li></ul><h3 id="1-4-5-语义分析和中间代码生成"><a href="#1-4-5-语义分析和中间代码生成" class="headerlink" title="1.4.5. 语义分析和中间代码生成"></a>1.4.5. 语义分析和中间代码生成</h3><ul><li>词法分析-&gt;语法分析-&gt;语义分析</li></ul><h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><ul><li>自上而下（LL）<ul><li>递归下降</li><li>词汇表<ul><li>构建</li><li>递归栈<ul><li>AST树<ul><li>自下而上构建AST</li><li>AST树离散</li></ul></li></ul></li></ul></li></ul></li><li>自下而上（LR）<ul><li>规约<ul><li>递归栈</li></ul></li></ul></li></ul><h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><ul><li>语法翻译制导<ul><li>依赖图</li><li>语法树</li></ul></li></ul><h4 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h4><ul><li>依赖图</li><li>遍历<ul><li>自上而下<ul><li>翻译模式<ul><li>推导</li></ul></li></ul></li><li>自下而上<ul><li>加一个语义化<ul><li>规约<br>最后得到</li></ul></li></ul></li></ul></li><li>执行结果</li><li>中间代码（AST、三&#x2F;四地址）<pre class="line-numbers language-none"><code class="language-none">语法分析  |  ├── 语法翻译制导  |      |  |      ├── 依赖图  |      |  |      └── 语法树  |  └── 语义分析          |          ├── 依赖图          |          └── 遍历                |                ├── 自上而下                |       |                |       ├── 翻译模式                |       |      |                |       |      └── 推导                |       |                |       └── 执行结果                |                └── 自下而上                        |                        ├── 加一个语义化                        |        |                        |        └── 规约                        |                        └── 中间代码（AST、三&#x2F;四地址）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>汇总：<br>词法-语法-「「解释API；生成中间代码」-「什么样子-「三地址，四元式；三元式」；间接三元式-「间接对象（代码执行顺序）；三元式表（内容）」；-语义-「自上而下；自下而上」-「OP；Type」</p><pre class="line-numbers language-ASCII" data-language="ASCII"><code class="language-ASCII">词法  |  └── 语法          |          ├── 解释API；生成中间代码          |         |          |         ├── 什么样子          |         |      |          |         |      ├── 三地址，四元式          |         |      |          |         |      └── 三元式          |         |          |         └── 间接三元式          |                 |          |                 ├── 间接对象（代码执行顺序）          |                 |          |                 └── 三元式表（内容）          |          └── 语义 |                           └── Type              |                          |        └── OP                  |                  ├── 自上而下                         |                  └── 自下而上                          <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-5-Chapter5-软件系统数据管理"><a href="#1-5-Chapter5-软件系统数据管理" class="headerlink" title="1.5. Chapter5 软件系统数据管理"></a>1.5. Chapter5 软件系统数据管理</h2><h3 id="1-5-1-数据库的基本概念-数据库技术发展概述"><a href="#1-5-1-数据库的基本概念-数据库技术发展概述" class="headerlink" title="1.5.1. 数据库的基本概念,数据库技术发展概述"></a>1.5.1. 数据库的基本概念,数据库技术发展概述</h3><h3 id="1-5-2-关系数据库-及标准语言SQL-数据库安全性"><a href="#1-5-2-关系数据库-及标准语言SQL-数据库安全性" class="headerlink" title="1.5.2. 关系数据库,及标准语言SQL,数据库安全性"></a>1.5.2. 关系数据库,及标准语言SQL,数据库安全性</h3><h3 id="1-5-3-数据库设计和数据库编程"><a href="#1-5-3-数据库设计和数据库编程" class="headerlink" title="1.5.3. 数据库设计和数据库编程"></a>1.5.3. 数据库设计和数据库编程</h3><h3 id="1-5-4-数据库新技术-大数据与hadoop"><a href="#1-5-4-数据库新技术-大数据与hadoop" class="headerlink" title="1.5.4. 数据库新技术:大数据与hadoop"></a>1.5.4. 数据库新技术:大数据与hadoop</h3>]]></content>
      
      
      <categories>
          
          <category> Course </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二下 </tag>
            
            <tag> 软件技术基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>量化交易与商业银行</title>
      <link href="/article/488818ef.html"/>
      <url>/article/488818ef.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-Chapter1-课程概述"><a href="#1-1-Chapter1-课程概述" class="headerlink" title="1.1. Chapter1 课程概述"></a>1.1. Chapter1 课程概述</h2><h3 id="1-1-1-课程简介"><a href="#1-1-1-课程简介" class="headerlink" title="1.1.1. 课程简介"></a>1.1.1. 课程简介</h3><ul><li>小组作业与汇报（4次）：60%</li><li>期货交易仿真（1次）：20%</li><li>期末设计报告（1次）：20%<ul><li>加分：讲义的修改</li></ul></li></ul><h4 id="PPT注意事项"><a href="#PPT注意事项" class="headerlink" title="PPT注意事项"></a>PPT注意事项</h4><ul><li>Dark背景，白色字体和蓝色字体和黄色字体足矣</li><li>右上角的课程logo</li><li>less than 5 colors</li><li>注明分工</li><li>background</li><li>图表标注说明</li><li>页码添加</li></ul><h3 id="1-1-2-量化交易简介"><a href="#1-1-2-量化交易简介" class="headerlink" title="1.1.2. 量化交易简介"></a>1.1.2. 量化交易简介</h3><blockquote><p>量化交易是指以数据为基础，以数量化手段为核心，利用计算机技术进行程序化交易的投资方式。这里的数量化手段，包括对整个交易流程和交易目标的数量刻画、数学模型的构建、对 量化目标的最优化、对策略结果的数量化评价等方式方法。</p></blockquote><p>量化交易的缺点和优点</p><h4 id="金融学逻辑"><a href="#金融学逻辑" class="headerlink" title="金融学逻辑"></a>金融学逻辑</h4><ul><li>有效市场假说<ul><li>人们会因为情绪和对信息的理解，导致时间上股价的内在价值的偏移，由于定价误差的存在，量化交易可以捕捉到投资的机会。</li></ul></li><li>行为经济学<ul><li>人们会对自己的行为过度自信，导致股价的变化并不是即时性的。</li></ul></li></ul><h3 id="1-1-3-商业银行简介"><a href="#1-1-3-商业银行简介" class="headerlink" title="1.1.3. 商业银行简介"></a>1.1.3. 商业银行简介</h3><h2 id="1-2-Chapter2-股票量化交易"><a href="#1-2-Chapter2-股票量化交易" class="headerlink" title="1.2. Chapter2 股票量化交易"></a>1.2. Chapter2 股票量化交易</h2><h3 id="1-2-1-选股逻辑与交易策略"><a href="#1-2-1-选股逻辑与交易策略" class="headerlink" title="1.2.1. 选股逻辑与交易策略"></a>1.2.1. 选股逻辑与交易策略</h3><ul><li>多因子模型<ul><li>套利定价理论为基础，买入满足因子条件的股票卖出不满足的（如市盈率因子）</li><li>多因子组合可以使用加权打分法和收益回归法</li></ul></li><li>套利类策略<ul><li>Call Option</li><li>Put Option</li></ul></li><li>统计套利(Statistical Arbitrage)<ul><li>Pairs Trading</li></ul></li><li>衍生品策略</li><li>事件驱动策略</li></ul><h3 id="1-2-2-因子分析"><a href="#1-2-2-因子分析" class="headerlink" title="1.2.2. 因子分析"></a>1.2.2. 因子分析</h3><p>There are a few different ways to determine factors in quantitative trading:</p><ul><li><strong>Backtesting.</strong> Backtesting involves running a historical simulation of a trading strategy to see how it would have performed in the past. This can help you to identify factors that were historically associated with success.</li><li><strong>Statistical analysis.</strong> Statistical analysis can be used to identify factors that are correlated with stock prices. This can help you to develop a model that can predict future stock prices.</li><li><strong>Expert opinion.</strong> You can also consult with experts in the field of quantitative trading to get their recommendations on factors.</li></ul><p>Once you have identified some potential factors, you need to test them to see if they are actually effective in predicting stock prices. This can be done by running a backtest or by using statistical analysis.</p><p>It is important to note that there is no one-size-fits-all answer to this question. The best way to determine factors will vary depending on your specific investment goals and objectives.</p><p>There are a few things you can do to determine your stock pool when using a multi-factor strategy:</p><ol><li><strong>Identify your factors.</strong> What factors do you want to use to select stocks? Some common factors include price momentum, value, and technical indicators.</li><li><strong>Rank your factors.</strong> Once you have identified your factors, you need to rank them in order of importance. This will help you to narrow down your stock pool.</li><li><strong>Screen for stocks.</strong> Once you have ranked your factors, you can screen for stocks that meet your criteria. This will help you to identify a smaller pool of stocks to further analyze.</li><li><strong>Analyze your stocks.</strong> Once you have screened for stocks, you need to analyze them further. This will help you to identify the best stocks to include in your portfolio.</li></ol><p>It is important to note that there is no one-size-fits-all answer to this question. The best way to determine your stock pool will vary depending on your specific investment goals and objectives.<br>#<br>Here are some additional tips for determining your stock pool:</p><ul><li><strong>Consider your risk tolerance.</strong> The stocks you choose should be consistent with your risk tolerance. If you are a conservative investor, you will want to choose stocks with a lower risk profile.</li><li><strong>Diversify your portfolio.</strong> It is important to diversify your portfolio to reduce risk. This means investing in a variety of different stocks from different sectors.</li><li><strong>Monitor your portfolio.</strong> Once you have chosen your stocks, you need to monitor your portfolio regularly. This will help you to identify any stocks that are no longer meeting your criteria and make changes as needed.</li></ul><h1 id><a href="#" class="headerlink" title></a></h1><blockquote><p>So isn’t this a contradiction? In quantitative trading, my stock selection needs to be determined by factors, but the determination of factors needs to be determined by the backtest data of the stock pool</p></blockquote><p>Not necessarily. You can use backtesting to identify factors that were historically associated with success, but you can also use other methods, such as expert opinion or statistical analysis. Ultimately, the decision of which factors to use is up to you.</p><p>Backtesting can be a helpful tool, but it is important to remember that it is not a perfect tool. There are a number of limitations to backtesting, such as the fact that it uses historical data and does not take into account current market conditions. However, backtesting can be a valuable tool for identifying potential problems with a trading strategy and for identifying factors that were historically associated with success.</p><p>If you are using backtesting to identify factors, it is important to use a variety of different data sets and to backtest your strategy over a long period of time. This will help you to get a more accurate picture of how your strategy would have performed in the past.</p><p>It is also important to remember that backtesting is just one tool that you can use to make investment decisions. You also need to consider your own risk tolerance, your investment goals, and your investment horizon. Ultimately, the decision of whether or not to use a particular trading strategy is up to you.</p><h3 id="1-2-3-交易策略的编程实现"><a href="#1-2-3-交易策略的编程实现" class="headerlink" title="1.2.3. 交易策略的编程实现"></a>1.2.3. 交易策略的编程实现</h3><p>聚宽量化交易平台</p><h2 id="1-3-Chapter3-期货量化交易"><a href="#1-3-Chapter3-期货量化交易" class="headerlink" title="1.3. Chapter3 期货量化交易"></a>1.3. Chapter3 期货量化交易</h2><h3 id="1-3-1-期货和期权的简介"><a href="#1-3-1-期货和期权的简介" class="headerlink" title="1.3.1. 期货和期权的简介"></a>1.3.1. 期货和期权的简介</h3><h4 id="远期协议Forward-Contact"><a href="#远期协议Forward-Contact" class="headerlink" title="远期协议Forward Contact"></a>远期协议Forward Contact</h4><h5 id="期货-Future"><a href="#期货-Future" class="headerlink" title="期货 Future"></a>期货 Future</h5><h6 id="两大功能："><a href="#两大功能：" class="headerlink" title="两大功能："></a>两大功能：</h6><ul><li><p>价格发现<br>投资者可以准确掌握未来市场的供求信息，提高资本市场的效率</p></li><li><p>风险规避<br>投资者可以通过套期保值来规避市场价格风险，促进金融服务实体经济</p></li><li><p>交易所中介（降低信用风险）</p></li><li><p>标准化的合同更具流动性</p></li><li><p>风险对冲（hedging）</p></li><li><p>杠杆交易原理</p></li></ul><h5 id="保证金（margin）-amp-盯市（mark-to-market）"><a href="#保证金（margin）-amp-盯市（mark-to-market）" class="headerlink" title="保证金（margin）&amp;盯市（mark to market）"></a>保证金（margin）&amp;盯市（mark to market）</h5><p>如果保证金不足，将会发生强行平仓</p><h5 id="期货功能"><a href="#期货功能" class="headerlink" title="期货功能"></a>期货功能</h5><ul><li>风险规避</li><li>价格发现</li></ul><h5 id="商品期货的定价公式"><a href="#商品期货的定价公式" class="headerlink" title="商品期货的定价公式"></a>商品期货的定价公式</h5><p>$$F &#x3D; S_0(1+r_f+h)^T$$<br>where $S_0$是现货价格<br>$r_f$是无风险利率Risk Free<br>$h$是存储成本</p><p>两种套利方法</p><h3 id="1-3-2-期货量化交易"><a href="#1-3-2-期货量化交易" class="headerlink" title="1.3.2. 期货量化交易"></a>1.3.2. 期货量化交易</h3><h3 id="1-3-3-期货的基本面分析"><a href="#1-3-3-期货的基本面分析" class="headerlink" title="1.3.3. 期货的基本面分析"></a>1.3.3. 期货的基本面分析</h3><h2 id="1-4-Chapter4-商业银行经营与业务逻辑"><a href="#1-4-Chapter4-商业银行经营与业务逻辑" class="headerlink" title="1.4. Chapter4 商业银行经营与业务逻辑"></a>1.4. Chapter4 商业银行经营与业务逻辑</h2><h3 id="1-4-1-商业银行业务概述"><a href="#1-4-1-商业银行业务概述" class="headerlink" title="1.4.1. 商业银行业务概述"></a>1.4.1. 商业银行业务概述</h3><h4 id="职能与作用"><a href="#职能与作用" class="headerlink" title="职能与作用"></a>职能与作用</h4><ul><li>融资</li><li>信用中心</li></ul><h4 id="基本业务"><a href="#基本业务" class="headerlink" title="基本业务"></a>基本业务</h4><ul><li>直接贷款 表内业务</li><li>贷款承诺 表外业务</li><li>委托贷款 中间业务</li></ul><h3 id="1-4-2-商业银行的经营绩效评估"><a href="#1-4-2-商业银行的经营绩效评估" class="headerlink" title="1.4.2. 商业银行的经营绩效评估"></a>1.4.2. 商业银行的经营绩效评估</h3><h4 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h4><ul><li>流动性前提</li><li>安全性保障</li><li>盈利性目标</li></ul><h3 id="1-4-3-上市商业银行的财务报表分析"><a href="#1-4-3-上市商业银行的财务报表分析" class="headerlink" title="1.4.3. 上市商业银行的财务报表分析"></a>1.4.3. 上市商业银行的财务报表分析</h3><h2 id="1-5-Chapter5-个人信用风险评估与消费信贷产品设计"><a href="#1-5-Chapter5-个人信用风险评估与消费信贷产品设计" class="headerlink" title="1.5. Chapter5 个人信用风险评估与消费信贷产品设计"></a>1.5. Chapter5 个人信用风险评估与消费信贷产品设计</h2><h3 id="1-5-1-个人信用风险评估原理与方法"><a href="#1-5-1-个人信用风险评估原理与方法" class="headerlink" title="1.5.1. 个人信用风险评估原理与方法"></a>1.5.1. 个人信用风险评估原理与方法</h3><h3 id="1-5-2-个人信用分类训练模型"><a href="#1-5-2-个人信用分类训练模型" class="headerlink" title="1.5.2. 个人信用分类训练模型"></a>1.5.2. 个人信用分类训练模型</h3><h1 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h1><h2 id="数据预处理："><a href="#数据预处理：" class="headerlink" title="数据预处理："></a>数据预处理：</h2><p>加载训练样本和测试样本数据<br>检查并处理缺失值，可以使用填充、删除或插值等方法<br>对类别型特征进行编码，例如独热编码或标签编码<br>对数值型特征进行标准化或归一化处理</p><h2 id="特征选择："><a href="#特征选择：" class="headerlink" title="特征选择："></a>特征选择：</h2><p>使用相关性分析、递归特征消除（RFE）或基于模型的方法（例如LASSO回归）进行特征选择，以减少特征维度并提高模型性能</p><h2 id="处理不均衡样本："><a href="#处理不均衡样本：" class="headerlink" title="处理不均衡样本："></a>处理不均衡样本：</h2><p>采用过采样（例如SMOTE算法）或欠采样（例如随机欠采样）方法，使各类别样本数量接近平衡</p><h2 id="选择至少两种机器学习方法构建模型，例如："><a href="#选择至少两种机器学习方法构建模型，例如：" class="headerlink" title="选择至少两种机器学习方法构建模型，例如："></a>选择至少两种机器学习方法构建模型，例如：</h2><p>神经网络（例如多层感知机）<br>随机森林决策树<br>XgboostLightGBM<br>CatBoost</p><h2 id="描述所选机器学习算法的原理："><a href="#描述所选机器学习算法的原理：" class="headerlink" title="描述所选机器学习算法的原理："></a>描述所选机器学习算法的原理：</h2><p>对于每种选定的算法，描述它们的工作原理、优缺点和在此任务中的适用性</p><h2 id="训练并评估模型："><a href="#训练并评估模型：" class="headerlink" title="训练并评估模型："></a>训练并评估模型：</h2><p>将预处理后的训练数据集划分为训练集和验证集<br>使用各种选定的算法训练模型，并在验证集上评估模型性能，记录准确性、精确度、召回率、F1分数等评价指标</p><h2 id="与支持向量机（SVM）和Logistic回归进行比较："><a href="#与支持向量机（SVM）和Logistic回归进行比较：" class="headerlink" title="与支持向量机（SVM）和Logistic回归进行比较："></a>与支持向量机（SVM）和Logistic回归进行比较：</h2><p>训练支持向量机和Logistic回归模型，并在验证集上评估性能<br>将所选方法的性能与SVM和Logistic回归的性能进行比较，找出最佳模型</p><h2 id="使用最佳模型在预处理后的测试数据集上进行预测"><a href="#使用最佳模型在预处理后的测试数据集上进行预测" class="headerlink" title="使用最佳模型在预处理后的测试数据集上进行预测"></a>使用最佳模型在预处理后的测试数据集上进行预测</h2><p>分析预测结果，提出可能的优化方法（如参数调优、特征选择、不同模型结合等）</p><h2 id="撰写报告："><a href="#撰写报告：" class="headerlink" title="撰写报告："></a>撰写报告：</h2><p>总结整个过程，包括数据预处理、特征选择、模型训练、评估和预测<br>描述所选方法的原理以及与SVM和Logistic回归的比较<br>提出改进和优化的建议</p><h1 id="以下为具体操作"><a href="#以下为具体操作" class="headerlink" title="以下为具体操作"></a>以下为具体操作</h1><h2 id="数据预处理：-1"><a href="#数据预处理：-1" class="headerlink" title="数据预处理："></a>数据预处理：</h2><p>加载训练样本和测试样本数据<br>检查并处理缺失值，可以使用填充、删除或插值等方法<br>对类别型特征进行编码，例如独热编码或标签编码<br>对数值型特征进行标准化或归一化处理</p><p>首先导入必要的库，并加载训练样本和测试样本数据。假设训练集位于”train.csv”，测试集位于”test.csv”。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>preprocessing <span class="token keyword">import</span> StandardScaler<span class="token punctuation">,</span> MinMaxScaler<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>impute <span class="token keyword">import</span> SimpleImputer<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>preprocessing <span class="token keyword">import</span> OneHotEncoder<span class="token punctuation">,</span> LabelEncoder<span class="token comment"># 加载数据</span>train_data <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">"train.csv"</span><span class="token punctuation">)</span>test_data <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">"test.csv"</span><span class="token punctuation">)</span><span class="token comment"># 查看数据</span><span class="token keyword">print</span><span class="token punctuation">(</span>train_data<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>test_data<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来检查并处理缺失值。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">handle_missing_values</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 使用均值填充数值型特征的缺失值</span>    num_imputer <span class="token operator">=</span> SimpleImputer<span class="token punctuation">(</span>strategy<span class="token operator">=</span><span class="token string">"mean"</span><span class="token punctuation">)</span>    data<span class="token punctuation">[</span>num_cols<span class="token punctuation">]</span> <span class="token operator">=</span> num_imputer<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>data<span class="token punctuation">[</span>num_cols<span class="token punctuation">]</span><span class="token punctuation">.</span>values<span class="token punctuation">)</span>    <span class="token comment"># 使用众数填充类别型特征的缺失值</span>    cat_imputer <span class="token operator">=</span> SimpleImputer<span class="token punctuation">(</span>strategy<span class="token operator">=</span><span class="token string">"most_frequent"</span><span class="token punctuation">)</span>    data<span class="token punctuation">[</span>cat_cols<span class="token punctuation">]</span> <span class="token operator">=</span> cat_imputer<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>data<span class="token punctuation">[</span>cat_cols<span class="token punctuation">]</span><span class="token punctuation">.</span>values<span class="token punctuation">)</span>    <span class="token keyword">return</span> datatrain_data <span class="token operator">=</span> handle_missing_values<span class="token punctuation">(</span>train_data<span class="token punctuation">)</span>test_data <span class="token operator">=</span> handle_missing_values<span class="token punctuation">(</span>test_data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对类别型特征进行编码。这里以独热编码为例。首先确定类别型特征。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">one_hot_encoding</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> cat_cols<span class="token punctuation">)</span><span class="token punctuation">:</span>    ohe <span class="token operator">=</span> OneHotEncoder<span class="token punctuation">(</span>handle_unknown<span class="token operator">=</span><span class="token string">"ignore"</span><span class="token punctuation">)</span>    ohe_array <span class="token operator">=</span> ohe<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>data<span class="token punctuation">[</span>cat_cols<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>toarray<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> ohe_arraycat_cols <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'cat_col_1'</span><span class="token punctuation">,</span> <span class="token string">'cat_col_2'</span><span class="token punctuation">,</span> <span class="token string">'cat_col_3'</span><span class="token punctuation">]</span>  <span class="token comment"># 根据实际数据集中的类别型特征列名替换</span>train_ohe <span class="token operator">=</span> one_hot_encoding<span class="token punctuation">(</span>train_data<span class="token punctuation">,</span> cat_cols<span class="token punctuation">)</span>test_ohe <span class="token operator">=</span> one_hot_encoding<span class="token punctuation">(</span>test_data<span class="token punctuation">,</span> cat_cols<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着#对数值型特征进行标准化处理。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">standardize_numeric_features</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> num_cols<span class="token punctuation">)</span><span class="token punctuation">:</span>    scaler <span class="token operator">=</span> StandardScaler<span class="token punctuation">(</span><span class="token punctuation">)</span>    data<span class="token punctuation">[</span>num_cols<span class="token punctuation">]</span> <span class="token operator">=</span> scaler<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>data<span class="token punctuation">[</span>num_cols<span class="token punctuation">]</span><span class="token punctuation">.</span>values<span class="token punctuation">)</span>    <span class="token keyword">return</span> datanum_cols <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'num_col_1'</span><span class="token punctuation">,</span> <span class="token string">'num_col_2'</span><span class="token punctuation">,</span> <span class="token string">'num_col_3'</span><span class="token punctuation">]</span>  <span class="token comment"># 根据实际数据集中的数值型特征列名替换</span>train_data <span class="token operator">=</span> standardize_numeric_features<span class="token punctuation">(</span>train_data<span class="token punctuation">,</span> num_cols<span class="token punctuation">)</span>test_data <span class="token operator">=</span> standardize_numeric_features<span class="token punctuation">(</span>test_data<span class="token punctuation">,</span> num_cols<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后将处理后的数值型特征和独热编码后的类别型特征结合。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">train_final <span class="token operator">=</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">(</span>train_data<span class="token punctuation">[</span>num_cols<span class="token punctuation">]</span><span class="token punctuation">.</span>values<span class="token punctuation">,</span> train_ohe<span class="token punctuation">)</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>test_final <span class="token operator">=</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">(</span>test_data<span class="token punctuation">[</span>num_cols<span class="token punctuation">]</span><span class="token punctuation">.</span>values<span class="token punctuation">,</span> test_ohe<span class="token punctuation">)</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Processed train data shape: "</span><span class="token punctuation">,</span> train_final<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Processed test data shape: "</span><span class="token punctuation">,</span> test_final<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此完成了数据预处理过程，接下来可以使用处理后的数据在训练集上训练模型，然后在测试集上进行评估。</p><h2 id="特征选择：-1"><a href="#特征选择：-1" class="headerlink" title="特征选择："></a>特征选择：</h2><p>使用相关性分析、递归特征消除（RFE）或基于模型的方法（例如LASSO回归）进行特征选择，以减少特征维度并提高模型性能</p><ol><li>相关性分析：<br> 可以计算特征之间的相关性，选择与目标变量相关性较高的特征。这里 可以使用Pearson相关系数（在数值型特征之间）和Spearman相关系数（在类别型和数值型特征之间）来衡量相关性。</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment"># 假设数据已经经过预处理（缺失值、编码和标准化）</span><span class="token comment"># X_train为训练集特征，y_train为训练集标签</span><span class="token comment"># 计算特征与目标变量之间的相关系数</span>correlations <span class="token operator">=</span> X_train<span class="token punctuation">.</span>corrwith<span class="token punctuation">(</span>y_train<span class="token punctuation">)</span><span class="token comment"># 选取与目标变量相关系数绝对值较高的特征</span>selected_features <span class="token operator">=</span> correlations<span class="token punctuation">[</span><span class="token builtin">abs</span><span class="token punctuation">(</span>correlations<span class="token punctuation">)</span> <span class="token operator">></span> threshold<span class="token punctuation">]</span><span class="token punctuation">.</span>index<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>递归特征消除（RFE）：<br>递归特征消除是一种递归地移除特征并通过模型精度来评估特征重要性的方法。</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>feature_selection <span class="token keyword">import</span> RFE<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> LogisticRegression<span class="token comment"># 初始化逻辑回归模型</span>model <span class="token operator">=</span> LogisticRegression<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 初始化RFE，并选取要保留的特征数量。在这里 选择保留前10个特征</span>rfe <span class="token operator">=</span> RFE<span class="token punctuation">(</span>model<span class="token punctuation">,</span> n_features_to_select<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token comment"># 使用训练数据进行拟合</span>rfe<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span><span class="token comment"># 获取选定的特征</span>selected_features <span class="token operator">=</span> X_train<span class="token punctuation">.</span>columns<span class="token punctuation">[</span>rfe<span class="token punctuation">.</span>support_<span class="token punctuation">]</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>基于模型的特征选择（例如LASSO回归）：<br>使用带有L1正则化的线性模型（如LASSO回归）进行特征选择时，伴随着正则化参数的增加，L1正则化会将某些特征的系数逼近为零，从而实现特征选择。</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> Lasso<span class="token comment"># 初始化LASSO回归模型（可以微调正则化参数alpha）</span>lasso <span class="token operator">=</span> Lasso<span class="token punctuation">(</span>alpha<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token comment"># 用训练数据拟合模型</span>lasso<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span><span class="token comment"># 获取非零系数特征</span>selected_features <span class="token operator">=</span> X_train<span class="token punctuation">.</span>columns<span class="token punctuation">[</span>lasso<span class="token punctuation">.</span>coef_ <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上三种特征选择方法可以根据实际情况进行选择。</p><h2 id="处理不均衡样本：-1"><a href="#处理不均衡样本：-1" class="headerlink" title="处理不均衡样本："></a>处理不均衡样本：</h2><p>采用过采样（例如SMOTE算法）或欠采样（例如随机欠采样）方法，使各类别样本数量接近平衡</p><p>处理不平衡数据集是很重要的，因为在许多实际问题中，类别分布是不均衡的。在这种情况下，过采样和欠采样技术可以提高分类器的性能。</p><ol><li>过采样（如SMOTE算法）：</li></ol><p>SMOTE（合成少数类过采样技术）是处理不平衡数据集的一种有效方法。它通过生成少数类的合成样本来平衡类别。这里是一个简单的实现过程：</p><pre><code>1.1. 导入所需的库和数据拆分：</code></pre><pre class="line-numbers language-none"><code class="language-none">from imblearn.over_sampling import SMOTEfrom sklearn.model_selection import train_test_split<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>1.2. 拆分数据集为训练集和测试集：</code></pre><pre class="line-numbers language-none"><code class="language-none">X_train, X_test, y_train, y_test &#x3D; train_test_split(X, y, test_size&#x3D;0.3, random_state&#x3D;42)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>1.3. 使用SMOTE过采样：</code></pre><pre class="line-numbers language-none"><code class="language-none">smote &#x3D; SMOTE(random_state&#x3D;42)X_train_resampled, y_train_resampled &#x3D; smote.fit_resample(X_train, y_train)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>1.4. 在重采样后的数据上训练模型并验证性能</code></pre><ol start="2"><li>欠采样（例如随机欠采样）：</li></ol><p>欠采样是另一种平衡类别的方法，它通过减少多数类的样本数量。随机欠采样是执行欠采样的一种方法。这里是一个简单的实现过程：</p><pre><code>2.1. 导入所需的库和数据拆分：</code></pre><pre class="line-numbers language-none"><code class="language-none">from imblearn.under_sampling import RandomUnderSamplerfrom sklearn.model_selection import train_test_split<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>2.2. 拆分数据集为训练集和测试集：</code></pre><pre class="line-numbers language-none"><code class="language-none">X_train, X_test, y_train, y_test &#x3D; train_test_split(X, y, test_size&#x3D;0.3, random_state&#x3D;42)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>2.3. 使用随机欠采样：</code></pre><pre class="line-numbers language-none"><code class="language-none">rus &#x3D; RandomUnderSampler(random_state&#x3D;42)X_train_resampled, y_train_resampled &#x3D; rus.fit_resample(X_train, y_train)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>2.4. 在重采样后的数据上训练模型并验证性能</code></pre><p>在这两种方法中，过采样保留了更多的信息，因此它可能导致更好的性能。然而，这也可能导致过度拟合，因此使用交叉验证来评估模型性能。欠采样对于非常不平衡的数据集和计算资源有限的情况很有用，但它可能会丢失一些有价值的信息。</p><h2 id="选择至少两种机器学习方法构建模型，例如：-1"><a href="#选择至少两种机器学习方法构建模型，例如：-1" class="headerlink" title="选择至少两种机器学习方法构建模型，例如："></a>选择至少两种机器学习方法构建模型，例如：</h2><p>神经网络（例如多层感知机）<br>随机森林决策树<br>XgboostLightGBM<br>CatBoost</p><p>使用神经网络（多层感知机）和XGBoost进行建模。</p><h4 id="神经网络（多层感知机）："><a href="#神经网络（多层感知机）：" class="headerlink" title="神经网络（多层感知机）："></a>神经网络（多层感知机）：</h4><ol><li><p>准备数据：在训练神经网络之前，确保 已完成数据预处理和特征选择的前两个任务。另外，对输入数据进行归一化处理，使其值介于0和1之间，以便神经网络更快地收敛。</p></li><li><p>创建神经网络：使用Python的<code>keras</code>库定义一个多层感知机。可以以以下方式创建多层感知机：</p></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> keras<span class="token punctuation">.</span>models <span class="token keyword">import</span> Sequential<span class="token keyword">from</span> keras<span class="token punctuation">.</span>layers <span class="token keyword">import</span> Densemodel <span class="token operator">=</span> Sequential<span class="token punctuation">(</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>add<span class="token punctuation">(</span>Dense<span class="token punctuation">(</span>units<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">,</span> input_dim<span class="token operator">=</span>X_train<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>add<span class="token punctuation">(</span>Dense<span class="token punctuation">(</span>units<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>add<span class="token punctuation">(</span>Dense<span class="token punctuation">(</span>units<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'sigmoid'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>编译模型：选择适当的损失函数、优化器和评估指标：</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">model<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span>loss<span class="token operator">=</span><span class="token string">'binary_crossentropy'</span><span class="token punctuation">,</span> optimizer<span class="token operator">=</span><span class="token string">'adam'</span><span class="token punctuation">,</span> metrics<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'accuracy'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>训练模型：将训练数据集划分为训练和验证集，然后使用<code>fit</code>方法训练模型，并设置合适数字轮次和批量大小：</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">history <span class="token operator">=</span> model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> epochs<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">,</span> validation_data<span class="token operator">=</span><span class="token punctuation">(</span>X_val<span class="token punctuation">,</span> y_val<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="5"><li><p>评估模型性能：查看训练和验证准确率，根据需要调整模型结构和参数。</p></li><li><p>应用模型：使用<code>predict</code>方法预测新数据的标签。</p></li></ol><h4 id="XGBoost："><a href="#XGBoost：" class="headerlink" title="XGBoost："></a>XGBoost：</h4><ol><li><p>准备数据：确保 已完成数据预处理和特征选择的前两个任务。对于XGBoost，不需要对输入数据进行归一化处理。</p></li><li><p>创建模型：使用<code>xgboost</code>库创建一个XGBoost分类器：</p></li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> xgboost <span class="token keyword">as</span> xgbmodel <span class="token operator">=</span> xgb<span class="token punctuation">.</span>XGBClassifier<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="3"><li>训练模型：使用<code>fit</code>方法训练模型，并将训练数据集划分为训练和验证集：</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python">model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> eval_set<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">(</span>X_val<span class="token punctuation">,</span> y_val<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> early_stopping_rounds<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li><p>调整超参数：使用网格搜索或随机搜索等技术调整超参数，以优化模型性能。</p></li><li><p>评估模型性能：根据准确率、精确率、召回率等指标评估模型性能。</p></li><li><p>应用模型：使用<code>predict</code>方法预测新数据的标签。</p></li></ol><p>这就是如何使用多层感知机和XGBoost构建模型的概述。注意，这两种方法都涉及到很多可调整的参数和设置，因此建议对这些方法进行深入了解，以便根据 具体问题获得最佳性能。在实践中， 也可以同时尝试其他机器学习方法，如随机森林决策树、LightGBM和CatBoost，以评估哪种方法在 问题上表现最佳。</p><h2 id="描述所选机器学习算法的原理：-1"><a href="#描述所选机器学习算法的原理：-1" class="headerlink" title="描述所选机器学习算法的原理："></a>描述所选机器学习算法的原理：</h2><p>对于每种选定的算法，描述它们的工作原理、优缺点和在此任务中的适用性</p><ol><li>神经网络（Neural Networks）</li></ol><ul><li>工作原理：神经网络是一种模仿人脑神经元结构的机器学习方法。它由多个节点（神经元）和连接它们的权重组成，分为输入层、隐藏层和输出层。神经网络通过改变权重和激活函数来进行学习。当输入数据进入网络时，权重和激活函数将数据从一层传递到另一层，直到生成输出。学习过程通常使用反向传播算法更新权重，并依靠梯度下降优化算法（如Adam或RMSprop）最小化损失函数。</li><li>优点：<ul><li>可以处理复杂、非线性数据。</li><li>适合处理图像、文本、语音等领域的问题。</li><li>可以通过调整网络结构和参数以适应各种任务。</li></ul></li><li>缺点：<ul><li>训练时间较长，尤其是对于大型网络和大量数据。</li><li>容易过拟合，尤其是在较小的数据集上。</li><li>需要大量的调参和验证以达到最佳性能。</li></ul></li><li>适用性：神经网络适用于 任务，因为它们能够捕捉复杂的关系和模式。在预处理数据并进行特征选择之后，可以尝试构建一个简单的神经网络来解决 问题。随着 了解需要学习的模式的复杂性，可以逐渐增加网络的大小，并尝试不同的激活函数和优化器。</li></ul><ol><li>XGBoost（eXtreme Gradient Boosting）</li></ol><ul><li>工作原理：XGBoost是一种基于梯度提升决策树（Gradient Boosted Decision Trees，GBDT）的机器学习算法。梯度提升是一种集成学习方法，通过将多个基本模型（通常是决策树）组合起来提高预测性能。在每一轮迭代中，都会按顺序添加一个新的基本模型，并对该模型的预测结果与实际值之间的误差进行拟合。XGBoost通过梯度提升来进行优化。更具体地说，它使用领英之间梯度下降的原理来最小化损失函数，并发挥集成模型的最大优势。</li><li>优点：<ul><li>高性能，常常在比赛和实际应用中展现优越的表现。</li><li>可以很好地处理离散数值、分类型和缺失值。</li><li>能够解决回归、分类、排序和自定义损失函数等问题。</li><li>提供了很多调</li></ul></li></ul><h2 id="训练并评估模型：-1"><a href="#训练并评估模型：-1" class="headerlink" title="训练并评估模型："></a>训练并评估模型：</h2><p>将预处理后的训练数据集划分为训练集和验证集<br>使用各种选定的算法训练模型，并在验证集上评估模型性能，记录准确性、精确度、召回率、F1分数等评价指标</p><ol><li>将预处理后的训练数据集划分为训练集和验证集：<br>使用sklearn库的train_test_split方法，将数据集划分为训练集（例如，80%的数据）和验证集（例如，20%的数据）。</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_splitX_train<span class="token punctuation">,</span> X_val<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> y_val <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> test_size<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>使用神经网络训练模型：<br>使用Keras或PyTorch等库构建神经网络，并使用训练集对模型进行训练。</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> tf<span class="token keyword">from</span> tensorflow<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>models <span class="token keyword">import</span> Sequential<span class="token keyword">from</span> tensorflow<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers <span class="token keyword">import</span> Dense<span class="token comment"># 定义神经网络结构</span>model <span class="token operator">=</span> Sequential<span class="token punctuation">(</span><span class="token punctuation">[</span>    Dense<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">,</span> input_dim<span class="token operator">=</span>X_train<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    Dense<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    Dense<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'sigmoid'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 编译模型</span>model<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span>optimizer<span class="token operator">=</span><span class="token string">'adam'</span><span class="token punctuation">,</span> loss<span class="token operator">=</span><span class="token string">'binary_crossentropy'</span><span class="token punctuation">,</span> metrics<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'accuracy'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 训练神经网络</span>model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> epochs<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">,</span> validation_data<span class="token operator">=</span><span class="token punctuation">(</span>X_val<span class="token punctuation">,</span> y_val<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>使用XGBoost训练模型：<br>安装并引入XGBoost库，然后使用训练集对模型进行训练。</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> xgboost <span class="token keyword">as</span> xgb<span class="token comment"># 创建XGBoost分类器</span>xgb_clf <span class="token operator">=</span> xgb<span class="token punctuation">.</span>XGBClassifier<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 训练模型</span>xgb_clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>评估模型性能：<br>在验证集上评估模型性能，记录准确性、精确度、召回率、F1分数等评价指标。</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> accuracy_score<span class="token punctuation">,</span> precision_score<span class="token punctuation">,</span> recall_score<span class="token punctuation">,</span> f1_score<span class="token comment"># 神经网络预测</span>y_pred_nn <span class="token operator">=</span> model<span class="token punctuation">.</span>predict_classes<span class="token punctuation">(</span>X_val<span class="token punctuation">)</span><span class="token comment"># XGBoost预测</span>y_pred_xgb <span class="token operator">=</span> xgb_clf<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X_val<span class="token punctuation">)</span><span class="token comment"># 评估指标</span><span class="token keyword">def</span> <span class="token function">evaluate_model</span><span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_pred<span class="token punctuation">)</span><span class="token punctuation">:</span>    accuracy <span class="token operator">=</span> accuracy_score<span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_pred<span class="token punctuation">)</span>    precision <span class="token operator">=</span> precision_score<span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_pred<span class="token punctuation">)</span>    recall <span class="token operator">=</span> recall_score<span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_pred<span class="token punctuation">)</span>    f1 <span class="token operator">=</span> f1_score<span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_pred<span class="token punctuation">)</span>        <span class="token keyword">return</span> accuracy<span class="token punctuation">,</span> precision<span class="token punctuation">,</span> recall<span class="token punctuation">,</span> f1accuracy_nn<span class="token punctuation">,</span> precision_nn<span class="token punctuation">,</span> recall_nn<span class="token punctuation">,</span> f1_nn <span class="token operator">=</span> evaluate_model<span class="token punctuation">(</span>y_val<span class="token punctuation">,</span> y_pred_nn<span class="token punctuation">)</span>accuracy_xgb<span class="token punctuation">,</span> precision_xgb<span class="token punctuation">,</span> recall_xgb<span class="token punctuation">,</span> f1_xgb <span class="token operator">=</span> evaluate_model<span class="token punctuation">(</span>y_val<span class="token punctuation">,</span> y_pred_xgb<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Neural Network: Accuracy: &#123;&#125;, Precision: &#123;&#125;, Recall: &#123;&#125;, F1-score: &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>accuracy_nn<span class="token punctuation">,</span> precision_nn<span class="token punctuation">,</span> recall_nn<span class="token punctuation">,</span> f1_nn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"XGBoost: Accuracy: &#123;&#125;, Precision: &#123;&#125;, Recall: &#123;&#125;, F1-score: &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>accuracy_xgb<span class="token punctuation">,</span> precision_xgb<span class="token punctuation">,</span> recall_xgb<span class="token punctuation">,</span> f1_xgb<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="与支持向量机（SVM）和Logistic回归进行比较：-1"><a href="#与支持向量机（SVM）和Logistic回归进行比较：-1" class="headerlink" title="与支持向量机（SVM）和Logistic回归进行比较："></a>与支持向量机（SVM）和Logistic回归进行比较：</h2><p>训练支持向量机和Logistic回归模型，并在验证集上评估性能<br>将所选方法的性能与SVM和Logistic回归的性能进行比较，找出最佳模型<br>使用最佳模型在测试数据上进行预测：</p><ol><li>神经网络</li><li>XGBoost</li></ol><p>添加支持向量机（SVM）和Logistic回归模型，并在验证集上评估它们的性能。</p><ol><li>导入所需的库：</li></ol><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_split<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> accuracy_score<span class="token punctuation">,</span> classification_report<span class="token punctuation">,</span> confusion_matrix<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> LogisticRegression<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>svm <span class="token keyword">import</span> SVC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><p>加载数据并进行预处理（ 根据数据更改此部分代码）：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 使用自己的数据替换这一部分</span>data <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'your_data.csv'</span><span class="token punctuation">)</span>X <span class="token operator">=</span> data<span class="token punctuation">.</span>drop<span class="token punctuation">(</span>columns<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'target'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>y <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token string">'target'</span><span class="token punctuation">]</span><span class="token comment"># 如果还没有执行过特征选择和数据集不平衡处理， 在此处执行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>将数据拆分为训练集和验证集：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">X_train<span class="token punctuation">,</span> X_validation<span class="token punctuation">,</span> y_train<span class="token punctuation">,</span> y_validation <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> test_size<span class="token operator">=</span><span class="token number">0.2</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>训练支持向量机（SVM）模型：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">svm_model <span class="token operator">=</span> SVC<span class="token punctuation">(</span>kernel<span class="token operator">=</span><span class="token string">'rbf'</span><span class="token punctuation">)</span>svm_model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>评估SVM模型在验证集上的性能：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">y_valid_pred_svm <span class="token operator">=</span> svm_model<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X_validation<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Support Vector Machine validation accuracy:"</span><span class="token punctuation">,</span> accuracy_score<span class="token punctuation">(</span>y_validation<span class="token punctuation">,</span> y_valid_pred_svm<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>classification_report<span class="token punctuation">(</span>y_validation<span class="token punctuation">,</span> y_valid_pred_svm<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>confusion_matrix<span class="token punctuation">(</span>y_validation<span class="token punctuation">,</span> y_valid_pred_svm<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>训练Logistic回归模型：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">logistic_regression_model <span class="token operator">=</span> LogisticRegression<span class="token punctuation">(</span>random_state<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">,</span> max_iter<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">)</span>logistic_regression_model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>评估Logistic回归模型在验证集上的性能：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">y_valid_pred_logistic <span class="token operator">=</span> logistic_regression_model<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X_validation<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Logistic Regression validation accuracy:"</span><span class="token punctuation">,</span> accuracy_score<span class="token punctuation">(</span>y_validation<span class="token punctuation">,</span> y_valid_pred_logistic<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>classification_report<span class="token punctuation">(</span>y_validation<span class="token punctuation">,</span> y_valid_pred_logistic<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>confusion_matrix<span class="token punctuation">(</span>y_validation<span class="token punctuation">,</span> y_valid_pred_logistic<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>比较模型性能：</p><p>对于之前已经训练的神经网络和XGBoost模型， 确保 已经针对验证集评估了它们的性能。现在 可以比较这四种模型（神经网络、XGBoost、SVM和Logistic回归）在验证集上的性能，以确定最佳模型。最佳模型可以根据准确率、精确度、召回率、F1得分等多个指标进行评估。</p></li></ol><h1 id="使用最佳模型在预处理后的测试数据集上进行预测-1"><a href="#使用最佳模型在预处理后的测试数据集上进行预测-1" class="headerlink" title="使用最佳模型在预处理后的测试数据集上进行预测"></a>使用最佳模型在预处理后的测试数据集上进行预测</h1><p>分析预测结果，提出可能的优化方法（如参数调优、特征选择、不同模型结合等）</p><ol><li><p>加载测试数据并进行预处理（根据 数据集自行修改）：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#  使用 的数据替换这一部分</span>test_data <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'your_test_data.csv'</span><span class="token punctuation">)</span>X_test <span class="token operator">=</span> test_data<span class="token punctuation">.</span>drop<span class="token punctuation">(</span>columns<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'target'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>y_test <span class="token operator">=</span> test_data<span class="token punctuation">[</span><span class="token string">'target'</span><span class="token punctuation">]</span><span class="token comment"># 如果需要，根据 之前的策略对测试数据执行预处理和特征选择</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用最佳模型对测试数据进行预测（将<code>best_model</code>替换为 根据验证集性能选择的最佳模型实例）：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">y_test_pred <span class="token operator">=</span> best_model<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>X_test<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>评估最佳模型在测试集上的性能：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Test accuracy:"</span><span class="token punctuation">,</span> accuracy_score<span class="token punctuation">(</span>y_test<span class="token punctuation">,</span> y_test_pred<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>classification_report<span class="token punctuation">(</span>y_test<span class="token punctuation">,</span> y_test_pred<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>confusion_matrix<span class="token punctuation">(</span>y_test<span class="token punctuation">,</span> y_test_pred<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><p>分析预测结果后， 可以根据测试集上的表现提出一些建议以改进模型，方法包括：</p><ol><li><p>参数调优：通过网格搜索、随机搜索或贝叶斯优化等方法，调整最佳模型的超参数，以在测试集上实现更好的性能。</p></li><li><p>特征选择：重新审视特征选择过程，并尝试其他技术，如递归特征消除（RFE）、正则化方法（如L1或L2）等，以选择更具预测能力的特征子集。</p></li><li><p>不同模型的组合：尝试集成方法，如投票分类器、bagging或随机森林等，将多个模型的预测能力结合起来。这种组合可以让多个模型的优点相互补充，并在某些情况下提高预测性能。</p></li><li><p>更复杂的模型：如果目前的最佳模型无法捕捉到数据中的某些复杂模式， 可以尝试一些更复杂的模型，如深度学习模型。 注意，在采用更复杂的模型时，要防止过拟合，并确保 有足够的数据供模型学习。</p></li><li><p>数据增强：尝试通过数据可视化和探索性数据分析来深入了解数据，并考虑执行额外的特征工程和数据变换，以提取和利用数据中的更多信息。</p></li></ol><h2 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h2><p>在这份报告中， 概述在不平衡数据集上进行模型训练、评估和预测的整个过程，包括数据预处理、特征选择、模型训练、评估和预测。 还将描述所选方法的原理，并与支持向量机（SVM）和逻辑回归进行比较。最后， 提出可能的改进和优化建议。</p><ol><li><p>数据预处理：<br>在进行模型训练之前， 首先对数据集进行预处理。这包括以下几个步骤：<br> a) 处理缺失值： 采用插值或丢弃缺失值的方法来处理数据中的缺失值。<br> b) 数据标准化： 对数据进行标准化，使其服从标准正态分布，以提高模型性能。<br> c) 处理类别不平衡问题：由于数据集存在严重的类别不平衡问题， 采用过采样（如SMOTE）和&#x2F;或欠采样方法以平衡数据。</p></li><li><p>特征选择：<br>特征选择是选择最重要和最有意义的特征以提高模型性能的过程。 使用了以下方法：<br> a) 基于统计的特征选择：如皮尔逊相关系数和卡方检验等。<br> b) 基于模型的特征选择：如使用随机森林或XGBoost等模型进行特征重要性排序。</p></li></ol><p>通过特征选择， 能够减少特征的数量，从而减少模型的训练时间，同时提高模型性能。</p><ol start="3"><li>模型训练：<br> 选择了神经网络和XGBoost作为建模方法，并在预处理后的数据上进行了训练。 还分析了SVM和Logistic回归作为参考。</li></ol><p> a) 神经网络：基于大量神经元互相连接并形成网络的一种深度学习方法。具有强大的学习能力，特别适合学习在传统机器学习算法中难以学习的复杂规律。<br> b) XGBoost：一种基于梯度提升树的集成学习方法，能够很好地处理不平衡数据。具有优秀的性能、速度和准确率。</p><ol start="4"><li>模型评估和预测：<br>通过交叉验证和其他评估指标如准确率、F1-score、ROC-AUC等，对不同模型进行了比较。 选择性能最佳的模型，在预处理后的测试数据集上进行预测并分析结果。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Course </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 大二下 </tag>
            
            <tag> 量化交易与商业银行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计</title>
      <link href="/article/28d5cef4.html"/>
      <url>/article/28d5cef4.html</url>
      
        <content type="html"><![CDATA[<h1 id="概率论与数理统计"><a href="#概率论与数理统计" class="headerlink" title="概率论与数理统计"></a>概率论与数理统计</h1><h2 id="第一章-随机事件与概率"><a href="#第一章-随机事件与概率" class="headerlink" title="第一章 随机事件与概率"></a>第一章 随机事件与概率</h2><hr><h3 id="case1-事件运算及概率"><a href="#case1-事件运算及概率" class="headerlink" title="case1 事件运算及概率"></a>case1 事件运算及概率</h3><h4 id="1-1-随机试验与随机事件"><a href="#1-1-随机试验与随机事件" class="headerlink" title="1.1 随机试验与随机事件"></a>1.1 随机试验与随机事件</h4><p>样本空间:所有可能的结果的集合,记为Ω</p><p>样本点:样本空间中的元素</p><p>基本事件:是集合,仅在样本空间中单个结果的事件</p><h4 id="随机事件的关系及运算"><a href="#随机事件的关系及运算" class="headerlink" title="随机事件的关系及运算"></a>随机事件的关系及运算</h4><ol><li>包含关系</li><li>和事件</li><li>积事件</li><li>互不相容事件</li><li>对立事件(逆事件)实际就是补集的概念</li><li>差事件 A-B</li></ol><ul><li>A-B &#x3D; AB-hat &#x3D; A-AB &#x3D; A∪B - B</li></ul><ol><li>随机事件(集合)运算律:</li></ol><ul><li>交换律:A∪B &#x3D; B∪A , A∩B &#x3D; B∩A</li><li>结合律:括号可以随意调整</li><li>分配律:去掉括号,再分配</li><li>德摩根律:去掉hat时长变短开口换方向</li><li>吸收律:…</li></ul><hr><h3 id="case2-概率性质"><a href="#case2-概率性质" class="headerlink" title="case2 概率性质"></a>case2 概率性质</h3><h4 id="概率-Probability"><a href="#概率-Probability" class="headerlink" title="概率(Probability)"></a>概率(Probability)</h4><p>客观存在的常量</p><h4 id="频率"><a href="#频率" class="headerlink" title="频率"></a>频率</h4><p>定义:在相同条件下,进行n次实验,其中出现m次某结果,</p><p>这个比值叫做频率(m&#x2F;n)</p><p>性质:稳定性</p><h4 id="古典概率"><a href="#古典概率" class="headerlink" title="古典概率"></a>古典概率</h4><h4 id="古典概型试验"><a href="#古典概型试验" class="headerlink" title="古典概型试验"></a>古典概型试验</h4><ul><li>仅有__有限多个__基本事件</li><li>每个基本事件发生的__可能性相等__</li></ul><h4 id="概率的公理化定义"><a href="#概率的公理化定义" class="headerlink" title="概率的公理化定义"></a>概率的公理化定义</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241344268.png"></p><h4 id="由公理化定义可以得到很多重要性质"><a href="#由公理化定义可以得到很多重要性质" class="headerlink" title="由公理化定义可以得到很多重要性质:"></a>由公理化定义可以得到很多重要性质:</h4><ol><li>不可能事件的概率为0,即$P(\phi)&#x3D;0$ #逆命题不真</li><li>有限可加性</li><li>对立事件概率和为1,$P(A)+P(A_hat)&#x3D;1$</li><li>概率单调性</li></ol><h4 id="概率加法定理"><a href="#概率加法定理" class="headerlink" title="概率加法定理"></a>概率加法定理</h4><p>又名 多除少补原理</p><p>$P\left(A_1\cup A_2\cup\ldots\cup A_n\right)&#x3D;\sum_{i&#x3D;1}^n P\left(A_n\right)-\sum_{1\leq i&lt;j\leq n}P\left(A_i A_j\right)+\sum_{1\leq i&lt;j&lt;k\leq n}P\left(A_i A_j A_k\right)-\ldots+(-1)^{n-1}P\left(A_1 A_2\ldots A_n\right)$</p><h4 id="做题过程"><a href="#做题过程" class="headerlink" title="做题过程"></a>做题过程</h4><ul><li>定义事件ABC…</li><li>交代是什么问题(e.g. 这是个古典概型问题)</li><li>Attention:摸球分类模型不需要过程,直接算就行(超几何分布适用)</li></ul><hr><h3 id="case3-条件概率"><a href="#case3-条件概率" class="headerlink" title="case3 条件概率"></a>case3 条件概率</h3><p>条件概率满足概率定义的三个公理</p><h4 id="全概率公式"><a href="#全概率公式" class="headerlink" title="全概率公式"></a>全概率公式</h4><p>内容：如果事件$B1、B2、B3…Bi$构成一个<a href="https://baike.baidu.com/item/%E5%AE%8C%E5%A4%87%E4%BA%8B%E4%BB%B6%E7%BB%84/6451190?fromModule=lemma_inlink">完备事件组</a>，即它们两两互不相容，其和为全集；并且$P(Bi)$大于0，则对任一事件A有</p><p>$$<br>P(A)&#x3D;P(A|B1)P(B1) + P(A|B2)P(B2) + … + P(A|Bi)P(Bi)<br>$$</p><h4 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h4><p>用来解决<em><strong>事后问题</strong></em>,结果已经发生,求哪个原因导致的</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241346990.png"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241347006.png"></p><h4 id="独立的定义和证明"><a href="#独立的定义和证明" class="headerlink" title="独立的定义和证明"></a>独立的定义和证明</h4><p>$P(AB)&#x3D;P(A)P(B)$</p><h4 id="三个相互独立的证明"><a href="#三个相互独立的证明" class="headerlink" title="三个相互独立的证明:"></a>三个相互独立的证明:</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241347058.png"></p><hr><h2 id="第二章-随机变量及其分布"><a href="#第二章-随机变量及其分布" class="headerlink" title="第二章 随机变量及其分布"></a>第二章 随机变量及其分布</h2><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241351878.png" alt="image-20221224135157803"></p><h4 id="随机变量的定义"><a href="#随机变量的定义" class="headerlink" title="随机变量的定义"></a>随机变量的定义</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241352318.png"></p><h4 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h4><p>实际也是个函数,至少我觉得</p><p>事件E的样本空间为$\omega$,对于每一个样本点$\omega$∈$\omega$,都有一个唯一的实数x($\omega$)与之对应,那么x就是随机变量,是个可测函数,挺好用的,找个实数对应</p><h4 id="分布函数"><a href="#分布函数" class="headerlink" title="分布函数"></a>分布函数</h4><p>设X是一个随机变量,x是任意的实数,称函数</p><p>F(x) &#x3D; P{X&lt;&#x3D;x} &#x3D; P{$\omega$: X($\omega$) &lt;&#x3D; x}</p><p>为随机变量X的分布函数</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241352465.png"></p><h4 id="分布函数三条性质"><a href="#分布函数三条性质" class="headerlink" title="分布函数三条性质:"></a>分布函数三条性质:</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241352667.png"></p><p>最后讲<strong>混合型随机变量</strong>，一个陀螺，一半刻1，一半刻0-1连续的数字，落地数字的分布律，要证明分布函数既不连续也不离散：</p><p>不连续，因为图像不连续，由连续型随机变量分布函数的逆否命题可得，不离散，因为图像不是阶梯形</p><h4 id="六个常见的离散型随机变量分布："><a href="#六个常见的离散型随机变量分布：" class="headerlink" title="六个常见的离散型随机变量分布："></a>六个常见的离散型随机变量分布：</h4><ul><li><p>几何分布 k次实验才成功的概率(也就是前面k-1次都失败了)</p></li><li><p>超几何分布 不放回，用A排列去算(抽球)</p></li><li><p>负二项分布（帕斯卡分布）eg n次成功前失败x的次数分布</p><ul><li>可以看成几何分布的推广(很多个几何分布加起来)</li></ul></li><li><p>二项分布（超几何分布的极限情况，样本空间足够大）</p></li><li><p>两点分布 (伯努利分布,就是二项分布的n&#x3D;1时的情况)</p></li><li><p>柏松分布（小概率事件发生的次数）</p></li></ul><h4 id="三个连续型随机变量"><a href="#三个连续型随机变量" class="headerlink" title="三个连续型随机变量"></a>三个连续型随机变量</h4><ul><li>均匀分布</li><li>指数分布</li><li>正态分布</li></ul><hr><h3 id="case1-离散型随机变量"><a href="#case1-离散型随机变量" class="headerlink" title="case1 离散型随机变量"></a>case1 离散型随机变量</h3><p>remember 超几何分布(不放回)的极限条件就是二项分布</p><h3 id="独立重复实验"><a href="#独立重复实验" class="headerlink" title="独立重复实验"></a>独立重复实验</h3><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241353321.png"></p><h3 id="伯努利概型"><a href="#伯努利概型" class="headerlink" title="伯努利概型"></a>伯努利概型</h3><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241354330.png" alt="image-20221224135403194"></p><h3 id="几何分布"><a href="#几何分布" class="headerlink" title="几何分布"></a>几何分布</h3><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241354236.png" alt="image-20221224135412126"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241354236.png"></p><p>这个性质个人理解就是每个事件相互独立互不影响,因此就没有所谓的”后效性”</p><h3 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h3><p>后面有详细介绍（五种重要分布那章）</p><hr><h3 id="case2-一维随机变量"><a href="#case2-一维随机变量" class="headerlink" title="case2 一维随机变量"></a>case2 一维随机变量</h3><h4 id="离散型随机变量"><a href="#离散型随机变量" class="headerlink" title="离散型随机变量"></a>离散型随机变量</h4><ul><li>分布律,分布函数</li><li>函数的分布</li></ul><h4 id="连续性随机变量"><a href="#连续性随机变量" class="headerlink" title="连续性随机变量"></a>连续性随机变量</h4><ul><li>概率密度,分布函数(必考)</li><li>函数的分布</li></ul><h4 id="离散型随机变量分布律-分布函数"><a href="#离散型随机变量分布律-分布函数" class="headerlink" title="离散型随机变量分布律,分布函数"></a>离散型随机变量<em>分布律,分布函数</em></h4><h5 id="分布律"><a href="#分布律" class="headerlink" title="分布律"></a>分布律</h5><h4 id="例一-抽球-6个球-4白2黑-随机抽两个-求-1-抽到白球X的分布律-2-随机变量X的分布函数"><a href="#例一-抽球-6个球-4白2黑-随机抽两个-求-1-抽到白球X的分布律-2-随机变量X的分布函数" class="headerlink" title="$例一:抽球,6个球,4白2黑,随机抽两个,求(1)抽到白球X的分布律 (2)随机变量X的分布函数$"></a>$例一:抽球,6个球,4白2黑,随机抽两个,求(1)抽到白球X的分布律 (2)随机变量X的分布函数$</h4><p>$例二:给出随机变量X的分布函数,求X的分布律和P{-1 &lt; X &lt;&#x3D; 3}$</p><h5 id="函数的分布"><a href="#函数的分布" class="headerlink" title="函数的分布"></a>函数的分布</h5><p>例一$给出随机变量X的分布律,求U&#x3D;X- 1的分布律,W&#x3D;X^2的分布律$</p><p>这个很简单,合并同类项就可以了</p><h4 id="连续型随机变量的概率密度-分布函数"><a href="#连续型随机变量的概率密度-分布函数" class="headerlink" title="连续型随机变量的概率密度,分布函数"></a>连续型随机变量的<em>概率密度,分布函数</em></h4><p>$例一:给出连续型随机变量X的概率密度函数f(x),求里面的常数,P(X&gt;&#x3D;0.5),分布函数F(x)$</p><p>需要知道概率密度f(x)的性质有:</p><ul><li>归一性:从-∞到+∞积分是1</li><li>$F(x)&#x3D;P{X\leq x}&#x3D;\int_{-\infty}^{x}f(x)dx$</li><li>****$P{a\leq X\leq b}&#x3D;F(b)- F(a)&#x3D;\int_{a}^{b}f(x)dx$</li></ul><p>$例二:给出连续型随机变量的分布函数F(x)&#x3D;A+Barctanx,-∞&lt;x&lt;+∞,求:系数AB,P{-1&lt;X&lt;1},X的概率密度f(x)$</p><p>需要知道分布函数的性质:</p><ul><li>F(x) &#x3D; P{X&lt;x}</li><li>0 &lt;&#x3D; F(x) &lt;&#x3D; 1</li><li>F’(x) &#x3D; f(x)</li><li>右连续</li><li>归一性：在定义域范围内积分后得到1</li></ul><p>P{X &#x3D;x_0} &#x3D; 0 ,这也可以推出一个好玩的事实：</p><p>即概率为零不一定是不可能事件，因为连续型概率密度上每个点的概率都是0，但是也有可能发生。</p><p>因此，求开区间，闭区间，半开半闭区间上的分布函数最后得到的都一样</p><p>补充一道题目：</p><p>证明标准正态分布的函数是概率密度函数</p><p>（1）非负性       这玩意不用证明，一眼定真</p><p>（2）归一性       这玩意没法直接积分，需要先平方化成二重积分，再换元转换极坐标，然后积分</p><hr><h3 id="case3-五种重要分布"><a href="#case3-五种重要分布" class="headerlink" title="case3 五种重要分布"></a>case3 五种重要分布</h3><h4 id="离散型"><a href="#离散型" class="headerlink" title="离散型"></a>离散型</h4><ul><li>二项分布</li><li>泊松分布</li></ul><h4 id="连续型"><a href="#连续型" class="headerlink" title="连续型"></a>连续型</h4><ul><li>均匀分布</li><li>指数分布</li><li>正态分布</li></ul><ol><li><strong>离散型--二项分布</strong></li></ol><p>记作:$X~b(n,p)分布律:P{X&#x3D;k}&#x3D;C^k_np^k(1-p)^(n-k)$ ——n是样本个数,p是发生概率</p><blockquote><p>例一:5台机器,每台使用相互独立,每台同时被使用概率为0.1,问:(1)恰有两台被使用概率(2)至少有两台被使用</p></blockquote><ol start="2"><li><strong>离散型--泊松分布</strong></li></ol><p>记作:$X~\pi(\lambda)$ 分布律:$P(X&#x3D;k)&#x3D;\frac{\lambda^k}{k!}e^{-\lambda},k&#x3D;0,1,\cdots$</p><p>计算小概率事件就用泊松分布</p><p>泊松与二项之间的关系:通常$n\geq 20,p\leq 0.05$时就可以用泊松分布近似计算了</p><p>泊松中的$\lambda&#x3D;np$,事实上泊松由二项推导出来</p><ol start="3"><li><strong>连续型--均匀分布（Uniform）</strong></li></ol><p>记作:$X\sim U(a,b)$<br>概率密度:</p><p>$f(x)&#x3D;\frac{1}{b-a},\quad a&lt;x&lt;b$</p><p>$f(x)&#x3D;0$, else</p><p>应用：计算机上面的伪随机数一般用均匀分布生成</p><ol start="4"><li><strong>连续型--指数分布（Exponent）</strong></li></ol><p>记作:$X E(λ)$ 概率密度:</p><p>$f(x)&#x3D;\lambda e^{-\lambda x},\quad x&gt;0$</p><p>$ f(x) &#x3D; 0 , x \leqslant0$</p><p>没有分布函数，该补充</p><p>指数函数的无记忆性:</p><p>$P{X&gt;s+t|X&gt;s}&#x3D;P{X&gt;t},\quad P{X&gt;s}&gt;0$</p><p>其中 $X$ 是一个随机变量，$s$ 和 $t$ 是实数。</p><p>举个简单的例子便于理解:</p><p>一个灯泡用了s个小时,求再用t 小时报废的概率,和从0开始计时, 用了t小时报废的概率相同</p><ol start="5"><li><strong>连续型--正态分布（Gauss）</strong></li></ol><p>记作:$X~N(μ,σ^2)$ ,</p><p>概率密度: $f(x)&#x3D;\frac{1}{\sqrt{2\pi}σ}e^{-\frac{x-μ^2}{2σ^2}$</p><p>$f(x)&#x3D;\frac{1}{\sqrt{2\pi} \sigma} e^{-\frac{(x-\mu)^2}{2\sigma^2}}$</p><p>标准正态分布：X～N（0，1）</p><p><strong>特征</strong>：</p><ul><li>归一性：不必多说</li><li>曲线关于$x &#x3D; \mu $对称</li><li>最大值$ \frac{1}{\sigma \sqrt{2\pi }}$在$ x &#x3D; \mu $ 处取得</li></ul><h5 id="正态分布概率的计算"><a href="#正态分布概率的计算" class="headerlink" title="正态分布概率的计算"></a>正态分布概率的计算</h5><p>关于正态分布的分布函数：用大$\phi$表示</p><p>$\phi(x;\mu,\sigma^2)$</p><p>听说处有16个公式需要记忆</p><p>由于不符合牛顿莱布尼兹公式，所以查表寻值（参考附录给出的表格）</p><h4 id="公式如下："><a href="#公式如下：" class="headerlink" title="公式如下："></a>公式如下：</h4><ul><li>标准正态分布有： $\phi(-x) &#x3D; 1 - \phi(x)$</li><li>对于非规则的（$\mu , \sigma$不为0） ：有$\phi(x;\mu,\sigma^2) &#x3D; \phi(\frac{x - \mu}{\sigma})$</li><li>此处有标准化变换：令$y &#x3D; \frac{t - \mu}{\sigma}$</li><li>$\phi(u_\alpha) &#x3D; 1 - \alpha$</li></ul><h5 id="还有个挺常用的公式："><a href="#还有个挺常用的公式：" class="headerlink" title="还有个挺常用的公式："></a>还有个挺常用的公式：</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241403177.png"></p><hr><h2 id="第三章-二维随机变量及其分布"><a href="#第三章-二维随机变量及其分布" class="headerlink" title="第三章 二维随机变量及其分布"></a>第三章 二维随机变量及其分布</h2><h4 id="联合分布函数"><a href="#联合分布函数" class="headerlink" title="联合分布函数"></a>联合分布函数</h4><p>定义：设随机试验E的样本空间为$\Omega$，对于每一个样本点$\omega$属于$\Omega$，有两个实数$X(\omega)Y(\omega)$，与之对应，则称它们组成的有序数组（X，Y）为二维随机变量。</p><p>注：X，Y都是定义在$\Omega$上的随机变量</p><p>$F_X(x)&#x3D;P{X\leq x}$</p><p>$F_Y(y)&#x3D;P{Y\leq y}$</p><p>$$<br>F(x,y) &#x3D; P{X \leq x , Y \leq y}<br>$$</p><p>说明是以（x，y）为顶点的左下方的无穷矩形的面积</p><p><strong>联合分布函数</strong>和<strong>边缘分布函数</strong>的概念:</p><p><a href="https://baike.baidu.com/item/%E8%81%94%E5%90%88%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0/18885427">联合分布函数</a></p><ul><li>其实有点条件概率的那个感觉</li></ul><p>有了联合分布函数可以求边缘分布函数，反过来却不行，因为不能保证两个变量相互独立</p><h4 id="联合分布函数的性质"><a href="#联合分布函数的性质" class="headerlink" title="联合分布函数的性质"></a>联合分布函数的性质</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241406754.png"></p><p>最后一条还挺重要的，叫做相容性。</p><p>然后讲课就推广到了n维</p><h4 id="联合分布律"><a href="#联合分布律" class="headerlink" title="联合分布律"></a>联合分布律</h4><h5 id="可能的考点"><a href="#可能的考点" class="headerlink" title="可能的考点"></a>可能的考点</h5><p>元件组寿命</p><ol><li><p>并联</p><p>a. $T &#x3D; max(x_1,x_2,…,x_n)$</p></li><li><p>串联</p><p>a. $T &#x3D; min(x_1,x_2,…,x_n)$</p></li></ol><h4 id="求T的分布"><a href="#求T的分布" class="headerlink" title="求T的分布?"></a><strong>求T的分布?</strong></h4><p>一.,</p><p><strong>1.1</strong></p><p>$$<br>F_Z(z) &#x3D; P{max(x_1,…,x_n) \leq z}<br>$$</p><p>$$<br>&#x3D; P{x_1 \leq z,x_2 \leq z,…,x_n \leq z}<br>$$</p><p>$$<br>&#x3D; F(z,z,…,z)<br>$$</p><p>加个条件 —- 若$x_1,x_2,…,x_n$<strong>相互独立</strong>,则:</p><p>$$&#x3D; F_{x_1}(z)…F_{x_n}(z)$$</p><p>再加个条件$x_1,..,x_n$<strong>独立且同分布</strong>,则:</p><p>$$F_{x_1}^n(z)$$</p><p>此时</p><p>$$f_Z(z) &#x3D; nF_{x_1}^{n-1}(z)f_{x_1}(z)$$</p><p><strong>1.2</strong></p><p>$F_Z(z)&#x3D;P{min(z_1,z_2,…,z_n)\leq z}$</p><p>$$&#x3D; P{Z_1 \leq z \cup Z_2 \leq z \cup … \cup Z_n \leq z}$$</p><p>$$&#x3D; 1-P{Z_1 &gt; z , Z_2 &gt; z , …,Z_n &gt; z}$$</p><p>若$x_1,…,x_n$<strong>独立同分布</strong>:</p><p>$$&#x3D; 1 - P^n{Z_1 &gt; z } &#x3D; 1 - [ 1 - F_Z(z)]^n$$</p><p>则:</p><p>$$f_Z(z) &#x3D; n[1-F_Z(z)]^{n-1}f_Z(z)$$</p><p>二.</p><p>已知(X,Y)联合密度f(x,y),求Z &#x3D; X + Y 的密度$f_Z(z)$</p><p>1 求$F_Z(z) &#x3D; P{ X + Y \leq z}$</p><p>$$&#x3D;\iint\limits_{x+y\leq z}f(x,y)d\delta$$</p><p>$$&#x3D;\int_{-\infty}^{+\infty} [\int_{-\infty}^{z-x}f(x,y)dy]dx$$</p><p>not equal(不要随便换)</p><p>$$\int_{-\infty}^{z-x}[\int_{-\infty}^{+\infty}f(x,y)dx]dy$$</p><p><em><strong><strong>令u &#x3D;y + x y &#x3D; u - x</strong></strong></em></p><p>$$&#x3D; \int_{-\infty}^{+\infty} [\int_{-\infty}^{z}f(x,u-x)du]dx$$</p><p>$$&#x3D;\int_{-\infty}^{z} [\int_{-\infty}^{+\infty}f(x,u-x)dx]du$$</p><p>$$f’<em>Z(z) &#x3D; \int</em>{-\infty}^{+\infty}f(x,z-x)dx$$</p><p>$$&#x3D;\int_{-\infty}^{+\infty}f(z-y,y)dy$$</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241407561.png"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241407936.png"></p><hr><h3 id="case1-二维离散型随机变量"><a href="#case1-二维离散型随机变量" class="headerlink" title="case1 二维离散型随机变量"></a>case1 二维离散型随机变量</h3><h4 id="下面例题看懂就行"><a href="#下面例题看懂就行" class="headerlink" title="下面例题看懂就行"></a>下面例题看懂就行</h4><p>例题：</p><p>已知二维离散型随机变量（X，Y）的联合分布律为下：</p><blockquote><p>balabala</p></blockquote><ol><li>P{x &#x3D; -1 , Y &#x3D;2} and P{X&lt;&#x3D; Y }（没什么说的，顾名思义）</li><li>X和Y的边缘分布律（就是不考虑另外一个变量）</li><li>X和Y是否独立（独立条件：P{X &#x3D; x_i,Y &#x3D; y_i} &#x3D; P{X &#x3D;x_i}*P{Y&#x3D;y_i} ，注：一般都不独立，所以找个反例就ok）</li><li>Z &#x3D; X + Y ，W &#x3D; max{X , Y } 的分布律（还是那会事，合并同类项就行）</li><li>P{X &#x3D; -1|Y &#x3D; 1} （条件概率，利用那个啥，条件概率公式就可）</li></ol><p>此处可以有二维离散型随机变量的定义：略。</p><h4 id="二维的两点分布"><a href="#二维的两点分布" class="headerlink" title="二维的两点分布"></a>二维的两点分布</h4><p>举个简单的例子：用剪刀剪一个悬挂小球的细绳，剪中绳子记为X，小球坠落记为Y，那么F（x，y）就是了</p><p>实际上X是因Y是果，但是符合两点分布。</p><h4 id="联合概率密度"><a href="#联合概率密度" class="headerlink" title="联合概率密度"></a>联合概率密度</h4><p>最重要的性质：<strong>必考</strong></p><p>性质四：</p><p>$$p{(X,Y)\in  G}  &#x3D; \iint_G f(x,y)d\sigma$$</p><p>性质五：</p><p>$$f_X(x) &#x3D; \int_{-∞}^{+∞}f(x,y)dy$$</p><p>反过来$f_Y(y)$也是如此</p><p>$$f_Y(y) &#x3D; \int_{-∞}^{+∞} f(x,y)dx$$</p><hr><h3 id="case2-连续型二维随机变量"><a href="#case2-连续型二维随机变量" class="headerlink" title="case2 连续型二维随机变量"></a>case2 连续型二维随机变量</h3><p>用到了二重积分</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241412037.png"></p><p>$$P{a&lt;x\leq b | Y &#x3D; y} &#x3D; \int_a^b f_{X|Y}(x|y)dx$$</p><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p>$设二维随机变量(X,Y)的概率密度为f(x,y)&#x3D;Cxy0&lt;x&lt;10&lt;y&lt;1(else为0)$</p><p>求:</p><p>$(1)常数C和P{X+Y&lt;1}$}</p><p>$(2)(X,Y)的边缘概率密度$ *实际上就是求带参函数的积分,难点就是上下限的确定,可以画图解决</p><p>$(3) f_{X|Y}(x|y) 和 f_{Y|X}(y|x)$</p><p>$(4) 判定X和Y是否相互独立 $</p><p>(1) 归一性的应用,还有二重积分的应用</p><p>(2)边缘概率密度直接套公式,XY分开求,另一个从负无穷积到正无穷</p><p>(3)条件概率的计算而已,套条件密度概率公式</p><p>(4) 独立性检验直接检测交集是不是概率相乘,还是套上图公式</p><p><em>有些题目换坐标轴即可</em></p><h5 id="二维均匀分布的例题-约会问题"><a href="#二维均匀分布的例题-约会问题" class="headerlink" title="二维均匀分布的例题(约会问题)"></a>二维<em>均匀分布</em>的例题(约会问题)</h5><p>甲乙两艘船要停泊,24小时内到达的概率都是等可能的,且相互独立,如果甲停1小时,乙停2小时,那么求两个中任何一个都不需要等待的概率</p><p>分析:</p><p>X,Y分别表示甲乙船到达时刻,则它们符合均匀分布,$x<del>U(0,24)Y</del>U(0,24)$</p><p>且相互独立,</p><p>若</p><p>$ X&lt; Y \to  X + 1 &lt; Y$</p><p>$ X&gt;Y  \to X &gt; Y +2$</p><p>求</p><p>$P{X+1&lt;Y或X&gt;Y+2}$</p><h5 id="二维正态分布"><a href="#二维正态分布" class="headerlink" title="二维正态分布"></a>二维正态分布</h5><p>有一个看起来很复杂的公式:</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241412299.png"></p><p>然后有(X,Y)服从二维正态分布,记为$(X,Y)~N(\mu_1,\sigma_1^2;\mu_2,\sigma_2^2;ρ)$</p><p>注:|ρ|&lt;1</p><p>推论: <del>据说会考推论的使用</del></p><ul><li><p>$X<del>N(\mu_1,\sigma_1^2)Y</del>N(\mu_2,\sigma_2^2)$</p></li><li><p>独立性balabala,求X,Y的边缘概率密度非常的巧妙,中间凑出来了一个正态分布的标准式子(通过对二次的配项)</p></li><li><p>详细证明可以看百科</p><ul><li><a href="ahref=%22https://baike.baidu.com/item/%E4%BA%8C%E7%BB%B4%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83/2951835%22">ahref&#x3D;&amp;#34;https://baike.baidu.com/item/%E4%BA%8C%E7%BB%B4%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83/2951835&#34;</a>二维正态分布_百度百科 (baidu.com)<code>&lt;/a&gt;</code></li></ul></li></ul><hr><h3 id="case3-二维连续型函数的分布"><a href="#case3-二维连续型函数的分布" class="headerlink" title="case3 二维连续型函数的分布"></a>case3 二维连续型函数的分布</h3><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241413912.png"></p><h4 id="两个结论↑"><a href="#两个结论↑" class="headerlink" title="两个结论↑"></a>两个结论↑</h4><p>替换:Y&#x3D;Z - X</p><ol><li><p>替换:Y&#x3D;Z - X</p><p>a. $f_Z(z) &#x3D; \int_{-∞}^{＋∞}f(x,z-x)dx$</p><p>b. 确定被积函数:f(x,z-x)dx</p><p>c. 确定x的积分范围</p><p>d. 分情况,带入公式</p></li><li><p>替换:X &#x3D; Z - Y</p><p>a. $f_Z(z) &#x3D; \int_{-\infty}^{+\infty}f(z-y,y)$</p><p>b. 确定被积函数:f(z-y,y)dy</p><p>c. 确定y的积分范围</p><p>d. 分情况,带入公式</p></li></ol><h4 id="Z-x3D-XY分布-替换-Y-x3D-frac-Z-X"><a href="#Z-x3D-XY分布-替换-Y-x3D-frac-Z-X" class="headerlink" title="Z &#x3D; XY分布  替换 : $Y &#x3D; \frac{Z}{X}$"></a>Z &#x3D; XY分布  替换 : $Y &#x3D; \frac{Z}{X}$</h4><ol><li>$f_{XY}(z) &#x3D; \int_{-\infty}^{+\infty} \frac{1}{|x|}f(x,\frac{z}{x})dx$</li><li>确定被积函数:$\frac{1}{|x|}f(x,\frac{z}{x})$</li><li>确定x的积分范围</li><li>分情况,代入公式</li></ol><h4 id="Z-x3D-max分布"><a href="#Z-x3D-max分布" class="headerlink" title="Z &#x3D; max分布"></a>Z &#x3D; max分布</h4><ol><li>$F_{max}(z) &#x3D; F_X(z) \times F_Y(z)$</li><li>$f_{max}(z) &#x3D; F&#96;_{max}(z)$</li></ol><p>若X,Y独立同分布</p><ol><li>$F_{max}(z) &#x3D; [F_X(z)]^2$</li><li>$ f_{max}(z) &#x3D; F&#96;_{max}(z)$</li></ol><hr><h3 id="case4-二维独立性"><a href="#case4-二维独立性" class="headerlink" title="case4 二维独立性"></a>case4 二维独立性</h3><h4 id="二维随机变量的独立性"><a href="#二维随机变量的独立性" class="headerlink" title="二维随机变量的独立性"></a>二维随机变量的独立性</h4><p>随机变量A与B相互独立,则</p><p> $ P(AB) &#x3D; P(A)P(B)$</p><p>定义: 设(X,Y)是二维随机变量,若对任何实数对(x,y)均有</p><p>$$P{X\leq x,Y\leq y} &#x3D; P{X\leq x}P{Y\leq y}$$</p><ul><li>实际做题应该只考察证明不独立,找出一个<strong>反例</strong>即可</li></ul><p>连续型XY相互独立</p><p>$$<br>f(x,y) &#x3D; f_X(x)f_Y(y)<br>$$</p><p>推广到n个的情况也是如此，如果只求有限个则令其余部分趋向正无穷</p><ul><li>m维随机向量和n维随机向量相互独立</li><li>随机变量h（x1，x2…)和g（xm,x…)也是相互独立</li></ul><p>例：3维随机变量x1，x2，x3相互独立，则</p><table><thead><tr><th>3维随机变量</th><th>相互独立关系</th></tr></thead><tbody><tr><td>$x_1^2,x_2^2,x_3^2$</td><td>相互独立</td></tr><tr><td>$x_1+x_2$与$x_3$</td><td>相互独立</td></tr><tr><td>$\sin x_1$与$x_2$</td><td>相互独立</td></tr><tr><td>$x_1-x_2$与$x_1+x_2$</td><td>无法判断相互独立关系</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241408235.png" alt="image-20221224140854803"></p><hr><h3 id="case5-二维条件分布"><a href="#case5-二维条件分布" class="headerlink" title="case5 二维条件分布"></a>case5 二维条件分布</h3><p>$P{Y\geq y|X  &#x3D; x}$为“当X &#x3D; x”时，Y的条件分布函数，记为$F_{Y|X}(y|x)$</p><ul><li>注：$F_X(x)$是一元函数，$F(x,y)$是二元函数，$F_{Y|X}(y|x)$是一元函数,x当成常量处理（x是参量），y是变量</li></ul><p>离散两个公式，连续两个公式：</p><p>条件密度概率公式的推导中间用了拉格朗日定理：</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241414490.png"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241415658.png"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241415582.png"></p><hr><h3 id="case6-随机变量的函数及其分布"><a href="#case6-随机变量的函数及其分布" class="headerlink" title="case6 随机变量的函数及其分布"></a>case6 随机变量的函数及其分布</h3><p>主要内容: $h(x_1,x_2,…,x_n)$确定Y</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241416575.png"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241416874.png"></p><p>区间的开闭需要注意</p><h4 id="离散型随机变量的函数与分布律"><a href="#离散型随机变量的函数与分布律" class="headerlink" title="离散型随机变量的函数与分布律"></a>离散型随机变量的函数与分布律</h4><p>$Y &#x3D; g(X) $是随机变量,则:</p><p>$$P{Y &#x3D; y_j} &#x3D; P{g(X) &#x3D; y_j} &#x3D; \sum_{x_i \in S_j}P{X &#x3D; x_i} , j &#x3D; 1,2,…$$</p><h5 id="离散卷积公式"><a href="#离散卷积公式" class="headerlink" title="离散卷积公式"></a>离散卷积公式</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241417612.png"></p><p>p一样,相互独立的二项分布加在一起也是二项分布,所以二项分布是具有可加性的分布</p><p>具有可加性的分布还有泊松分布</p><p>关于如何证明具有可加性,二项见上,剩下的可以根据<em>两个条件</em>推导</p><h4 id="连续型随机变量的函数及其分布"><a href="#连续型随机变量的函数及其分布" class="headerlink" title="连续型随机变量的函数及其分布"></a>连续型随机变量的函数及其分布</h4><ul><li>设X是连续型随机变量,若Y &#x3D; g(X)也是连续型随机变量,则:</li></ul><p>$$F_Y(y) &#x3D; P{g(X) \leq y } &#x3D; \int_{X|g(x) \leq y} f_X(x)dx$$</p><ul><li><p>从前有个人,想研究标准正态分布的平方,还有更多的推导,所以有了以下内容:</p><ul><li>自由度为1的$\chi ^2$分布</li></ul></li></ul><hr><h2 id="第四章-随机变量的数字特征"><a href="#第四章-随机变量的数字特征" class="headerlink" title="第四章 随机变量的数字特征"></a>第四章 随机变量的数字特征</h2><hr><h3 id="case1-数学期望-方差"><a href="#case1-数学期望-方差" class="headerlink" title="case1 数学期望,方差"></a>case1 数学期望,方差</h3><h4 id="常见分布的期望与方差"><a href="#常见分布的期望与方差" class="headerlink" title="常见分布的期望与方差"></a>常见分布的期望与方差</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241418058.png"></p><hr><h4 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>设连续型随机变量X的概率密度为f(,x),若$\int_{-\infty}^{+\infty}|x|f(x)dx&lt;+\infty$ 绝对收敛确保数学期望有唯一的数值</p><p>则称$E(X) &#x3D; \int_{-\infty}^{+\infty} xf(x) dx$</p><p>为X的数学期望</p><p>注:</p><ul><li>期望时所有可能取值的加权平均值</li><li>部分随机变量X的数学期望不存在,比如后面的柯西分布</li></ul><h5 id="一个核心定理"><a href="#一个核心定理" class="headerlink" title="一个核心定理"></a>一个核心定理</h5><h5 id="设X是随机变量-Y-x3D-g-X-也是随机变量-计算E-g-X"><a href="#设X是随机变量-Y-x3D-g-X-也是随机变量-计算E-g-X" class="headerlink" title="设X是随机变量,Y&#x3D; g(X)也是随机变量,计算E[g(X)]"></a>设X是随机变量,Y&#x3D; g(X)也是随机变量,计算E[g(X)]</h5><ol><li>若X是离散型随机变量,分布律为</li></ol><p>$P{X &#x3D; x_i} &#x3D; p_i, i &#x3D; 1,2,3..$</p><p>若:$\sum_{i&#x3D;1}^{+\infty}g(x_i)p_i$绝对收敛,则有</p><p>$E(Y) &#x3D; E[g(X)] &#x3D; \sum_{i&#x3D;1}^{+\infty}g(x_i)p_i$</p><p>X是连续型随机变量,概率密度为$f_X(x)$</p><ol start="2"><li>X是连续型随机变量,概率密度为$f_X(x)$</li></ol><p>若$\int_{-\infty}^{+\infty}|g(x)|f(x)&lt;+\infty $</p><p>则</p><p>$E(Y) &#x3D; E[g(X)] &#x3D; \int_{-\infty}^{+\infty}g(x)f_X(x)dx$</p><ul><li><p>有些分布期望不存在</p></li><li><p>柯西分布$f(x)&#x3D;\frac{1}{\pi(1+x^2)}$</p><ul><li>因为不满足xf(x)条件收敛</li></ul></li></ul><p>如果随机变量相互独立,不仅$f(x,y) &#x3D; f_X(x)f_Y(y)$,而且期望$E(XY) &#x3D; E(X)E(Y)$</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241420926.png"></p><h4 id="随机变量期望的性质"><a href="#随机变量期望的性质" class="headerlink" title="随机变量期望的性质"></a>随机变量期望的性质</h4><ul><li><p>常数的期望为本身$E(c) &#x3D; c$</p></li><li><p>线性性: $E(cX) &#x3D; cE(X)$</p><ul><li>$E(aX + b) &#x3D; aE(X) + b$</li></ul></li><li><p>$E(\sum_{i&#x3D;1}^{n}X_i) &#x3D; \sum_{i &#x3D; 1}^{n}E(X_i)$</p></li><li><p>若$X_1,X_2,…,X_n$相互独立,则$E(\prod_{i&#x3D;1}^{n}X_i)&#x3D;\prod_{i&#x3D;1}^{n}E(X_i)$</p></li></ul><hr><p>刻画了随机变量X相对数学期望的偏离程度</p><ul><li>刻画了随机变量X相对数学期望的偏离程度</li><li>方差是随机变量X关于任何值的偏离程度的最小值(当然,关于自身数学期望的偏离程度最小)</li></ul><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241419858.png"></p><ul><li>$D(X)\geq0$</li></ul><h4 id="关于离散型和连续型的计算"><a href="#关于离散型和连续型的计算" class="headerlink" title="关于离散型和连续型的计算"></a>关于离散型和连续型的计算</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241420968.png"></p><h4 id="常用计算公式"><a href="#常用计算公式" class="headerlink" title="常用计算公式"></a>常用计算公式</h4><p>$$D(X) &#x3D; E(X^2) - [E(X)]^2$$</p><h4 id="方差的性质"><a href="#方差的性质" class="headerlink" title="方差的性质"></a>方差的性质</h4><ul><li><p>$E(c) &#x3D; c, D(c) &#x3D; 0$</p></li><li><p>$E(cX) &#x3D; cE(X), D(cX) &#x3D; c^2D(X)$</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241421030.png"></p></li><li><p>$D(X)&#x3D;0\iff P{X&#x3D;E(X)}&#x3D;1$</p></li></ul><h4 id="Chebyshev不等式"><a href="#Chebyshev不等式" class="headerlink" title="Chebyshev不等式"></a>Chebyshev不等式</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241421067.png"></p><ul><li>证明倒很简单,就一个简单的放缩</li></ul><h4 id="随机变量X的标准化变形"><a href="#随机变量X的标准化变形" class="headerlink" title="随机变量X的标准化变形"></a>随机变量X的标准化变形</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241421749.png"></p><hr><h5 id="必考补充定理"><a href="#必考补充定理" class="headerlink" title="必考补充定理"></a>必考补充定理</h5><p>设$X~N(0,\sigma^2)$ , 则$E[X^n]&#x3D;(n-1)!!\sigma^n$ 当n为偶数</p><p>注:</p><ul><li>n为奇数时,结果是0</li><li>双阶乘是隔一个相乘</li></ul><p><strong>证明:</strong></p><p>令</p><p>$$I(n) &#x3D; E[X^n] &#x3D; \int_{-\infty}^{+\infty} x^n \frac{1}{\sqrt{2\pi}\sigma }e^{-\frac{x^2}{2\sigma ^2}}dx$$</p><ul><li>n为奇数时,该函数为奇函数在对称区间上的积分,为0</li><li>n为偶数时,可以利用分布积分得到一个递推式,最终得到结论</li></ul><hr><p>关于正态分布:</p><ul><li><p>若X是n维非退化(|C_x|!&#x3D;0)则Y<strong>不可能</strong>是m维非退化正态分布(m&#x3D;n+1)</p></li><li><p>当m&lt;&#x3D;n时,Y是非退化(r(k)&#x3D;m)那么</p><ul><li>非退化正态随机变量的行满秩线性变换为非退化正态分布</li></ul></li></ul><hr><h3 id="case2-协方差-相关系数与矩"><a href="#case2-协方差-相关系数与矩" class="headerlink" title="case2 协方差,相关系数与矩"></a>case2 协方差,相关系数与矩</h3><p>协方差</p><p>协方差,相关系数就是描述随机变量之间相互关系的数字特征</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241424102.png"></p><h4 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h4><p>若$E{[X-E(X)][Y-E(Y)]}$存在,称:</p><p>$$Cov(X,Y) &#x3D; E{[X-E(X)][Y-E(Y)]}$$</p><p>为X,Y的协方差</p><p><em><strong>特别的</strong></em></p><p>有$D(X) &#x3D; Cov(X,X)$</p><p>$D(X\pm Y) &#x3D; D(X) + D(Y)\pm2Cov(X,Y)$</p><p><strong>计算公式</strong></p><p>$$Cov(X,Y) &#x3D; E(XY)-E(X)E(Y)$$</p><p><strong>协方差的性质</strong></p><ul><li>$Cov(X,Y) &#x3D; Cov(Y,X)$</li><li>$Cov(aX,bY) &#x3D; abCov(X,Y)$</li><li>$Cov(X_1+X_2,Y) &#x3D; Cov(X_1,Y) + Cov(X_2,Y)$</li></ul><hr><p>相关系数是衡量两个随机变量之间_线性相关程度_的数字特征</p><ul><li>相关系数是衡量两个随机变量之间<strong>线性相关程度</strong>的数字特征</li><li>$\rho_{XY}&#x3D;0$仅说明X,Y之间没有线性关系,但是可以有其他非线性关系</li></ul><p>$设二维随机变量X,Y的D(X)&gt;0,D(Y)&gt;0,称$</p><p>$$\rho_{XY} &#x3D; \frac{Cov(X,Y)}{\sqrt{D(X)} \sqrt{D(Y)}}$$</p><p>为随机变量X与Y的<strong>相关系数</strong></p><p><strong>注:</strong></p><ul><li>$\rho_{XY}$是一个无量纲的量</li><li>$\rho_{XY}&#x3D;E[\frac{X-E(X)}{\sqrt{D(X)}}\frac{Y-E(Y)}{\sqrt{D(Y)}}]&#x3D;E[X^{∗}Y^{∗}]&#x3D;Cov(X^{∗},Y^{∗})$</li></ul><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul><li><p>设随机变量X,Y的相关系数$\rho$存在,则:</p><ul><li><p>$|\rho|\leq1$</p></li><li><p>$|\rho|&#x3D;1\iff X与Y依概率为1线性相关,即$</p><ul><li>存在$\alpha,\beta,(\alpha\neq 0),有P{Y&#x3D;\alpha X+\beta}&#x3D;1$</li></ul></li></ul></li></ul><p><strong>定理</strong>:</p><ul><li><p>若随机变量X与Y相互独立,则X与Y不相关,即有$\rho_{XY}&#x3D;0$</p><ul><li><p>逆定理不成立</p><ul><li><em>但是正态分布中,相互独立和</em>$\rho_{XY}&#x3D;0$<em>是等价的</em></li></ul></li></ul></li></ul><h4 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241424469.png"></p><p>性质:</p><ul><li>$c_{ii}&#x3D;D(X_i)i&#x3D;1,2,3,…n;$</li><li>$c_{ij}&#x3D;c_{ji}i,j&#x3D;1,2,…,n;$对称阵</li><li>C是非负定矩阵</li><li>$c_{ij}^2\leq c_{ii}c_{jj}$, $i,j&#x3D;1,2,\ldots,n$</li></ul><h4 id="矩"><a href="#矩" class="headerlink" title="矩"></a>矩</h4><p>定义1:设X为随机变量,若$E(|X|^k)&lt;+\infty$,称</p><p>$$\gamma_k &#x3D; E(X^k)    k &#x3D; 1,2,3…$$</p><p>为X的<em>k阶原点矩</em></p><p>称$\alpha_k&#x3D;E(|X|^k),k&#x3D;1,2,3…..$为X的<em>k阶绝对原点矩</em></p><p>定义2:设X为随机变量,若$E[|X-E(X)|^k]&lt;+\infty$,称</p><p>$$\mu_k &#x3D; E{[X-E(X)]^k}\ k &#x3D;1,2,3…$$</p><p>为X的<em>k阶中心矩</em></p><p>称</p><p>$$\beta_k &#x3D; E[|X-E(X)|^k]  \\ k &#x3D; 1,2,3…$$</p><p>为X的<em>k阶绝对中心矩</em></p><p>然后观察得到结论—-<strong>随机变量的矩是数!</strong></p><hr><h3 id="补充内容-分布函数的收敛"><a href="#补充内容-分布函数的收敛" class="headerlink" title="补充内容 分布函数的收敛"></a>补充内容 分布函数的收敛</h3><p><strong>一.r.v.序列的收敛性(random variable&#x2F;vector)</strong></p><p>[又叫理想中的爱情]</p><p>回顾:$a_n\to a,如a_n&#x3D;\frac{1}{n}a_n\to0(when n\to\infty)$</p><p>$\forall\epsilon&gt;0,\exists N,当n&gt;N时,有|a_n-a|&lt;\epsilon$</p><p>引例1:</p><p>[现实中的爱情]</p><p>设</p><table><thead><tr><th>$X_n$</th><th>0</th><th>n</th></tr></thead><tbody><tr><td></td><td>$1-\frac{1}{n}$</td><td>$\frac{1}{n}$</td></tr></tbody></table><p>那么$|X_n-0|&lt;\epsilon不等价于X_n&#x3D;0$</p><p>但是</p><p>当$X_n\to X$ $X:\Omega\to R$ $X(\omega)&#x3D;x$</p><p>$X_n,X$均定义在$\Omega$上</p><ol><li>若对$\forall\omega\in\Omega:|X_n(\omega)- X(\omega)|&lt;\epsilon$等价于${\omega:|X_n(\omega)-X(\omega)|&lt;\epsilon}&#x3D;\Omega$等价于${|X_n - X|&lt;\epsilon}&#x3D;\Omega$</li></ol><p>称$X_n$处处收敛于$X$,或$X_n$必然收敛于$X$</p><p>证为$X_n\to X(everywhere)或者X_n\to X(sure)$</p><ol><li>若$P{|X_n - X|&lt;\epsilon}&#x3D;1$等价于$P{\lim_{n\to\infty}X_n&#x3D;X}&#x3D;1$</li></ol><p>称$X_n$几乎处处收敛于$X$,或$X_n$几乎必然处处收敛于$X$ 或$X_n$以概率1收敛于$X$</p><p>证为$X_n\to X(almost everwhere)$或$X_n\to X(a.s.)$或$X_n\to X(w.P.1)$</p><p>继续放宽</p><ol><li>若$\lim_{n\to\infty}P{|X_n - X|&lt;\epsilon}&#x3D;1$</li></ol><p>称$X_n$依概率收敛于$X$</p><p>证为$X_n\to X(P)$</p><p>再放宽</p><ol><li>设$X_n,X$的分布函数为$F_n(X),F(X)$</li></ol><p>若$F_n(X)\to F(X)$</p><p>仅在$F(X)$连续点成立</p><p>则称$F_n(X)\to F(X)(函数列的收敛)$或$X_n\to^{L}_{F}X$</p><p>$$<br>处处收敛\to 几乎处处收敛 \to 依概率收敛 \to 依分布收敛<br>$$</p><hr><h2 id="第五章-随机变量序列的极限"><a href="#第五章-随机变量序列的极限" class="headerlink" title="第五章 随机变量序列的极限"></a>第五章 随机变量序列的极限</h2><hr><h3 id="case1-大数-中心极限定理"><a href="#case1-大数-中心极限定理" class="headerlink" title="case1 大数,中心极限定理"></a>case1 大数,中心极限定理</h3><h4 id="大数定理"><a href="#大数定理" class="headerlink" title="大数定理"></a>大数定理</h4><p><strong>二.Markov不等式(马尔可夫不等式)</strong></p><p>$$<br>P{|X| &lt; \epsilon} \geq \frac{E(|X|^k)}{\epsilon^k}<br>$$</p><p>证设$X$密度为$f(x)$</p><p>$$<br>P{|X| &gt; \epsilon} &#x3D; \int_{|X| &gt; \epsilon}f(x)dx \leq \int_{|x| &gt; \epsilon} \frac{|X|^k|}{\epsilon^k}f(x)dx\leq \frac{1}{\epsilon^k} \int_{-\infty}^{+\infty}|X|^kf(x)dx &#x3D; \frac{1}{\epsilon^k}E(|X|^k)<br>$$</p><ul><li><strong>特别的,当k&#x3D;2,令Y&#x3D;X-E(X) ,E{|Y|^2}&#x3D;D(X)存在,有</strong></li></ul><p><strong>切比雪夫不等式</strong></p><p>$$<br>P{|X-E(X)|\geq\epsilon}\leq\frac{D(X)}{\epsilon ^2}<br>$$</p><p>或者</p><p>$$<br>P{|X-E(X)|&lt;\epsilon} \geq 1-\frac{D(X)}{\epsilon ^2}<br>$$</p><h5 id="大数定理-1"><a href="#大数定理-1" class="headerlink" title="大数定理"></a>大数定理</h5><p>设${X_n}$是一个随机变量序列,其数学期望都存在,若对任意的$\epsilon&gt;0$有</p><p>$$<br>\lim_{n\to \infty} P{|\frac{1}{n}\sum_{i&#x3D;1}^{n}X_i - \frac{1}{n} \sum_{i&#x3D;1}^{n}E(X_i)|&lt;\epsilon} &#x3D; 1<br>$$</p><p>称随机变量序列${X_n}$服从大数定理</p><p><strong>注</strong>:</p><ol><li>${X_k}$服从大数定律是指</li></ol><p>$$<br>\frac{1}{n}\sum_{i&#x3D;1}^{n}X_i \stackrel{p}{\longrightarrow} \frac{1}{n}\sum_{i&#x3D;1}^{n}E(X_i)<br>$$</p><ol start="2"><li>服从大数定律即是${X_k}$的前n项算术平均将紧密的聚集在数学期望的附近</li></ol><h4 id="常见的大数定律"><a href="#常见的大数定律" class="headerlink" title="常见的大数定律"></a>常见的大数定律</h4><h5 id="切比雪夫大数定律"><a href="#切比雪夫大数定律" class="headerlink" title="切比雪夫大数定律"></a>切比雪夫大数定律</h5><ul><li><p>设{X_k}是相互独立的随机变量序列,期望方差都存在,则存在常数C,满足</p><p>$$<br>D(X_K)&lt;C \\ k&#x3D;1,2…<br>$$</p></li></ul><p>说明{X_k}服从大数定律</p><h5 id="独立同分布大数定律"><a href="#独立同分布大数定律" class="headerlink" title="独立同分布大数定律"></a>独立同分布大数定律</h5><ul><li>设{X_k}是相互独立且同分布的随机变量序列,且$E(X_k)&#x3D;\mu,D(X_k)&#x3D;\sigma^2,k&#x3D;1,2,3..$,则{X_k}服从大数定律,有:</li></ul><p>$$<br>\lim_{n\to \infty}P{|\frac{1}{n}\sum_{k&#x3D;1}^{n}X_k-\mu|&lt;\epsilon}&#x3D;1<br>$$</p><ul><li>此定理为切比雪夫大数定理的推论</li><li>为实际应用中大量重复测算值得算术平均值作为精确值得计算提供理论依据</li><li>有更一般的结论</li></ul><h5 id="辛钦大数定律"><a href="#辛钦大数定律" class="headerlink" title="辛钦大数定律"></a>辛钦大数定律</h5><ul><li><em><strong>不要求掌握,了解就行</strong></em></li><li>设{X_k}独立同分布,X_k若有有限的数学期望a,则{X_K}服从大数定律</li></ul><h5 id="伯努利-Bernulli-大数定律"><a href="#伯努利-Bernulli-大数定律" class="headerlink" title="伯努利(Bernulli)大数定律"></a>伯努利(Bernulli)大数定律</h5><ul><li>设$\frac{m}{n}$是n次重复独立试验中事件A发生的频率,p是事件A在每次试验中发生的概率,则对$\forall\epsilon&gt;0$,有</li></ul><p>$$<br>\lim_{n\to \infty}P{|\frac{m}{n}-p|&lt;\epsilon } &#x3D; 1<br>$$</p><ul><li>此定理为切比雪夫大数定律的推论之一</li><li>严格的数学形式描述了频率的稳定性</li><li>小概率事件在实际中可以看作不可能事件(买彩票中奖)</li></ul><h4 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h4><p><strong>定义</strong>:依分布收敛</p><p>设随机变量$X,X_1,X_2,…$的分布函数分别为$F(x),F(x_1),…$,若</p><p>$$<br>\lim_{n\to \infty} F_n(x) &#x3D; F(x)<br>$$</p><p>在F(x)的每一个连续点上都成立,则称随机变量序列${X_k},k&#x3D;1,2,…$依分布收敛于X.并记为</p><p>$$<br>X_n \stackrel{L}{\longrightarrow}X<br>$$</p><p><strong>定义</strong>:中心极限定理</p><p>设随机变量$X~N(0,1),{X_k} , k&#x3D;1,2,…$相互独立,且数学期望和方差都存在,若标准化随机变量序列</p><p>$$<br>\frac{\sum_{k&#x3D;1}^{n}X_k-\sum_{k&#x3D;1}^{n}E(X_k)}{\sqrt{\sum_{k&#x3D;1}^{n}D(X_k)}}<br>$$</p><p>依分布收敛于X,则称随机变量序列{X_k},k&#x3D;1,2,3…服从中心极限定理</p><p>注:</p><ul><li>解释了现实中哪些随机变量可以看为服从正态分布</li><li>给出了概率的近似计算公式</li></ul><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241429884.png"></p><h5 id="独立同分布中心极限定理"><a href="#独立同分布中心极限定理" class="headerlink" title="独立同分布中心极限定理"></a>独立同分布中心极限定理</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241429876.png"></p><ul><li><p>产品检验</p><ul><li><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241429470.png"></li></ul></li><li><p>产品测重</p><ul><li><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241430151.png"></li></ul></li></ul><h5 id="棣莫佛-拉普拉斯中心极限定理"><a href="#棣莫佛-拉普拉斯中心极限定理" class="headerlink" title="棣莫佛-拉普拉斯中心极限定理"></a>棣莫佛-拉普拉斯中心极限定理</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241430965.png"></p><ul><li>航船的稳定性</li><li>报亭售报问题</li></ul><hr><h2 id="第六章-数理统计的基本概念"><a href="#第六章-数理统计的基本概念" class="headerlink" title="第六章 数理统计的基本概念"></a>第六章 数理统计的基本概念</h2><h4 id="总体-样本与统计量"><a href="#总体-样本与统计量" class="headerlink" title="总体,样本与统计量"></a>总体,样本与统计量</h4><h5 id="总体与个体"><a href="#总体与个体" class="headerlink" title="总体与个体"></a>总体与个体</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241430001.png"></p><p><strong>总体分布</strong>是指__数量指标__<strong>X</strong>的分布</p><h4 id="样本"><a href="#样本" class="headerlink" title="样本"></a>样本</h4><p>按照__一定规则__从总体中抽取的一部分个体</p><p><strong>是一组随机变量</strong></p><p>$$<br>(X_1,X_2,…,X_n)<br>$$</p><p>满足:</p><ul><li>$X_i$与总体同分布</li><li>$X_1,X_2,…,X_n$相互独立</li></ul><p>以上两点要求的是<strong>简单随机样本</strong>,以后的样本都是这样的样本.</p><p><strong>抽样</strong>:抽取样本的过程</p><p><strong>样本容量</strong>:样本中个体的数目n</p><p>**样本值(样本观测值):**具体观察数值记作$x_1,x_2,…,x_n$</p><h4 id="统计量"><a href="#统计量" class="headerlink" title="统计量"></a>统计量</h4><p>不包含未知参数的样本的函数</p><p>$$<br>T &#x3D; g(X_1,X_2,…,X_n)<br>$$</p><p>对于相应的样本值$(x_1,x_2,…,x_n)$,称</p><p>$$<br>t &#x3D; g(x_1,x_2,…,x_n)<br>$$</p><p>为统计量的<strong>统计值</strong></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241431315.png"></p><hr><h3 id="case1-常用四种统计分布"><a href="#case1-常用四种统计分布" class="headerlink" title="case1 常用四种统计分布"></a>case1 常用四种统计分布</h3><p>标准正态分布</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241431614.png"></p><h4 id="chi-2-卡方-分布"><a href="#chi-2-卡方-分布" class="headerlink" title="$\chi^2$(卡方)分布"></a>$\chi^2$(卡方)分布</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241431539.png"></p><p>上面的两个不用记,当然也记不住,<em><strong><strong>重要的看下面</strong></strong></em></p><h4 id="卡方分布的一个定理"><a href="#卡方分布的一个定理" class="headerlink" title="卡方分布的一个定理"></a>卡方分布的一个定理</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241432078.png"></p><h4 id="卡方分布的三条性质"><a href="#卡方分布的三条性质" class="headerlink" title="卡方分布的三条性质"></a>卡方分布的三条性质</h4><h5 id="性质一-数字特征"><a href="#性质一-数字特征" class="headerlink" title="性质一:数字特征"></a>性质一:数字特征</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241432194.png"></p><h5 id="性质二-可加性"><a href="#性质二-可加性" class="headerlink" title="性质二:可加性"></a>性质二:可加性</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241432179.png"></p><h5 id="性质三-大样本分位数-chi-2-alpha"><a href="#性质三-大样本分位数-chi-2-alpha" class="headerlink" title="性质三:大样本分位数$\chi^2_\alpha$"></a>性质三:大样本分位数$\chi^2_\alpha$</h5><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241432208.png"></p><h4 id="自由度为n的t分布-T-t-n"><a href="#自由度为n的t分布-T-t-n" class="headerlink" title="自由度为n的t分布 T~t(n)"></a>自由度为n的t分布 T~t(n)</h4><p>又名学生氏分布–第一个研究者笔名是Student</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241432594.png"></p><p>服从标准正态分布的随机变量与 &#x2F;符合卡方分布的随机变量自己的自由度的开方 的比值，符合T分布</p><h4 id="F分布-F-F-n1-n2"><a href="#F分布-F-F-n1-n2" class="headerlink" title="F分布  F~F(n1,n2)"></a>F分布  F~F(n1,n2)</h4><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241433363.png"></p><p>两个服从标准正态分布的随机变量除以各自的自由度的商，符合F分布</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241433288.png"></p><hr><h3 id="case2-抽样分布"><a href="#case2-抽样分布" class="headerlink" title="case2 抽样分布"></a>case2 抽样分布</h3><p>单正态总体的分布定理</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241433630.png"></p><p>定理1和3不做要求，用到矩阵变化</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241434708.png"></p><hr><h2 id="第七章-参数估计"><a href="#第七章-参数估计" class="headerlink" title="第七章 参数估计"></a>第七章 参数估计</h2><p>定义: <strong>参数估计</strong>是对已知分布类型的总体,利用样本对其未知参数做出估计</p><p>参数估计</p><ul><li><p>参数估计</p><ul><li><p>点估计</p><ul><li>矩估计</li><li>极大似然估计</li></ul></li><li><p>区间估计</p></li></ul></li></ul><h4 id="矩估计思路过程"><a href="#矩估计思路过程" class="headerlink" title="矩估计思路过程"></a>矩估计思路过程</h4><table><thead><tr><th>$X\sim P(\lambda)$</th><th>比如泊松分布</th></tr></thead><tbody><tr><td>$\lambda$未知</td><td>条件:样本X1,X2,…,Xn</td></tr><tr><td>建立</td><td>$\hat\lambda&#x3D;h(x_1,x_2,…,x_n)$</td></tr><tr><td>建立</td><td>未知参数与样本的某个方程</td></tr><tr><td>如果建立方程(组)</td><td>依据是什么?</td></tr><tr><td>$(x_1,x_2,…,x_n)$独立同分布</td><td>联想大数定律</td></tr><tr><td>$\frac{1}{n}\sum_{i&#x3D;1}^{n}x_i^k\to{p}E(x^k)$ 依照概率p</td><td></td></tr></tbody></table><p>如果题目中没有样本,需要加上这句话:</p><ul><li>设$x_1,..,x_n$是来自总体X的样本</li></ul><p>令,…..</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241434441.png"></p><h4 id="极大似然估计-M-L-E"><a href="#极大似然估计-M-L-E" class="headerlink" title="极大似然估计(M.L.E.)"></a>极大似然估计(M.L.E.)</h4><p>maximum likelihood estimation</p><p>按最大可能性准则推断小概率事件原理</p><p>做一次试验,事件A发生了,由小概率事件原理,$P(A) &#x3D; L(\theta)$不应该小;</p><p>现确定$P(A)$,由最大可能性准则,令$P(A) &#x3D; maxL(\theta)$等价的,令$\theta$为$L(\theta)$的最大值点</p><p>一般的,$A&#x3D; (X_1 &#x3D; x_1, …,X_n &#x3D; x_n)$</p><ul><li>离散型总体分布</li></ul><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241435823.png"></p><ul><li>连续型总体分布</li></ul><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241435676.png"></p><hr><h3 id="case1-估计量的优良性准则"><a href="#case1-估计量的优良性准则" class="headerlink" title="case1 估计量的优良性准则"></a>case1 估计量的优良性准则</h3><p>无偏性</p><p>有效性</p><p>相合性</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241435907.png"></p><hr><h3 id="case2-置信区间"><a href="#case2-置信区间" class="headerlink" title="case2 置信区间"></a>case2 置信区间</h3><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241436835.png"></p><p>一个例子搞定7，3和第八章</p><p>这个方法叫做–枢轴变量法</p><p>因为$\mu$是一个数（总体矩是个数），没办法求概率</p><p>所以找X的算数平均值来曲线救国，最后对X的算数平均数进行标准化变形时，里面就有$\mu$</p><p>单正态总体四个问题</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241437168.png"></p><hr><h2 id="第八章-假设检验"><a href="#第八章-假设检验" class="headerlink" title="第八章 假设检验"></a>第八章 假设检验</h2><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241437791.png"></p><hr><h2 id="第九章-回归分析"><a href="#第九章-回归分析" class="headerlink" title="第九章 回归分析"></a>第九章 回归分析</h2><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/picgoimgbed/202212241438266.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> Course </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论与数理统计 </tag>
            
            <tag> 大二上 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Verilog学习笔记:基础语法与代码规范总结</title>
      <link href="/article/7045141b.html"/>
      <url>/article/7045141b.html</url>
      
        <content type="html"><![CDATA[<h2 id="Verilog基本代码规范"><a href="#Verilog基本代码规范" class="headerlink" title="Verilog基本代码规范"></a>Verilog基本代码规范</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><ul><li>推荐使用<strong>驼峰命名法</strong></li><li>注释规则与C语言类似</li><li>标识符和关键字命名同C语言</li></ul><h3 id="数值表示"><a href="#数值表示" class="headerlink" title="数值表示"></a>数值表示</h3><p>共有4种方法表示数字逻辑电平:</p><ol><li>0: 低电平</li><li>1: 高电平</li><li>x: 未知电平</li><li>z: 高阻状态</li></ol><p>数值声明中可以使用4种进制:</p><ul><li>十进制 (<code>&#39;d</code>或<code>&#39;D</code>)</li><li>十六进制 (<code>&#39;h</code>或<code>&#39;H</code>)</li><li>二进制 (<code>&#39;b</code>或<code>&#39;B</code>)</li><li>八进制 (<code>&#39;o</code>或<code>&#39;O</code>)</li></ul><p>可以指定数值位宽,也可以不指定。例如:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token number">32</span> <span class="token number">'h3022_c0de</span> <span class="token comment">// 32位十六进制数</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>使用双引号包裹字符串。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>两种主要数据类型:<strong>线网</strong>(wire)和<strong>寄存器</strong>(reg)。</p><h4 id="线网-wire"><a href="#线网-wire" class="headerlink" title="线网(wire)"></a>线网(wire)</h4><p>用于表示硬件逻辑之间的物理连线,例如:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> flag1<span class="token punctuation">,</span> flag2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="寄存器-reg"><a href="#寄存器-reg" class="headerlink" title="寄存器(reg)"></a>寄存器(reg)</h4><p>用于保持数据值,直到被重写。例如:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> flag1<span class="token punctuation">,</span> flag2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="向量-Vector"><a href="#向量-Vector" class="headerlink" title="向量(Vector)"></a>向量(Vector)</h4><p>当位宽大于1时使用,wire和reg都可以声明为向量。类似编程语言中的数组。</p><p>例如:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> gpio_data<span class="token punctuation">;</span> <span class="token comment">// 声明32位线网变量gpio_data</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="其他数据类型"><a href="#其他数据类型" class="headerlink" title="其他数据类型"></a>其他数据类型</h3><ul><li><strong>整数</strong>(integer): 一般32位,直接使用<code>integer</code>声明</li><li><strong>实数</strong>(real): 默认值为0</li><li><strong>时间</strong>(time): 用于保存仿真时间,一般为64位。通过<code>$time</code>系统函数获取</li><li><strong>数组</strong>: 可以声明reg、wire、integer、time、real和向量等类型的数组</li></ul><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span>  data_bit<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 声明二维1位wire数组</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="存储器和字符串"><a href="#存储器和字符串" class="headerlink" title="存储器和字符串"></a>存储器和字符串</h3><h4 id="存储器-Memory"><a href="#存储器-Memory" class="headerlink" title="存储器(Memory)"></a>存储器(Memory)</h4><p>Verilog中可以声明存储器,用于保存大量数据。存储器需要定义存储器类型、宽度和深度。</p><p>例如:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> ram<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">255</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 8位宽,256深度的寄存器型存储器</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>读取存储器使用中括号访问,写入使用赋值语句。</p><h4 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h4><p>Verilog没有专门的字符串类型,可以使用reg或wire向量来表示字符串。</p><p>例如:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> str <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 16个8位寄存器组成的字符串</span>str <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span> <span class="token comment">// 初始化字符串</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Verilog速通代码示例"><a href="#Verilog速通代码示例" class="headerlink" title="Verilog速通代码示例"></a>Verilog速通代码示例</h2><h3 id="基本组成单元-模块-module"><a href="#基本组成单元-模块-module" class="headerlink" title="基本组成单元 - 模块(module)"></a>基本组成单元 - 模块(module)</h3><p>一般形式:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> 模块名<span class="token punctuation">(</span>接口信号<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 信号声明</span><span class="token comment">// 功能描述</span><span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意:</p><ul><li>模块名要有意义</li><li>一个.v文件中只能有一个模块</li></ul><h3 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h3><p>常用的四种数据类型:</p><ul><li>reg:寄存器</li><li>wire:线网</li><li>parameter:参数</li><li>integer:整数</li></ul><h3 id="数值表示-1"><a href="#数值表示-1" class="headerlink" title="数值表示"></a>数值表示</h3><p>格式为:<code>&lt;位宽&gt;&lt;类型&gt;&lt;数值&gt;</code></p><p>例如:<code>8&#39;b1100_0010</code></p><h3 id="参数-parameter"><a href="#参数-parameter" class="headerlink" title="参数(parameter)"></a>参数(parameter)</h3><p>使用<code>parameter</code>定义常量。例如:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">parameter</span> SIZE <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>define</code>定义的宏可以跨模块使用,<code>localparam</code>仅在模块内可用。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>wire<ul><li>用于模块间输入输出信号,电路连线</li><li>例如:<code>wire [7:0] a;</code></li><li>使用<code>assign</code>进行连续赋值(阻塞赋值)</li></ul></li><li>reg<ul><li>代表寄存器</li><li>必须在<code>always</code>块中使用,赋值需用非阻塞”<code>&lt;=</code>“</li><li>例如:<code>reg [7:0] a;</code></li></ul></li></ul><p>运算符和C语言类似,这里不再赘述。</p><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><ul><li>非阻塞赋值(如<code>b &lt;= a;</code>):在块结束时才赋值</li><li>阻塞赋值(如<code>b = a;</code>):立即赋值</li></ul><p>规范:</p><ol><li>always块中使用非阻塞赋值</li><li>assign中使用阻塞赋值</li></ol><h3 id="块语句"><a href="#块语句" class="headerlink" title="块语句"></a>块语句</h3><ul><li>顺序块:顺序执行语句</li><li>并行块:同时执行语句</li></ul><p>示例:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">// 顺序块</span><span class="token keyword">begin</span>  语句<span class="token number">1</span><span class="token punctuation">;</span>  语句<span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token comment">// 并行块</span><span class="token keyword">fork</span>  语句<span class="token number">1</span><span class="token punctuation">;</span>  语句<span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条件和循环语句"><a href="#条件和循环语句" class="headerlink" title="条件和循环语句"></a>条件和循环语句</h3><ul><li>if…else语句、case语句</li><li>for循环语句</li></ul><h3 id="always块"><a href="#always块" class="headerlink" title="always块"></a>always块</h3><p>在仿真中持续重复执行的语句块。</p><p>格式:<code>always @(控制信号) 语句</code></p><p>例如:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clock <span class="token keyword">or</span> <span class="token keyword">posedge</span> reset<span class="token punctuation">)</span> <span class="token comment">// 时序逻辑</span><span class="token important">always @</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token comment">// 组合逻辑</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>按位运算符</strong></p><p>Verilog中包含以下按位运算符:</p><ul><li>取反:~</li><li>与:&amp;</li><li>或:|</li><li>异或:^</li><li>同或:~^</li></ul><p>这些运算符对两个操作数的每1位进行逐位运算。</p><p>如果两个操作数位数不等,则用0在短操作数左侧进行填充。</p><h3 id="连续赋值-Continuous-Assignment"><a href="#连续赋值-Continuous-Assignment" class="headerlink" title="连续赋值(Continuous Assignment)"></a>连续赋值(Continuous Assignment)</h3><p>用于对wire类型变量进行赋值。格式如下:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">assign</span> <span class="token operator">&lt;</span>目标变量<span class="token operator">></span> <span class="token operator">=</span> <span class="token operator">&lt;</span>表达式<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> Cout<span class="token punctuation">,</span> A<span class="token punctuation">,</span> B<span class="token punctuation">;</span><span class="token keyword">assign</span> Cout <span class="token operator">=</span> A <span class="token operator">&amp;</span> B<span class="token punctuation">;</span> <span class="token comment">// 实现A与B的按位与运算</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="门电路实现"><a href="#门电路实现" class="headerlink" title="门电路实现"></a>门电路实现</h3><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202307291900655.png"></p><h2 id="《Verilog简明教程》读书笔记"><a href="#《Verilog简明教程》读书笔记" class="headerlink" title="《Verilog简明教程》读书笔记"></a>《Verilog简明教程》读书笔记</h2><ul><li>模块之间并行执行</li><li><code>parameter</code>声明常量</li><li><code>testbench</code>是编写模块的高层测试模块</li><li><code>&#39;timescale</code>定义时间单位和精度</li><li>数值表示:<code>5&#39;O37</code> <code>4&#39;D2</code></li><li><code>wire</code>:<ul><li>声明:<code>wire [2:0] Start</code></li><li>赋值使用<code>assign</code>语句,例如<code>assign Start = Blt;</code></li><li>连续赋值,用于驱动wire变量</li></ul></li><li><code>reg</code>:<ul><li>只能在<code>initial</code>和<code>always</code>块中赋值</li><li><code>initial</code>只在开始时执行一次</li><li><code>always</code>可反复执行</li><li>时序控制,例如:<code>always #5 Clk=~Clk</code></li><li>事件触发,例如:<code>always @(posedge Clock)</code></li></ul></li><li>寄存器和存储器:<ul><li><code>reg [3:0] Sat;</code></li><li><code>reg [3:0] Mem [63:0]</code></li><li><code>reg Bog [1:5];</code></li></ul></li><li><code>reg</code>不能用<code>assign</code>赋值</li><li><code>#3</code>暂停3个时间单位</li><li><code>forever</code>实现永久循环</li></ul><p>模块实例化示例:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token function">Gang3</span><span class="token punctuation">(</span>Out<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>InA<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>InB<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Gang3</span><span class="token punctuation">(</span>Out<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>InA<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>InB<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>等价于:</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> Out<span class="token punctuation">,</span>InA<span class="token punctuation">,</span>InB<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>关于模块的替换工作可以在书吴戈的&lt;verilog简明教程&gt;中的测试单元里找到相应的模块</li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程学习 </tag>
            
            <tag> 基础语法 </tag>
            
            <tag> Verilog </tag>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> CPU </tag>
            
            <tag> Vivado </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSI v.s. TCP/IP：网络模型和协议的比较</title>
      <link href="/article/d3f72afd.html"/>
      <url>/article/d3f72afd.html</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络协议有什么用"><a href="#计算机网络协议有什么用" class="headerlink" title="计算机网络协议有什么用?"></a>计算机网络协议有什么用?</h2><p>计算机联网为了通信,就像人与人直接需要一个统一的交流标准(English),因此ARPA公司推出了著名的TCP&#x2F;IP标准网络协议。</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202307291900647.png"></p><h2 id="什么是OSI-什么又是TCP-x2F-IP"><a href="#什么是OSI-什么又是TCP-x2F-IP" class="headerlink" title="什么是OSI,什么又是TCP&#x2F;IP?"></a><strong>什么是OSI,什么又是TCP&#x2F;IP?</strong></h2><p>为了方便设计,更符合理性,因此引入网络层次划分</p><p>国际标准化组织（ISO）在1978年提出了”开放系统互联参考模型”，即著名的OSI&#x2F;RM模型（Open System Interconnection&#x2F;Reference Model）。</p><p>一共七个层次,除了OSI七层模型,常见的网络层次划分还有TCP&#x2F;IP四层和五层协议,它们之间的关系如图所示:</p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202307291900631.png"></p><h3 id="1-物理层-Physical-Layer"><a href="#1-物理层-Physical-Layer" class="headerlink" title="1. 物理层(Physical Layer)"></a>1. 物理层(Physical Layer)</h3><p>该层是最底层,为上层协议提供了一个数据传输可靠的物理媒体,确保原始数据在各种物理媒体上的传输。</p><h4 id="两个关键设备"><a href="#两个关键设备" class="headerlink" title="两个关键设备"></a>两个关键设备</h4><ul><li>中继器(Repeater,也叫放大器)</li><li>集线器</li></ul><h3 id="2-数据链路层-Data-Link-Layer"><a href="#2-数据链路层-Data-Link-Layer" class="headerlink" title="2. 数据链路层(Data Link Layer)"></a>2. 数据链路层(Data Link Layer)</h3><p>在物理层的基础上向网络层提供服务,**基本服务是将源于网络层的数据可靠的传输到相邻节点的目标机网络层(说人话就是为网络层提供可靠的数据传输)**。</p><h4 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h4><ul><li>将数据组合成数据块(数据块基本单位叫做<strong>帧(Frame)</strong>)</li><li>为物理的链路提供了硬件或软件的协议支持,构成数据链路</li><li>物理地址寻址,数据组合成数据块(成帧)</li><li>数据检索重发</li></ul><h4 id="主要协议"><a href="#主要协议" class="headerlink" title="主要协议"></a>主要协议</h4><ul><li><strong>以太网协议(网卡工作)</strong></li></ul><h4 id="两个重要设备"><a href="#两个重要设备" class="headerlink" title="两个重要设备"></a>两个重要设备</h4><ul><li>网桥</li><li>交换机</li></ul><h3 id="3-网络层-Network-Layer"><a href="#3-网络层-Network-Layer" class="headerlink" title="3. 网络层(Network Layer)"></a>3. 网络层(Network Layer)</h3><p><em>注意:实现端到端之间的数据透明传送</em></p><h4 id="网络层功能"><a href="#网络层功能" class="headerlink" title="网络层功能"></a>网络层功能</h4><ul><li>寻址,路由选择,连接建立,保持,中止等</li></ul><h4 id="重要协议"><a href="#重要协议" class="headerlink" title="重要协议"></a>重要协议</h4><ul><li><strong>IP协议,ICMP协议,ARP协议,RARP协议</strong></li></ul><h4 id="补充IP协议功能"><a href="#补充IP协议功能" class="headerlink" title="补充IP协议功能"></a>补充IP协议功能</h4><ul><li>无连接数据报传输,数据包路由选择和差错控制</li><li>因特网组管理协议IGMP</li><li>重点是无连接</li></ul><h4 id="网络层具体功能"><a href="#网络层具体功能" class="headerlink" title="网络层具体功能"></a>网络层具体功能</h4><ul><li>对子网间数据包进行路由选择,拥塞控制,网际互连等(根据网络地址将源节点发出的数据包传送到目的结点)</li><li>基本数据单位:IP数据报</li></ul><h4 id="重要设备"><a href="#重要设备" class="headerlink" title="重要设备"></a>重要设备</h4><ul><li>路由器</li></ul><h3 id="4-传输层-Transport-Layer"><a href="#4-传输层-Transport-Layer" class="headerlink" title="4. 传输层(Transport Layer)"></a>4. 传输层(Transport Layer)</h3><ul><li>第一个实现<strong>端到端</strong>也就是主机到主机层次通信的层</li><li>将上层的数据分段并提供端到端的,可靠或者不可靠的传输。端到端的差错控制和流量控制问题。</li></ul><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>根据通信子网的特性,最佳利用网络资源,为两个端系统的会话层之间,提供建立,维护和取消传输连接的功能。(将数据可靠的传送到相应的端口)</li></ul><h4 id="基本数据单位"><a href="#基本数据单位" class="headerlink" title="基本数据单位"></a>基本数据单位</h4><ul><li>段 或者 报文</li></ul><h4 id="重要协议-1"><a href="#重要协议-1" class="headerlink" title="重要协议"></a>重要协议</h4><ul><li>TCP(Transmission Control Protocol,传输控制协议)</li><li>UDP(User Datagram Protocol,用户数据报协议)</li></ul><h4 id="重要设备-1"><a href="#重要设备-1" class="headerlink" title="重要设备"></a>重要设备</h4><ul><li>网关</li></ul><h3 id="5-会话层"><a href="#5-会话层" class="headerlink" title="5. 会话层"></a>5. 会话层</h3><p>管理主机之间的会话进程,建立,管理,终止进程之间的会话,数据的同步等等。</p><h3 id="6-表示层"><a href="#6-表示层" class="headerlink" title="6. 表示层"></a>6. 表示层</h3><p>让一个主机上的应用层信息可以被另一个主机上的应用程序理解,数据转换包括数据加密,压缩,格式转换等。</p><h3 id="7-应用层"><a href="#7-应用层" class="headerlink" title="7. 应用层"></a>7. 应用层</h3><p>为操作系统或网络应用程序提供网络服务的接口。</p><h4 id="会话层、表示层、应用层重点"><a href="#会话层、表示层、应用层重点" class="headerlink" title="会话层、表示层、应用层重点"></a>会话层、表示层、应用层重点</h4><ul><li>数据传输基本单位为:报文</li><li>主要协议:<ul><li>FTP(文件传送协议)</li><li>Telnet(远程登录协议)</li><li>DNS</li><li>SMTP(简单邮件传送协议)</li><li>POP3(邮局协议)</li><li>HTTP协议</li></ul></li></ul><h3 id="OSI模型与TCP-x2F-IP协议族比较"><a href="#OSI模型与TCP-x2F-IP协议族比较" class="headerlink" title="OSI模型与TCP&#x2F;IP协议族比较"></a>OSI模型与TCP&#x2F;IP协议族比较</h3><p><strong>OSI模型不适合软件实现,而TCP&#x2F;IP协议族适合,请解释?</strong></p><h3 id="关于上次问题的答案"><a href="#关于上次问题的答案" class="headerlink" title="关于上次问题的答案"></a>关于上次问题的答案</h3><blockquote><p>Q:现在电脑怎么访问公网</p></blockquote><p>A:<br>由于现在IP v4地址匮乏,所以现在拨号光纤默认分配私网地址,现在电脑上网ip是从运营商那里得到一个动态的ip地址(大内网时代,一个小ip池有3-5个ip分配),如果硬要一个公网ip也可以给运营商打电话说装监控需要一个公网ip,客服分配了公网ip后可以方便自家电脑通过DDNS映射到公网上,这样就可以远程访问了.但是这个账号每次PPOE拨号以后会重新分配ip地址,所以需要DDNS.<br>如果想要自己搭建一个网站映射到公网上,这个可行性不高,因为一.带宽不足,二.公网ip不固定,三.需要身份验证才能用http隧道.如果联系ISP网络服务提供商的话,带宽费用大概是50M一年一万多.<br>其实私网ip有利于保护个人电脑信息安全,如果暴露到公网上,容易被攻击</p><h3 id="新名词"><a href="#新名词" class="headerlink" title="新名词"></a>新名词</h3><p>DHCP(Dynamic Host Configuration Protocol)动态主机配置协议,服务器给客户机自动分配ip地址和子网掩码<br>子网掩码:为了解决IP v4地址不足诞生的虚拟ip技术,需要结合IP地址一起使用,方便辨别局域网和广域网ip,是个32位地址,还可以把一个大的IP网络划分成小的子网络<br>端口转发:将一个IP的端口和另一个ip的端口对应起来<br>静态ARP绑定:将内网的机器MAC地址与对应的IP固定起来<br>MAC地址(Media Access Control Address)又称物理地址,以太网地址,局域网地址,是一个确定网络设备位置的地址,MAC地址必须具备唯一性,一般被硬件厂商生产时就固化在硬件里,因为厂商不同,所以格式不一.<br>DDNS,先要了解DNS(Domain name Server,域名解析服务,作用:域名解析成ip),而DDNS多的那个”D”就是”Dynamic”,动态的,我们访问”<a href="http://www.baidu.com" 时,ping的域名返回的是ip,由于dhcp的存在,我们的ip会不断变化,因此要动态解析,所以就有了. ">www.baidu.com&quot;时,ping的域名返回的是IP,由于DHCP的存在,我们的IP会不断变化,因此要动态解析,所以就有了。</a></p><h3 id="还有很多值得说的"><a href="#还有很多值得说的" class="headerlink" title="还有很多值得说的:"></a>还有很多值得说的:</h3><ul><li>IP地址</li><li>子网掩码及网络划分 </li><li>ARP&#x2F;RARP协议</li><li>TCP&#x2F;IP协议(其中包括三次握手四次挥手,报文格式组成)</li><li>UDP协议</li><li>最后欠缺一个例子,连接网站的示例</li><li>NAT网络地址转换</li><li>路由器的工作原理 </li><li>开放系统互联模型与TCP&#x2F;IP协议的比较</li><li>TCP的拥塞控制 </li><li>计算机网络安全问题</li><li>HTTP、HTTPS协议详解</li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> OSI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言学习笔记:数据类型、流程控制和其他基础</title>
      <link href="/article/ada7eeb.html"/>
      <url>/article/ada7eeb.html</url>
      
        <content type="html"><![CDATA[<h2 id="Go语言变量声明"><a href="#Go语言变量声明" class="headerlink" title="Go语言变量声明"></a>Go语言变量声明</h2><h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token number">1</span> <span class="token keyword">package</span> main<span class="token number">2</span><span class="token number">3</span> <span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token number">4</span><span class="token number">5</span> <span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token number">6</span>     <span class="token keyword">var</span> a <span class="token builtin">int</span><span class="token number">7</span>     a <span class="token operator">=</span> <span class="token number">1</span><span class="token number">8</span>     fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token number">9</span><span class="token number">10</span>    f <span class="token operator">:=</span> <span class="token string">"Runoob"</span><span class="token number">11</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token number">12</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>:=</code> 这种写法非常省事,但是只能在函数内使用,一般用于for循环中声明循环条件。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> <span class="token punctuation">(</span>   age <span class="token builtin">int</span>   isOK <span class="token builtin">bool</span>   myName <span class="token builtin">string</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种因式分解关键字的写法一般用于声明全局变量,非常推荐全局变量这样声明,方便追加。</p><p>如果你想要交换两个变量的值,则可以简单地使用 <code>a, b = b, a</code>,两个变量的类型必须相同,应该类似于tuple交换了一下。</p><p>空白标识符 <code>_</code> 也叫做匿名变量,被用于抛弃值,如值 5 在 <code>_, b = 5, 7</code> 中被抛弃(原理就是占位符的作用,不分配内存,所以可以反复声明匿名变量)。</p><p>如果你声明了一个局部变量却没有在相同的代码块中使用它,同样会得到编译错误,但是全局变量就可以声明而不使用。</p><p>Go中用双引号<code>&quot; &quot;</code>来表明字符串,用单引号<code>&#39; &#39;</code>来表明单个字符(数字字符号字母汉字)。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">s1 <span class="token operator">:=</span> <span class="token char">'1'</span>s2 <span class="token operator">:=</span> <span class="token char">'我'</span>s3 <span class="token operator">:=</span> <span class="token char">'s'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>&#x2F;&#x2F; 字节:1个字节&#x3D;8Bit(8个二进制位)</p><p>&#x2F;&#x2F; 一个字符’A’ &#x3D; 1个字节</p><p>&#x2F;&#x2F; 一个utf8编码的汉字一般占3个字节 (比如‘沙’)</p><p><a href="https://www.runoob.com/go/go-variables.html">学习一个</a></p><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p>Go语言中有3种格式化输出的方法:<code>fmt.Println</code>、<code>fmt.Print</code> 和 <code>fmt.Printf</code>。</p><ul><li><code>fmt.Println</code>会在输出内容的后面添加一个换行符</li><li><code>fmt.Print</code>只是简单的输出内容,不会添加任何字符</li><li><code>fmt.Printf</code>可以格式化输出,类似C语言中的printf</li></ul><h3 id="fmt-Printf格式化占位符"><a href="#fmt-Printf格式化占位符" class="headerlink" title="fmt.Printf格式化占位符"></a>fmt.Printf格式化占位符</h3><p><code>fmt.Printf</code>使用 <code>%</code>加上一个字母作为占位符,使用变量的值替换占位符实现格式化输出。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">name <span class="token operator">:=</span> <span class="token string">"Runoob"</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"name:%s\\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token comment">// %s是一个占位符,使用name变量的值替换占位符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>常用占位符:</p><ul><li>%v 原样输出变量的值</li><li>%T 输出变量的类型</li><li>%s 输出字符串</li><li>%d 输出十进制整数</li><li>%b 输出二进制整数</li><li>%o 输出八进制整数</li><li>%x 输出十六进制整数</li><li>%f 输出浮点数</li><li>%t 输出true或false</li></ul><h3 id="var与const的区别"><a href="#var与const的区别" class="headerlink" title="var与const的区别"></a>var与const的区别</h3><ul><li>var声明的变量可以在程序运行时修改</li><li>const声明的是常量,在程序运行时不能修改</li></ul><h3 id="伪随机数的使用"><a href="#伪随机数的使用" class="headerlink" title="伪随机数的使用"></a>伪随机数的使用</h3><p>Go语言中的math&#x2F;rand包实现了伪随机数生成器。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"math/rand"</span><span class="token comment">// 随机种子</span>rand<span class="token punctuation">.</span><span class="token function">Seed</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">UnixNano</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 生成随机数</span>rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用rand.Seed()函数设置随机数种子,可以产生不同的随机数序列。</p><h2 id="if-else-和-switch"><a href="#if-else-和-switch" class="headerlink" title="if else 和 switch"></a>if else 和 switch</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h3><p>Go语言中的if else语句与其他语言类似:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> condition <span class="token punctuation">&#123;</span>    <span class="token comment">// if代码块</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// else代码块</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>if语句可以在条件表达式前加上一个执行语句,再根据变量值进行判断:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> a <span class="token operator">:=</span> <span class="token number">10</span><span class="token punctuation">;</span> a <span class="token operator">></span> <span class="token number">5</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// if代码块</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>if还可以写成一行:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> a <span class="token operator">></span> <span class="token number">5</span> <span class="token punctuation">&#123;</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"a大于5"</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch语句会将表达式的值与case语句进行匹配,匹配成功则执行该case语句块:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">switch</span> expression <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> value1<span class="token punctuation">:</span>       <span class="token comment">//语句</span>    <span class="token keyword">case</span> value2<span class="token punctuation">:</span>       <span class="token comment">//语句</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>       <span class="token comment">//默认语句</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>switch同样支持多表达式判断:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">switch</span> age <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">:</span>       fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"年轻人"</span><span class="token punctuation">)</span>    <span class="token keyword">case</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">:</span>       fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"中年人"</span><span class="token punctuation">)</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>       fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"老年人"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Slice和Map"><a href="#Slice和Map" class="headerlink" title="Slice和Map"></a>Slice和Map</h2><h3 id="Slice-切片"><a href="#Slice-切片" class="headerlink" title="Slice(切片)"></a>Slice(切片)</h3><p>切片(Slice)是对数组的抽象,对数组进行切片操作生成切片。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 声明切片</span><span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>a <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">// 简化声明</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切片可以进行追加操作,向切片追加新的元素:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Map-字典"><a href="#Map-字典" class="headerlink" title="Map(字典)"></a>Map(字典)</h3><p>Map是一种无序的键值对集合,也称作关联数组或者字典。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 声明 map</span><span class="token keyword">var</span> b <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span>b <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token comment">// 简化声明</span>b <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"zhangsan"</span><span class="token punctuation">,</span> <span class="token string">"gender"</span><span class="token punctuation">:</span> <span class="token string">"female"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>向字典增加键值对:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">b<span class="token punctuation">[</span><span class="token string">"age"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"20"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从字典查询值:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">value <span class="token operator">:=</span> b<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202307291900623.png"></p><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202307291900576.png"></p><h2 id="指针-Pointer"><a href="#指针-Pointer" class="headerlink" title="指针(Pointer)"></a>指针(Pointer)</h2><p>Go语言中的指针与C语言类似,用于存储变量的内存地址。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> p <span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">8</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>变量p存储了a的内存地址,可以通过<code>*p</code>来获取指针指向的变量。</p><p>对指针指向的变量进行操作如<code>(*p)[1] = 8</code>,会影响变量a的值。</p><p>字典也可以取地址操作:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"zhangsan"</span><span class="token punctuation">,</span> <span class="token string">"gender"</span><span class="token punctuation">:</span> <span class="token string">"female"</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> b <span class="token operator">*</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">(</span><span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"lisi"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>指针是Go语言中很重要的一个特性,正确使用指针可以减少内存拷贝提高程序效率。</p><h2 id="自定义数据类型"><a href="#自定义数据类型" class="headerlink" title="自定义数据类型"></a>自定义数据类型</h2><p>在Go语言中可以使用<code>type</code>关键字定义自定义数据类型。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>  Name <span class="token builtin">string</span>  Age <span class="token builtin">int</span>  Gender <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就创建了一个Person类型,并且有Name、Age、Gender三个字段。</p><p>可以通过<code>.</code>来访问结构体字段:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> a Persona<span class="token punctuation">.</span>Name <span class="token operator">=</span> <span class="token string">"san"</span>a<span class="token punctuation">.</span>Gender <span class="token operator">=</span> <span class="token string">"female"</span>a<span class="token punctuation">.</span>Age <span class="token operator">=</span> <span class="token number">15</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以通过结构体指针来访问:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span>a<span class="token punctuation">.</span>Name <span class="token operator">=</span> <span class="token string">"san"</span>a<span class="token punctuation">.</span>Gender <span class="token operator">=</span> <span class="token string">"female"</span>a<span class="token punctuation">.</span>Age <span class="token operator">=</span> <span class="token number">15</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>new</code>函数会返回一个结构体的指针。</p><p>自定义数据类型是Go语言中很重要的一个特征,可以提高代码复用性和可读性。</p><h2 id="Go语言循环遍历"><a href="#Go语言循环遍历" class="headerlink" title="Go语言循环遍历"></a>Go语言循环遍历</h2><p>Go语言中可以通过for循环遍历数组、切片、字符串、map等。</p><h3 id="遍历map"><a href="#遍历map" class="headerlink" title="遍历map"></a>遍历map</h3><p>使用for range遍历map:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"xiaopan"</span><span class="token punctuation">,</span> <span class="token string">"gender"</span><span class="token punctuation">:</span> <span class="token string">"male"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">:</span> <span class="token string">"20"</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> a <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这会遍历map的键值对。</p><h3 id="遍历切片、数组"><a href="#遍历切片、数组" class="headerlink" title="遍历切片、数组"></a>遍历切片、数组</h3><p>遍历切片和数组只需要值:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"xyz"</span><span class="token punctuation">,</span> <span class="token string">"zzz"</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> a <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以用下标i获取索引:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"xyz"</span><span class="token punctuation">,</span> <span class="token string">"zzz"</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> i<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> a <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Go语言中for range循环可以帮助我们快速遍历数据,非常实用。</p><h2 id="Go语言常用命令简介"><a href="#Go语言常用命令简介" class="headerlink" title="Go语言常用命令简介"></a>Go语言常用命令简介</h2><p>使用Go语言命令行工具前,需要配置好GOPATH等环境变量。</p><ul><li>GOPATH: Go代码、依赖包缓存目录,默认为$HOME&#x2F;go</li><li>GOBIN: go install安装的可执行文件目录,需要在PATH中</li></ul><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul><li>go run: 编译执行Go代码,适用于小程序</li><li>go build: 编译Go代码生成可执行文件</li><li>go install: 编译并安装可执行文件到GOBIN目录</li><li>go get: 下载依赖包(现在被go install替代)</li><li>go vet: 检查代码错误和提示</li><li>go test: 运行测试用例</li></ul><h3 id="模块命令"><a href="#模块命令" class="headerlink" title="模块命令"></a>模块命令</h3><ul><li>go mod init: 初始化模块, 创建go.mod文件</li><li>go mod tidy: 处理依赖关系</li><li>go mod graph: 查看依赖图</li></ul><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><ul><li>go help: 查看命令帮助</li><li>go: 显示所有命令</li></ul><h2 id="Go语言代码风格简介"><a href="#Go语言代码风格简介" class="headerlink" title="Go语言代码风格简介"></a>Go语言代码风格简介</h2><p>Go语言有自己的代码风格规范</p><p>下面是一个示例程序,展示了一些Go语言的代码风格:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"math/rand"</span><span class="token keyword">const</span> MaxRand <span class="token operator">=</span> <span class="token number">16</span><span class="token keyword">func</span> <span class="token function">StatRandomNumbers</span><span class="token punctuation">(</span>numRands <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> a<span class="token punctuation">,</span> b <span class="token builtin">int</span>  <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numRands<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span>MaxRand<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MaxRand<span class="token operator">/</span><span class="token number">2</span> <span class="token punctuation">&#123;</span>      a <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      b<span class="token operator">++</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> a<span class="token punctuation">,</span> b<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">100</span>  x<span class="token punctuation">,</span> y <span class="token operator">:=</span> <span class="token function">StatRandomNumbers</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Result:"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token string">"+"</span><span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token string">"="</span><span class="token punctuation">,</span> num<span class="token punctuation">,</span> <span class="token string">"?"</span><span class="token punctuation">)</span>  <span class="token function">println</span><span class="token punctuation">(</span>x<span class="token operator">+</span>y <span class="token operator">==</span> num<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一些需要注意的规范:</p><ul><li>大括号不能单独一行,必须放在代码块末尾</li><li>使用驼峰命名法命名变量、函数等</li><li>缩进使用空格,不要使用tab</li><li>注释符号&#x2F;&#x2F;和代码间保留一个空格</li></ul><p>Go语言的格式规范可以让代码更简洁规范,也便于阅读和维护。</p><h2 id="Go语言中的关键字和标识符"><a href="#Go语言中的关键字和标识符" class="headerlink" title="Go语言中的关键字和标识符"></a>Go语言中的关键字和标识符</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>Go语言一共有25个关键字:</p><pre class="line-numbers language-none"><code class="language-none">break        default      func         interface    selectcase         defer        go           map          structchan         else         goto         package      switchconst        fallthrough  if           range        typecontinue     for          import       return       var<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些关键字在Go语言中有特殊的含义,不能被自定义使用。</p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符用于命名变量、类型等,命名规则:</p><ul><li>由字母、数字、下划线组成</li><li>不能以数字开头</li><li>区分大小写</li></ul><p><code>_</code> 是特殊的空标识符,用于占位丢弃值。</p><p>标识符根据首字母大小写可分为导出标识符(公有)和非导出标识符(私有):</p><ul><li>大写字母开头的标识符可以被其他包访问(导出)</li><li>小写字母开头的不能被其他包访问(非导出)</li></ul><p>正确使用关键字和标识符可以编写出合理、可读性好的Go语言代码。</p><h2 id="Go语言中的基本类型"><a href="#Go语言中的基本类型" class="headerlink" title="Go语言中的基本类型"></a>Go语言中的基本类型</h2><p>Go语言提供了以下几种基本类型:</p><ul><li>布尔类型:bool</li><li>数字类型:整型、浮点型、复数型</li><li>字符串类型:string</li></ul><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>常用的整型别名:</p><ul><li>byte 别名为 uint8</li><li>rune 别名为 int32</li></ul><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><ul><li>float32 单精度浮点数</li><li>float64 双精度浮点数</li></ul><h3 id="复数型"><a href="#复数型" class="headerlink" title="复数型"></a>复数型</h3><ul><li>complex64 复数的实部和虚部为32位浮点数</li><li>complex128 复数的实部和虚部为64位浮点数</li></ul><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名是对一个类型的另一种命名。</p><h3 id="具名类型和无名类型"><a href="#具名类型和无名类型" class="headerlink" title="具名类型和无名类型"></a>具名类型和无名类型</h3><ul><li>具名类型:自定义的类型、泛型实例化类型等</li><li>无名类型:一般是组合类型</li></ul><h2 id="Go语言中的值-Value"><a href="#Go语言中的值-Value" class="headerlink" title="Go语言中的值(Value)"></a>Go语言中的值(Value)</h2><p>值表示程序运行过程中的数据。</p><h3 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h3><p>每个值都有对应的零值。</p><ul><li>bool: false</li><li>数值类型:0</li><li>string: “”</li><li>指针、通道、函数、切片等:nil</li></ul><h3 id="整型字面量"><a href="#整型字面量" class="headerlink" title="整型字面量"></a>整型字面量</h3><p>整型字面量有十进制、八进制、十六进制表示法。</p><p>可以使用_作为分隔符增强可读性。</p><h3 id="浮点数字面量"><a href="#浮点数字面量" class="headerlink" title="浮点数字面量"></a>浮点数字面量</h3><p>浮点数字面量使用小数点表示。</p><h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><p>使用双引号或单引号表示字符串。</p><ul><li>单引号会将值转义成rune类型</li><li>支持转义字符 \n、\t等</li></ul><h3 id="字符字面量"><a href="#字符字面量" class="headerlink" title="字符字面量"></a>字符字面量</h3><p>字符字面量用单引号 ‘ ‘ 表示。</p><p>支持转义字符表示特殊字符。</p><hr><h2 id="值的相关概念"><a href="#值的相关概念" class="headerlink" title="值的相关概念"></a>值的相关概念</h2><h3 id="值的大小"><a href="#值的大小" class="headerlink" title="值的大小"></a>值的大小</h3><p>在Go语言中,可以通过unsafe包中的Sizeof函数获取值所占用的字节大小。</p><h3 id="指针类型的基类型"><a href="#指针类型的基类型" class="headerlink" title="指针类型的基类型"></a>指针类型的基类型</h3><p>如果一个指针的底层类型是*T,那么这个指针的基类型就是T表示的那个类型。</p><h3 id="结构体类型的字段"><a href="#结构体类型的字段" class="headerlink" title="结构体类型的字段"></a>结构体类型的字段</h3><p>结构体类型的字段是构成该结构体的各个成员。</p><p>例如:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>  Author <span class="token builtin">string</span>  Title <span class="token builtin">string</span>  Pages <span class="token builtin">int</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该结构体的字段有:Author、Title、Pages。</p><h3 id="函数类型的签名"><a href="#函数类型的签名" class="headerlink" title="函数类型的签名"></a>函数类型的签名</h3><p>函数签名由函数的参数列表和返回值组成,不包含函数名和方法体。</p><h3 id="类型的方法"><a href="#类型的方法" class="headerlink" title="类型的方法"></a>类型的方法</h3><p>方法是定义在类型上的函数。一个类型的所有方法构成该类型的方法集。</p><h2 id="Go语言中的常量和变量"><a href="#Go语言中的常量和变量" class="headerlink" title="Go语言中的常量和变量"></a>Go语言中的常量和变量</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>使用const关键字声明常量:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> PI <span class="token operator">=</span> <span class="token number">3.14</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常量在编译时会进行自动补全,比如将3.14转换为3.140000。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>使用var关键字声明变量:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> name <span class="token builtin">string</span>name <span class="token operator">=</span> <span class="token string">"Golang"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也可以通过 :&#x3D; 同时声明并初始化变量:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">name <span class="token operator">:=</span> <span class="token string">"Golang"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="字面量默认类型"><a href="#字面量默认类型" class="headerlink" title="字面量默认类型"></a>字面量默认类型</h3><ul><li>字符串字面量的默认类型是string</li><li>布尔字面量的默认类型是bool</li><li>整型字面量的默认类型是int</li><li>浮点数字面量的默认类型是float64</li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>可以通过T(v)语法进行显式类型转换。</p><h2 id="Go语言中的类型转换和常量"><a href="#Go语言中的类型转换和常量" class="headerlink" title="Go语言中的类型转换和常量"></a>Go语言中的类型转换和常量</h2><h3 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h3><p>Go语言中的类型转换比较严格:</p><ul><li>只有兼容的类型可以相互转换,如int64到int</li><li>使用T(v)语法进行显式转换</li></ul><p>一些类型转换示例:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">float32</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span> <span class="token comment">// float64转float32</span><span class="token function">int</span><span class="token punctuation">(</span><span class="token number">1.23</span><span class="token punctuation">)</span> <span class="token comment">//错误,浮点数不能转成int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>Go语言编译器可以自动推断变量类型,这样可以省去显式声明类型。</p><p>主要通过 :&#x3D; 语法实现。</p><h3 id="常量-1"><a href="#常量-1" class="headerlink" title="常量"></a>常量</h3><p>使用const关键字声明常量:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> PI <span class="token operator">=</span> <span class="token number">3.14</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>常量在编译时会进行算术运算和自动补全</li><li>const更像是“绑定”的语义,可以通过另一个常量引用已声明的常量</li></ul><p>常量可以是包级常量或局部常量。</p><h2 id="Go语言常量补全和确定类型"><a href="#Go语言常量补全和确定类型" class="headerlink" title="Go语言常量补全和确定类型"></a>Go语言常量补全和确定类型</h2><h3 id="类型确定的具名常量"><a href="#类型确定的具名常量" class="headerlink" title="类型确定的具名常量"></a>类型确定的具名常量</h3><p>我们可以为常量指定特定的类型:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> X <span class="token builtin">float32</span> <span class="token operator">=</span> <span class="token number">3.14</span><span class="token keyword">const</span> A<span class="token punctuation">,</span> B <span class="token builtin">int64</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="常量声明中的自动补全"><a href="#常量声明中的自动补全" class="headerlink" title="常量声明中的自动补全"></a>常量声明中的自动补全</h3><p>在常量声明中,如果不指定类型和值,那么会自动补全:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> <span class="token punctuation">(</span>   X <span class="token operator">=</span> <span class="token number">3.14</span>   Y   A<span class="token punctuation">,</span> B <span class="token operator">=</span> <span class="token string">"Go"</span><span class="token punctuation">,</span> <span class="token string">"language"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码在编译时会自动补全为:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> <span class="token punctuation">(</span>   X <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">3.14</span>   Y <span class="token builtin">float64</span> <span class="token operator">=</span> <span class="token number">3.14</span>   A<span class="token punctuation">,</span> B <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"Go"</span><span class="token punctuation">,</span> <span class="token string">"language"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>常量声明中的自动补全可以减少重复代码。</p><h2 id="Go语言中的变量声明"><a href="#Go语言中的变量声明" class="headerlink" title="Go语言中的变量声明"></a>Go语言中的变量声明</h2><h3 id="使用iota声明常量"><a href="#使用iota声明常量" class="headerlink" title="使用iota声明常量"></a>使用iota声明常量</h3><p>iota是一个可以自动增长的整数常量。</p><p>在const关键字出现时将被重置为0,每新增一行常量声明将使iota计数一次。</p><p>利用iota可以简化定义枚举和量级的常量。</p><h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h3><p>标准的变量声明:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> name <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"Golang"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以让编译器自动推断类型:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> website <span class="token operator">=</span> <span class="token string">"&lt;https://golang.org>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>建议将变量声明放在一起:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> <span class="token punctuation">(</span>  name <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"Golang"</span>  website <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"&lt;https://golang.org>"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>变量在首次使用前必须声明并初始化。</p><h2 id="Go语言中的赋值语句和作用域"><a href="#Go语言中的赋值语句和作用域" class="headerlink" title="Go语言中的赋值语句和作用域"></a>Go语言中的赋值语句和作用域</h2><h3 id="纯赋值语句"><a href="#纯赋值语句" class="headerlink" title="纯赋值语句"></a>纯赋值语句</h3><p>Go语言不支持链式赋值,每条语句只能有一个赋值操作:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">x <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// 正确</span>x <span class="token operator">=</span> y <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// 错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>常量在声明后不能被再次赋值修改。</p><h3 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h3><p>使用 :&#x3D; 可以声明并初始化变量:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">name <span class="token operator">:=</span> <span class="token string">"Golang"</span> <span class="token comment">// 自动推断为string类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种方法更加简洁。</p><h3 id="常量溢出"><a href="#常量溢出" class="headerlink" title="常量溢出"></a>常量溢出</h3><p>在编译时常量运算不会溢出,只有显式指定类型后才可能溢出。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>变量和常量的作用域可以是包级别或函数内局部。</p><h2 id="Go语言中的运算符"><a href="#Go语言中的运算符" class="headerlink" title="Go语言中的运算符"></a>Go语言中的运算符</h2><p>Go语言支持以下几类运算符:</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>包括 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>等基本算术运算符。</p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>包括 <code>&amp;</code>、<code>|</code>、<code>^</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;</code>等位运算符。</p><p>其中 <code>^</code> 为按位取反,<code>&amp;^</code> 为按位清零。</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>包括 <code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>等比较运算符。</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>包括 <code>&amp;&amp;</code>、<code>||</code>、<code>!</code> 等逻辑运算符。</p><h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><ul><li>支持字符串连接:<code>+</code></li><li>支持自增自减:<code>++</code>、<code>-</code></li><li>不支持幂运算,使用math.Pow函数</li></ul><p>注意移位运算结果为整数,在不同架构上移位会有不同。</p><h2 id="Go语言中的函数声明和调用"><a href="#Go语言中的函数声明和调用" class="headerlink" title="Go语言中的函数声明和调用"></a>Go语言中的函数声明和调用</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>标准的函数声明格式:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">functionName</span><span class="token punctuation">(</span>input1 type1<span class="token punctuation">,</span> input2 type2<span class="token punctuation">)</span> <span class="token punctuation">(</span>output1 type1<span class="token punctuation">,</span> output2 type2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 函数体</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>支持多个参数和返回值</li><li>返回值需要指定类型</li></ul><p>返回值可以命名也可以匿名。</p><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>调用格式为:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">output1<span class="token punctuation">,</span> output2 <span class="token operator">:=</span> <span class="token function">functionName</span><span class="token punctuation">(</span>input1<span class="token punctuation">,</span> input2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用后会进入一个退出阶段完成收尾工作。</p><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>使用函数字面量可以创建匿名函数:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span><span class="token punctuation">(</span>input1<span class="token punctuation">,</span> input2<span class="token punctuation">)</span> <span class="token punctuation">(</span>output1<span class="token punctuation">,</span> output2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>匿名函数可以作为闭包使用。</p><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>Go语言内置了一些常用函数如println、print、new等。</p><h2 id="Go语言中的代码包和模块"><a href="#Go语言中的代码包和模块" class="headerlink" title="Go语言中的代码包和模块"></a>Go语言中的代码包和模块</h2><h3 id="包的引入"><a href="#包的引入" class="headerlink" title="包的引入"></a>包的引入</h3><p>使用import关键字可以导入包:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">import</span> <span class="token string">"math/rand"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>还可以给包取别名:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> f <span class="token string">"fmt"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用<code>.</code>可以匿名导入包。</p><h3 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h3><p>包可以包含一个或多个init函数,它们会在main函数执行前被调用。</p><h3 id="fmt-Printf占位符"><a href="#fmt-Printf占位符" class="headerlink" title="fmt.Printf占位符"></a>fmt.Printf占位符</h3><ul><li>%v 输出值的默认格式</li><li>%T 输出值类型</li><li>%x 十六进制格式</li><li>%s 字符串格式</li></ul><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>模块是相关包的集合,一个模块有自己的模块路径和版本。</p><p>使用go mod可以管理模块依赖。</p><p>合理使用包可以提高代码复用性,理解init函数的执行时机也很重要。</p><h2 id="Go语言中的表达式和语句"><a href="#Go语言中的表达式和语句" class="headerlink" title="Go语言中的表达式和语句"></a>Go语言中的表达式和语句</h2><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>表达式代表一个值或多个值,常见的表达式有:</p><ul><li>字面量、变量</li><li>常量</li><li>返回单个值的函数调用</li><li>通道接收操作(非赋值部分)</li></ul><h3 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h3><p>简单语句在执行时相当于一个整体,主要包括:</p><ul><li>变量简短声明</li><li>赋值语句</li><li>返回单值的函数调用</li><li>通道接收操作</li><li>自增自减语句</li></ul><h3 id="非简单语句"><a href="#非简单语句" class="headerlink" title="非简单语句"></a>非简单语句</h3><p>较复杂的语句不是简单语句,主要有:</p><ul><li>标准变量声明</li><li>常量声明</li><li>类型声明</li><li>代码块</li><li>流程控制语句</li><li>函数声明</li><li>返回语句</li></ul><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>语句表示一个操作,通常由一个或多个子表达式或子语句构成。</p><h2 id="Go语言中的基本流程控制"><a href="#Go语言中的基本流程控制" class="headerlink" title="Go语言中的基本流程控制"></a>Go语言中的基本流程控制</h2><p>Go语言中的基本流程控制语句包括:</p><h3 id="if-else-条件语句"><a href="#if-else-条件语句" class="headerlink" title="if-else 条件语句"></a>if-else 条件语句</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> 条件 <span class="token punctuation">&#123;</span>  <span class="token comment">// 条件成立执行</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 条件不成立执行</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>支持初始化语句,条件表达式必须返回布尔值。</p><h3 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> 初始化语句<span class="token punctuation">;</span> 条件表达式<span class="token punctuation">;</span> 迭代语句 <span class="token punctuation">&#123;</span>  <span class="token comment">// 循环体</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>支持 break 和 continue 语句进行跳转。</p><h3 id="switch-case-语句"><a href="#switch-case-语句" class="headerlink" title="switch-case 语句"></a>switch-case 语句</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">switch</span> 初始化语句<span class="token punctuation">;</span> 比较变量 <span class="token punctuation">&#123;</span>  <span class="token keyword">case</span> 值<span class="token number">1</span><span class="token punctuation">:</span>    <span class="token comment">// 语句</span>  <span class="token keyword">case</span> 值<span class="token number">2</span><span class="token punctuation">:</span>    <span class="token comment">// 语句</span>  <span class="token keyword">default</span><span class="token punctuation">:</span>    <span class="token comment">// 默认语句</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>case执行完毕会自动终止,不需要break。</p><h3 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h3><p>可以无条件跳转,但不推荐使用。</p><h2 id="Go语言中的协程和同步技术"><a href="#Go语言中的协程和同步技术" class="headerlink" title="Go语言中的协程和同步技术"></a>Go语言中的协程和同步技术</h2><h3 id="协程-goroutine"><a href="#协程-goroutine" class="headerlink" title="协程(goroutine)"></a>协程(goroutine)</h3><p>协程是Go语言实现并发的核心方式。</p><p>使用go关键字可以启动一个新的协程执行函数:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 协程中的代码</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>主协程退出时,程序也会退出。</p><h3 id="并发同步"><a href="#并发同步" class="headerlink" title="并发同步"></a>并发同步</h3><p>Go语言需要处理好并发中的同步问题:</p><ul><li>避免数据竞争导致数据不一致</li><li>控制协程的启动、阻塞和解除阻塞</li></ul><h3 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h3><p>sync.WaitGroup可以用于同步协程:</p><ul><li>Add添加任务数</li><li>Done表示任务完成</li><li>Wait等待所有任务完成</li></ul><p>通过协程和同步技术可以实现高效的并发编程。</p><h2 id="Go语言协程的状态和调度"><a href="#Go语言协程的状态和调度" class="headerlink" title="Go语言协程的状态和调度"></a>Go语言协程的状态和调度</h2><h3 id="协程状态"><a href="#协程状态" class="headerlink" title="协程状态"></a>协程状态</h3><p>协程可以处于运行状态或阻塞状态:</p><ul><li>运行状态:正在执行或等待系统调用返回</li><li>阻塞状态:被暂停执行</li></ul><p>所有协程阻塞会导致死锁。</p><h3 id="协程调度"><a href="#协程调度" class="headerlink" title="协程调度"></a>协程调度</h3><p>Go运行时采用MPG模型调度协程:</p><ul><li>M - 系统线程</li><li>P - 逻辑处理器</li><li>G - 协程</li></ul><p>调度规则:</p><ul><li>每个P绑定一个G执行</li><li>G可以被不同M调度执行</li><li>GOMAXPROCS设置最大P数量</li></ul><p>合理设置P的数量可以提高性能。</p><h2 id="Go语言中的延迟函数调用"><a href="#Go语言中的延迟函数调用" class="headerlink" title="Go语言中的延迟函数调用"></a>Go语言中的延迟函数调用</h2><h3 id="defer关键字"><a href="#defer关键字" class="headerlink" title="defer关键字"></a>defer关键字</h3><p>在函数中使用defer会将函数推迟到外层函数返回之后执行:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 将最后执行</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>defer类似栈操作,先进后出。</p><h3 id="延迟调用规则"><a href="#延迟调用规则" class="headerlink" title="延迟调用规则"></a>延迟调用规则</h3><ul><li>defer延迟调用的参数会在声明时求值</li><li>defer内的匿名函数参数在执行时求值</li></ul><h3 id="延迟调用修改返回值"><a href="#延迟调用修改返回值" class="headerlink" title="延迟调用修改返回值"></a>延迟调用修改返回值</h3><p>延迟调用可以修改自己函数的返回值。</p><h2 id="Go语言中的panic和recover"><a href="#Go语言中的panic和recover" class="headerlink" title="Go语言中的panic和recover"></a>Go语言中的panic和recover</h2><p>Go语言中可以通过panic和recover实现类似异常的机制。</p><h3 id="panic函数"><a href="#panic函数" class="headerlink" title="panic函数"></a>panic函数</h3><p>panic函数可以触发当前协程的恐慌状态:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">panic</span><span class="token punctuation">(</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>panic会使程序进入异常状态,如果未处理会导致程序崩溃。</p><h3 id="recover函数"><a href="#recover函数" class="headerlink" title="recover函数"></a>recover函数</h3><p>recover可以获取panic传递的值,并中止panic状态:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>recover仅在延迟函数中有效。</p><h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 捕获panic</span>  <span class="token comment">// 进行错误处理</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span> <span class="token comment">// 触发panic</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用panic和recover可以实现错误处理,但是不是必须,也可以通过返回错误的方式。</p><h2 id="Go语言中的接口-Interface"><a href="#Go语言中的接口-Interface" class="headerlink" title="Go语言中的接口(Interface)"></a>Go语言中的接口(Interface)</h2><p>接口(Interface)是Go语言实现抽象和封装的主要方式。</p><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p>接口使用type定义:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Reader <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>  <span class="token function">Read</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接口包含方法签名的集合,不包含实现。</p><h3 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h3><p>一个类型通过实现接口中所有方法来实现接口:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> File <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>File<span class="token punctuation">)</span> <span class="token function">Read</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 方法实现</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>File实现了Reader接口。</p><h3 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h3><p>接口值包含一个具体类型和具体值:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> r Readerr <span class="token operator">=</span> <span class="token operator">&amp;</span>File<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>r包含具体类型*File和值f。</p><p>接口需要实现类型来提供值。接口值调用会调用具体类型的值的方法。</p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> Golang </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> Go语言与区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的Python编程学习笔记总结</title>
      <link href="/article/8e458014.html"/>
      <url>/article/8e458014.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础数据类型"><a href="#一、基础数据类型" class="headerlink" title="一、基础数据类型"></a>一、<strong><strong>基础数据类型</strong></strong></h2><h3 id="List、Tuple、Dict、Set四种数据类型"><a href="#List、Tuple、Dict、Set四种数据类型" class="headerlink" title="List、Tuple、Dict、Set四种数据类型"></a><strong>List、Tuple、Dict、Set四种数据类型</strong></h3><h4 id="1-List-和-Tuple"><a href="#1-List-和-Tuple" class="headerlink" title="1. List 和 Tuple"></a><strong>1. List 和 Tuple</strong></h4><ul><li>List 是一种可变的有序表,可以随时添加和删除其中的元素</li><li>Tuple 是一种不可变的有序序列,不能对其进行修改</li></ul><h4 id="2-Dict-和-Set"><a href="#2-Dict-和-Set" class="headerlink" title="2. Dict 和 Set"></a><strong>2. Dict 和 Set</strong></h4><ul><li>Dict 是一种映射类型,key-value 对的集合</li><li>Set 是一种无序不重复元素的集合</li></ul><h4 id="3-定义可变参数和默认参数"><a href="#3-定义可变参数和默认参数" class="headerlink" title="3. 定义可变参数和默认参数"></a><strong>3. 定义可变参数和默认参数</strong></h4><ul><li><p>写函数定义可变参数时,在参数前加&#96;&#96;,参数本身就从 list 变成了 tuple</p></li><li><p>定义默认参数需要指向不变对象:</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">pythonCopy codedef func<span class="token punctuation">(</span>L <span class="token operator">=</span> <span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> L <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        L <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>nums</code> 表示把 <code>nums</code> 这个 list 的所有元素作为可变参数传进去。这种写法相当有用,而且很常见。</p></li></ul><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017261630425888">提高自己的姿势水平 from</a></p><h3 id="4-arguments"><a href="#4-arguments" class="headerlink" title="4 arguments"></a><strong>4 arguments</strong></h3><h4 id="可变参数和关键字参数"><a href="#可变参数和关键字参数" class="headerlink" title="可变参数和关键字参数"></a><strong>可变参数和关键字参数</strong></h4><ul><li>对于位置参数,想要参数可变,最早想到传入一个 list 或者 tuple。如果使用可变参数的话:<ul><li>可变参数(<code>args</code>)允许你传入0个或任意个参数,这些可变参数在函数调用时自动组装为一个 tuple。</li><li>而关键字参数(<code>*kw</code>)允许你传入0个或任意个含参数名的参数,这些关键字参数在函数内部自动组装为一个 dict。</li></ul></li></ul><h4 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a><strong>尾递归优化</strong></h4><ul><li>尾递归调用时,如果做了优化,栈不会增长,因此,无论多少次调用也不会导致栈溢出。</li><li>遗憾的是,大多数编程语言没有针对尾递归做优化,Python 解释器也没有做优化,所以,即使把 fact(n) 函数改成尾递归方式,也会导致栈溢出。</li></ul><h3 id="Slice-和迭代"><a href="#Slice-和迭代" class="headerlink" title="Slice 和迭代"></a><strong>Slice 和迭代</strong></h3><h4 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a><strong>Slice</strong></h4><p><strong>列表名[start : stop : step]</strong></p><ul><li><p>取前10个数:</p><p>  <code>[:10]</code> 或者 <code>[0:10]</code></p></li><li><p>左闭右开</p></li><li><p>取11到20:</p><p>  <code>[10:20]</code></p></li><li><p>取后10个数:</p><p>  <code>[-10:]</code></p></li><li><p>所有数字,隔五个取一个:</p><p>  <code>[::5]</code></p></li></ul><p>List、Tuple、String 都可以使用 slice。</p><h4 id="使用切片和递归移除空白字符"><a href="#使用切片和递归移除空白字符" class="headerlink" title="使用切片和递归移除空白字符"></a><strong>使用切片和递归移除空白字符</strong></h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">pythonCopy codedef trim<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> s<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> trim<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">elif</span> s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> trim<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>理论上生成{1x1,2x2,3x3,…,10x10}可以利用循环:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">L <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    L<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x <span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但是如果使用列表生成式:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">[</span>x <span class="token operator">*</span> x <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="添加条件筛选"><a href="#添加条件筛选" class="headerlink" title="添加条件筛选"></a>添加条件筛选</h4><p>可以在列表生成式中加上 if 来筛选:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">[</span>x <span class="token operator">*</span> x <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">if</span> x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h4><p>可以使用双循环生成全排列:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">[</span>m <span class="token operator">+</span> n <span class="token keyword">for</span> m <span class="token keyword">in</span> <span class="token string">'ABC'</span> <span class="token keyword">for</span> n <span class="token keyword">in</span> <span class="token string">'XYZ'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="结合字符串方法"><a href="#结合字符串方法" class="headerlink" title="结合字符串方法"></a>结合字符串方法</h4><p>将字符串列表转换为小写:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">L <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Hello'</span><span class="token punctuation">,</span> <span class="token string">'World'</span><span class="token punctuation">,</span> <span class="token string">'IBM'</span><span class="token punctuation">,</span> <span class="token string">'Apple'</span><span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> s <span class="token keyword">in</span> L<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="if-else-用法"><a href="#if-else-用法" class="headerlink" title="if-else 用法"></a>if-else 用法</h3><p>在一个列表生成式中,for 前面的 if-else 是表达式,而 for 后面的 if 是过滤条件,不能带 else。</p><h3 id="生成器-generator"><a href="#生成器-generator" class="headerlink" title="生成器 generator"></a>生成器 generator</h3><p>在 Python 中,这种一边循环一边计算的机制,称为生成器(generator)。</p><h4 id="yield-语句"><a href="#yield-语句" class="headerlink" title="yield 语句"></a>yield 语句</h4><p>注意,赋值语句:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a <span class="token operator">+</span> b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>相当于:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">t <span class="token operator">=</span> <span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token comment"># t是一个tuple</span>a <span class="token operator">=</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>b <span class="token operator">=</span> t<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>yield</strong> 与 <strong>print</strong> 不同,不会输出到屏幕。</p><h4 id="获取返回值"><a href="#获取返回值" class="headerlink" title="获取返回值"></a>获取返回值</h4><p>但是用 for 循环调用 generator 时,拿不到 generator 的 return 语句的返回值。如果想要拿到返回值,必须捕获 StopIteration 错误,返回值包含在 StopIteration 的 value 中:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">g <span class="token operator">=</span> fib<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    x <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'g:'</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>    x <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token keyword">except</span> StopIteration <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Generator return value:'</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器 Iterator"></a>迭代器 Iterator</h3><p>可以被 next() 函数调用并不断返回下一个值的对象称为迭代器(Iterator)。</p><ul><li><p>生成器都是 Iterator 对象,但 list、dict、str 虽然是可迭代的(Iterable),却不是 Iterator。</p></li><li><p>把 list、dict、str 等 Iterable 变成 Iterator 可以使用 iter() 函数:</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">isinstance</span><span class="token punctuation">(</span><span class="token builtin">iter</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Iterator<span class="token punctuation">)</span> <span class="token comment"># True</span><span class="token builtin">isinstance</span><span class="token punctuation">(</span><span class="token builtin">iter</span><span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Iterator<span class="token punctuation">)</span> <span class="token comment"># True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="二、函数定义及使用"><a href="#二、函数定义及使用" class="headerlink" title="二、函数定义及使用"></a>二、函数定义及使用</h2><h3 id="函数式编程-高阶函数-FP-Higher-order-function"><a href="#函数式编程-高阶函数-FP-Higher-order-function" class="headerlink" title="函数式编程:高阶函数 FP:Higher-order function"></a>函数式编程:高阶函数 <strong><strong>FP:Higher-order function</strong></strong></h3><h4 id="高阶函数Higher-order-function"><a href="#高阶函数Higher-order-function" class="headerlink" title="高阶函数Higher-order function"></a>高阶函数<strong><strong>Higher-order function</strong></strong></h4><p>高阶函数的优势:</p><ul><li><p>变量可以指向函数</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">f <span class="token operator">=</span> <span class="token builtin">abs</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>函数名也是变量</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">abs</span> <span class="token operator">=</span> <span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>编写高阶函数目的是让函数可以相互嵌套调用。</p><h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p>比如我们有一个函数 <code>f(x) = x^2</code>,要把这个函数作用在一个列表 <code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code> 上,就可以用 <code>map()</code> 实现:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">map</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>等价于利用循环:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">L <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> n <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    L<span class="token punctuation">.</span>append<span class="token punctuation">(</span>f<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h4><p><code>reduce()</code> 把一个函数作用在一个序列 <code>[x1, x2, x3, ...]</code> 上,这个函数必须接收两个参数,<code>reduce()</code> 把结果继续和序列的下一个元素做累积计算。</p><h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p><code>filter()</code> 把传入的函数依次作用于每个元素,然后根据返回值是 <code>True</code> 还是 <code>False</code> 决定保留还是丢弃该元素。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">not_empty</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> s <span class="token keyword">and</span> s<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">filter</span><span class="token punctuation">(</span>not_empty<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># ['A', 'B', 'C']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h4><p><code>sorted()</code> 可以对 list、string 等进行排序。要进行反向排序,可以传入 <code>reverse=True</code> 参数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">sorted</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'Zoo'</span><span class="token punctuation">,</span> <span class="token string">'Credit'</span><span class="token punctuation">,</span> <span class="token string">'bob'</span><span class="token punctuation">,</span> <span class="token string">'about'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="参数key"><a href="#参数key" class="headerlink" title="参数key"></a>参数key</h4><p><code>key</code> 参数指定排序时所用的映射函数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">L <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'Bob'</span><span class="token punctuation">,</span> <span class="token number">75</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'Adam'</span><span class="token punctuation">,</span> <span class="token number">92</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'Bart'</span><span class="token punctuation">,</span> <span class="token number">66</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'Lisa'</span><span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">by_name</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token builtin">sorted</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> key<span class="token operator">=</span>by_name<span class="token punctuation">)</span><span class="token comment"># [('Adam', 92), ('Bart', 66), ('Bob', 75), ('Lisa', 88)]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017408670135712#0">学习一个</a></p><h3 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h3><h4 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h4><p>相关参数和变量都保存在返回的函数中,这种称为“闭包(Closure)”的程序结构拥有极大的威力。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>返回闭包时牢记一点:返回函数不要引用任何循环变量,或者后续会发生变化的变量。</p><p><strong>关于闭包值得一提的是:</strong></p><p>从函数中返回函数其实并不需要在一个函数里去执行另一个函数,我们也可以将其作为输出返回出来:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">hi</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"yasoob"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token string">"now you are in the greet() function"</span>  <span class="token keyword">return</span> greeta <span class="token operator">=</span> hi<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># a 现在指向了 hi() 函数中的 greet() 函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 if&#x2F;else 语句中我们返回 greet 和 welcome,而不是 greet() 和 welcome()。因为带括号会执行函数,而没有括号可以赋值给其他变量。</p><p>括号代表函数执行,可以重复执行。</p><h4 id="nonlocal"><a href="#nonlocal" class="headerlink" title="nonlocal"></a>nonlocal</h4><p>可以通过 nonlocal 改变全局变量。</p><p><strong>练习:</strong></p><p>利用闭包返回一个计数器函数,每次调用它返回递增整数:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">createCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    x <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">nonlocal</span> x        x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">return</span> x    <span class="token keyword">return</span> counter<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="装饰器Decorator"><a href="#装饰器Decorator" class="headerlink" title="装饰器Decorator"></a>装饰器Decorator</h3><p><strong>装饰器相关要注意闭包的用法。</strong></p><p>假设我们要增强 now() 函数的功能,比如在函数调用前后自动打印日志,但又不希望修改 now() 函数的定义,这种在代码运行期间动态增加功能的方式,称之为“装饰器”(Decorator)。</p><h4 id="基本装饰器写法"><a href="#基本装饰器写法" class="headerlink" title="基本装饰器写法"></a>基本装饰器写法</h4><p>一个不带参数的装饰器写法如下:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> functools<span class="token keyword">def</span> <span class="token function">log</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token decorator annotation punctuation">@functools<span class="token punctuation">.</span>wraps</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'call %s():'</span> <span class="token operator">%</span> func<span class="token punctuation">.</span>__name__<span class="token punctuation">)</span>        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="针对带参数的装饰器"><a href="#针对带参数的装饰器" class="headerlink" title="针对带参数的装饰器"></a>针对带参数的装饰器</h4><p>如果装饰器本身需要传入参数,可以编写一个返回装饰器的高阶函数:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> functools<span class="token keyword">def</span> <span class="token function">log</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">decorator</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token decorator annotation punctuation">@functools<span class="token punctuation">.</span>wraps</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%s %s():'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>text<span class="token punctuation">,</span> func<span class="token punctuation">.</span>__name__<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span>        <span class="token keyword">return</span> wrapper    <span class="token keyword">return</span> decorator<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注意返回值"><a href="#注意返回值" class="headerlink" title="注意返回值"></a>注意返回值</h4><p><strong>不能忘记返回函数调用的返回值</strong>,否则会导致修饰后函数失效。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 错误示例</span><span class="token keyword">def</span> <span class="token function">metric</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span class="token punctuation">:</span>        fn<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span>        <span class="token comment"># 这里应该return fn(*args, **kw)</span>    <span class="token keyword">return</span> wrapper<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>装饰器的效果是你传给它一个函数,它返回一个新的函数。</p><h3 id="偏函数-Partial-Function"><a href="#偏函数-Partial-Function" class="headerlink" title="偏函数 Partial Function"></a>偏函数 Partial Function</h3><p>当函数的参数个数太多,需要简化时,可以使用 <code>functools.partial</code> 创建一个新的函数,这个新函数可以固定住原函数的部分参数,从而在调用时更简单。</p><p><strong>举个例子,二进制字符串转整数的函数:</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token string">'12345'</span><span class="token punctuation">,</span> base<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是这样仍然稍显麻烦,可以使用 <code>functools.partial</code> 使得调用更简洁:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> functoolsint2 <span class="token operator">=</span> functools<span class="token punctuation">.</span>partial<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> base<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>int2<span class="token punctuation">(</span><span class="token string">'1000000'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过偏函数,可以使代码更加简洁</p><h2 id="三、面向对象编程"><a href="#三、面向对象编程" class="headerlink" title="三、面向对象编程"></a>三、面向对象编程</h2><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>面向对象编程(Object Oriented Programming, OOP)是一种程序设计思想。OOP 把对象作为程序的基本单元,一个对象包含了数据和操作数据的函数。</p><ul><li>类是创建实例的模板,而实例则是具体的对象,各个实例的数据互相独立。</li><li>方法就是与实例绑定的函数,可以直接访问实例的数据。</li><li>通过在实例上调用方法,直接操作对象内部的数据,无需知道方法内部实现。</li></ul><p>Python 允许对实例变量绑定任何数据,也就是说,两个实例变量即使是同一个类的不同实例,但拥有的变量名称也可能不同。</p><p><strong>练习:</strong></p><p>请把下面的 Student 类的 gender 字段对外隐藏起来:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> gender<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>gender <span class="token operator">=</span> gender<span class="token comment"># 修改如下:</span><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> gender<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>__gender <span class="token operator">=</span> gender<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问 gender 字段改为通过方法:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_gender</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> self<span class="token punctuation">.</span>__genderbart <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token string">'Bart'</span><span class="token punctuation">,</span> <span class="token string">'male'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>bart<span class="token punctuation">.</span>get_gender<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a><strong>继承和多态</strong></h3><ul><li>子类继承父类的所有属性和方法。</li><li>子类可以定义自己特有的方法,也可以对父类方法进行重写,这称为多态。</li><li>Python 中,类可以作为数据类型传入函数,根据鸭子类型,不关心参数是什么类型,只关心参数是否有调用的属性和方法。</li></ul><p>例如:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pythonCopy codeclass Animal<span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Animal is running...'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span>Animal<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Dog is running...'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span>animal<span class="token punctuation">)</span><span class="token punctuation">:</span>    animal<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span>dog <span class="token operator">=</span> Dog<span class="token punctuation">(</span><span class="token punctuation">)</span>func<span class="token punctuation">(</span>dog<span class="token punctuation">)</span><span class="token comment"># Dog is running...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里 <code>func()</code> 函数接收一个 <code>Animal</code> 类型的参数。在调用时,不关心它的实际类型是 <code>Animal</code> 还是 <code>Dog</code>,只要保证传入的对象有 <code>run()</code> 方法即可。这就是多态的一种体现。</p><h3 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h3><p><strong>判断类型</strong></p><ul><li><p>使用 <code>type()</code> 获取类型:</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">type</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span> <span class="token comment"># &lt;class 'int'></span><span class="token builtin">type</span><span class="token punctuation">(</span><span class="token string">'str'</span><span class="token punctuation">)</span> <span class="token comment"># &lt;class 'str'></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>isinstance()</code> 判断类型关系:</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">isinstance</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">,</span> <span class="token builtin">tuple</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># True</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><strong>获取属性和方法</strong></p><ul><li><p><code>dir()</code> 可以获取对象的所有属性和方法名。</p></li><li><p><code>getattr()</code>、<code>setattr()</code>以及 <code>hasattr()</code> 可以直接操作对象属性:</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">hasattr</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">)</span> <span class="token comment"># 是否有属性'x'</span><span class="token builtin">getattr</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">)</span> <span class="token comment"># 获取属性'x'</span><span class="token builtin">setattr</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span> <span class="token comment"># 设置一个属性'y'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h3><ul><li>实例属性属于各个实例所有,互不干扰。</li><li>不要对实例属性和类属性使用相同的名字,否则将产生难以发现的错误。</li></ul><p><strong>练习:</strong></p><p>为 Student 类增加一个类属性,每创建一个实例,该属性自动增加:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name        Student<span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span><span class="token comment"># 测试:</span>bart <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token string">'Bart'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>Student<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token comment"># 1</span>lisa <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token string">'Lisa'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>Student<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token comment"># 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么要使用 <code>Student.count</code> 而不能是 <code>self.count</code>?</p><p>因为 <code>self.count</code> 是实例属性,而 <code>Student.count</code> 是类属性。两者不应该使用相同的名字。</p><h3 id="多重继承和MixIn"><a href="#多重继承和MixIn" class="headerlink" title="多重继承和MixIn"></a>多重继承和MixIn</h3><ul><li>通过多重继承,一个子类可以同时获得多个父类的所有功能。</li><li><strong>MixIn的目的就是给一个类增加多个功能,通过多重继承来组合多个MixIn的功能,而不是设计多层次的复杂继承关系。</strong></li><li>MixIn 类包含其他类要用到的方法,但不必充当父类。</li></ul><p>MixIn 的优点:</p><ul><li>组合胜于继承</li><li>避免复杂的多继承</li></ul><p>例如:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">RunMixin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Running...'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">FlyMixin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">fly</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Flying...'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span>RunMixin<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span class="token keyword">class</span> <span class="token class-name">Bird</span><span class="token punctuation">(</span>FlyMixin<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="定制类和枚举类"><a href="#定制类和枚举类" class="headerlink" title="定制类和枚举类"></a>定制类和枚举类</h3><h4 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h4><p>可以针对不同的场景定制类:</p><ul><li><code>__str__()</code> 定制打印输出</li><li><code>__iter__()</code> 定制为可迭代对象</li><li><code>__getitem__()</code> 定制切片</li><li><code>__getattr__()</code> 动态返回属性</li><li><code>__call__()</code> 定制为可调用对象</li></ul><p>例如:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Chain</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> path<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>_path <span class="token operator">=</span> path    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> Chain<span class="token punctuation">(</span><span class="token string">'%s/%s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>_path<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_path<span class="token keyword">print</span><span class="token punctuation">(</span>Chain<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>users<span class="token punctuation">(</span><span class="token string">'michael'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>repos<span class="token punctuation">)</span><span class="token comment"># /users/michael/repos</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>枚举类可以定义常量,例如:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> enum <span class="token keyword">import</span> Enum<span class="token keyword">class</span> <span class="token class-name">Gender</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>    Male <span class="token operator">=</span> <span class="token number">1</span>    Female <span class="token operator">=</span> <span class="token number">2</span><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> gender<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name        self<span class="token punctuation">.</span>gender <span class="token operator">=</span> genderbart <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token string">'Bart'</span><span class="token punctuation">,</span> Gender<span class="token punctuation">.</span>Male<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用元类"><a href="#使用元类" class="headerlink" title="使用元类"></a>使用元类</h3><p>Python 中类也是对象,类型就是 <code>type</code>。</p><h4 id="使用-type-创建类"><a href="#使用-type-创建类" class="headerlink" title="使用 type 创建类"></a>使用 type 创建类</h4><p>要创建一个类对象,可以使用 <code>type()</code> 函数:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fn</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">)</span>Hello <span class="token operator">=</span> <span class="token builtin">type</span><span class="token punctuation">(</span><span class="token string">'Hello'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">dict</span><span class="token punctuation">(</span>hello<span class="token operator">=</span>fn<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>type()</code> 传入3个参数:</p><ul><li>类名</li><li>继承的父类集合,注意 Python 支持多重继承</li><li>类的方法名称与函数绑定</li></ul><h4 id="metaclass"><a href="#metaclass" class="headerlink" title="metaclass"></a>metaclass</h4><p>元类可以控制类的创建过程:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># metaclass是类的模板,所以必须从`type`类型派生:</span><span class="token keyword">class</span> <span class="token class-name">ListMetaclass</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> name<span class="token punctuation">,</span> bases<span class="token punctuation">,</span> attrs<span class="token punctuation">)</span><span class="token punctuation">:</span>        attrs<span class="token punctuation">[</span><span class="token string">'add'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">lambda</span> self<span class="token punctuation">,</span> value<span class="token punctuation">:</span> self<span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token builtin">type</span><span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">,</span> name<span class="token punctuation">,</span> bases<span class="token punctuation">,</span> attrs<span class="token punctuation">)</span><span class="token comment"># 指示使用ListMetaclass来定制类</span><span class="token keyword">class</span> <span class="token class-name">MyList</span><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">,</span> metaclass<span class="token operator">=</span>ListMetaclass<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span>L <span class="token operator">=</span> MyList<span class="token punctuation">(</span><span class="token punctuation">)</span>L<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>L<span class="token comment"># [1]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、其他核心概念"><a href="#四、其他核心概念" class="headerlink" title="四、其他核心概念"></a>四、其他核心概念</h2><h3 id="slots"><a href="#slots" class="headerlink" title="slots"></a><strong>slots</strong></h3><p><img src="https://raw.githubusercontent.com/SKDDJ/picgoimgbed/main/202307291900639.jpeg"></p><h3 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h3><p>@property 装饰器可以让方法像属性一样访问,既能检查参数,又可以简化代码。</p><p><strong>注意方法名不要和实例变量同名,以免递归错误。</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> birth<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>_birth <span class="token operator">=</span> birth    <span class="token decorator annotation punctuation">@property</span>    <span class="token keyword">def</span> <span class="token function">birth</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_birth<span class="token comment"># 方法名和实例变量名不同,就避免了递归错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>练习:</strong></p><p>请利用 @property 给一个 Screen 对象添加 width、height 属性,以及一个只读属性 resolution:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Screen</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>_width <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>_height <span class="token operator">=</span> <span class="token number">0</span>    <span class="token decorator annotation punctuation">@property</span>    <span class="token keyword">def</span> <span class="token function">width</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_width    <span class="token decorator annotation punctuation">@width<span class="token punctuation">.</span>setter</span>    <span class="token keyword">def</span> <span class="token function">width</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">'width must be an integer!'</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> value <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">'width must be positive!'</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>_width <span class="token operator">=</span> value    <span class="token decorator annotation punctuation">@property</span>    <span class="token keyword">def</span> <span class="token function">height</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_height    <span class="token decorator annotation punctuation">@height<span class="token punctuation">.</span>setter</span>    <span class="token keyword">def</span> <span class="token function">height</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 同样需要判断类型和值</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token decorator annotation punctuation">@property</span>    <span class="token keyword">def</span> <span class="token function">resolution</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_width <span class="token operator">*</span> self<span class="token punctuation">.</span>_height<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="模块-Module"><a href="#模块-Module" class="headerlink" title="模块 Module"></a>模块 Module</h3><p><strong>使用模块的好处:</strong></p><ol><li>最大的好处是大大提高了代码的可维护性</li><li>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中。</li></ol><p><strong>模块作用域:</strong></p><ul><li>在一个模块中,我们可能会定义很多函数和变量,但有的我们希望被外部访问,有的希望仅在模块内部使用。</li><li>正常的函数和变量名是公开的(public),可以被直接引用,比如:<code>abc</code>, <code>x123</code>, <code>PI</code> 等。</li><li><code>__xxx__</code> 这样的变量是特殊变量,可以被直接引用,但是有特殊用途,比如 <code>__author__</code>, <code>__name__</code> 就是特殊变量。</li><li><code>_xxx</code> 和 <code>__xxx</code> 这样的函数或变量就是非公开的(private),不应该被直接引用。</li><li><code>__name__</code> 变量取值为模块名字,当模块被直接执行时值为<code>&#39;__main__&#39;</code>。</li></ul><h3 id="错误处理和调试"><a href="#错误处理和调试" class="headerlink" title="错误处理和调试"></a>错误处理和调试</h3><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><ul><li>测试数据出错时,可以用 <code>print()</code> 打印错误信息,或者使用 <code>assert</code> 进行断言。</li><li><code>assert</code> 后面表达式若为 False 将抛出 <code>AssertionError</code>。</li></ul><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><ul><li><p>使用 <code>print()</code> 打印变量信息,可以查看程序执行过程。</p></li><li><p>使用 debugger 调试,如 pdb:</p>  <pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pdbpdb<span class="token punctuation">.</span>set_trace<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>  程序运行会自动在此处停住,可以查看当前堆栈变量信息,或者逐行执行代码。</p></li><li><p>IDE也提供GUI调试,如设置断点,查看变量信息等。</p></li></ul><p>标准库 <code>logging</code> 模块可以进行日志记录,设置日志级别、日志文件保存等,方便追踪问题。</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>序列化就是将对象转换为可存储或传输的格式,在Python中可以使用pickle模块。</p><h4 id="pickle-序列化"><a href="#pickle-序列化" class="headerlink" title="pickle 序列化"></a>pickle 序列化</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pickledata <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span> <span class="token comment"># 对象</span>b <span class="token operator">=</span> pickle<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token comment"># 序列化为bytes</span>f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'data.pkl'</span><span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span>pickle<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>data<span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token comment"># 写入文件</span>f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>f <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'data.pkl'</span><span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span>d <span class="token operator">=</span> pickle<span class="token punctuation">.</span>load<span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token comment"># 从文件读取</span>f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>pickle可以序列化大多数Python对象,但有些类型可能需要 handling 模块支持。</p><h4 id="JSON-序列化"><a href="#JSON-序列化" class="headerlink" title="JSON 序列化"></a>JSON 序列化</h4><p>JSON是一种通用的数据格式,也可以用于序列化。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> jsonjson<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token comment"># 序列化为JSON字符串</span>json<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>data<span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token comment"># 写入JSON文件</span>json_str <span class="token operator">=</span> <span class="token string">'&#123;"name": "Bob"&#125;'</span>data <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>json_str<span class="token punctuation">)</span> <span class="token comment"># 反序列化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JSON支持更多语言,可以作为通用数据格式,但只能序列化基本类型。</p><h3 id="Turtle图形"><a href="#Turtle图形" class="headerlink" title="Turtle图形"></a>Turtle图形</h3><p>Turtle可以用来绘制简单的图形。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> turtleturtle<span class="token punctuation">.</span>forward<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment"># 向前移动100单位长度</span>turtle<span class="token punctuation">.</span>right<span class="token punctuation">(</span><span class="token number">90</span><span class="token punctuation">)</span> <span class="token comment"># 向右旋转90度</span>turtle<span class="token punctuation">.</span>width<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment"># 设置画笔宽度</span>turtle<span class="token punctuation">.</span>pencolor<span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">)</span>turtle<span class="token punctuation">.</span>begin_fill<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 开始填充图形</span><span class="token comment"># 绘制形状</span>turtle<span class="token punctuation">.</span>end_fill<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 填充完成</span>turtle<span class="token punctuation">.</span>done<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 保持窗口打开</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此</p><p>已学习的主要内容:</p><ul><li>基础数据类型:字符串、列表、元组、字典、集合</li><li>函数:定义、参数、递归、高阶函数</li><li>面向对象编程:类、对象、继承、多态</li><li>错误处理和调试</li><li>模块、包管理</li><li>文件和IO</li><li>序列化:pickle、JSON</li></ul><p>进阶内容:</p><ul><li>网络编程:Socket、WSGI、Web框架</li><li>GUI编程:Tkinter、PyQt等</li><li>科学计算和数据分析:NumPy、Pandas、Matplotlib等</li><li>Web爬虫:requests、BeautifulSoup、Scrapy等</li><li>图像处理:OpenCV、Pillow等</li><li>神经网络:TensorFlow、PyTorch等</li><li>游戏开发:PyGame等</li><li>系统管理:进程、线程、正则表达式等</li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程学习 </tag>
            
            <tag> 基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
